[
  {
    "title": "Equal Frequencies",
    "url": "https://codeforces.com/problemset/problem/1781/C",
    "history": "Let' s call a string balanced if all characters that are present in it appear the same number of times. For example, \" coder\" , \" appall\" , and \" ttttttt\" are balanced, while \" wowwow\" and \" codeforces\" are not. You are given a string s of length n consisting of lowercase English letters. Find a balanced string t of the same length n consisting of lowercase English letters that is different from the string s in as few positions as possible. In other words, the number of indices i such that s_ i t_ i should be as small as possible.",
    "input": "Each test contains multiple test cases. The first line contains the number of test cases t ( 1 \u2264 t \u2264 10^ 4 ) . The description of the test cases follows. Each test case consists of two lines. The first line contains a single integer n ( 1 \u2264 n \u2264 10^ 5 ) \u2014 the length of the string s . The second line contains the string s of length n consisting of lowercase English letters. It is guaranteed that the sum of n over all test cases does not exceed 10^ 5 .",
    "output": "For each test case, print the smallest number of positions where string s and a balanced string t can differ, followed by such a string t . If there are multiple solutions, print any. It can be shown that at least one balanced string always exists.",
    "note": "In the first test case, the given string \" hello\" is not balanced: letters ' h' , ' e' , and ' o' appear in it once, while letter ' l' appears twice. On the other hand, string \" helno\" is balanced: five distinct letters are present in it, and each of them appears exactly once. Strings \" hello\" and \" helno\" differ in just one position: the fourth character. Other solutions are possible too. In the second test case, string \" codefofced\" is balanced since only letters ' c' , ' o' , ' d' , ' e' , and ' f' are present in it, and each of them appears exactly twice. In the third test case, string \" eeeee\" is balanced since only letter ' e' is present in it. In the fourth test case, the given string \" appall\" is already balanced.",
    "topics": [
      "brute force",
      "constructive algorithms",
      "greedy",
      "implementation",
      "sortings",
      "strings"
    ]
  },
  {
    "title": "Hall of Fame",
    "url": "https://codeforces.com/problemset/problem/1779/A",
    "history": "Thalia is a Legendary Grandmaster in chess. She has n trophies in a line numbered from 1 to n ( from left to right) and a lamp standing next to each of them ( the lamps are numbered as the trophies) . A lamp can be directed either to the left or to the right, and it illuminates all trophies in that direction ( but not the one it is next to) . More formally, Thalia has a string s consisting only of characters ' L' and ' R' which represents the lamps' current directions. The lamp i illuminates: trophies 1, 2, . . . , i- 1 if s_ i is ' L' ; trophies i+ 1, i+ 2, . . . , n if s_ i is ' R' . She can perform the following operation at most once: Choose an index i ( 1 \u2264 i < n ) ; Swap the lamps i and i+ 1 ( without changing their directions) . That is, swap s_ i with s_ i+ 1 . Thalia asked you to illuminate all her trophies ( make each trophy illuminated by at least one lamp) , or to tell her that it is impossible to do so. If it is possible, you can choose to perform an operation or to do nothing. Notice that lamps cannot change direction, it is only allowed to swap adjacent ones.",
    "input": "Each test contains multiple test cases. The first line contains the number of test cases t ( 1 \u2264 t \u2264 10 000 ) . The description of the test cases follows. The first line of each test case contains a positive integer n ( 2 \u2264 n \u2264 100 000 ) \u2014 the number of trophies. The second line of each test case contains a string s of length n consisting only of characters ' L' and ' R' \u2014 the i - th character describes the direction of the i - th lamp. It is guaranteed that the sum of n over all test cases does not exceed 100 000 .",
    "output": "For each test case print - 1 if it is impossible to illuminate all trophies by performing one operation ( or doing nothing) . Otherwise, print 0 if you choose not to perform the operation ( i. e. , the trophies are illuminated by the initial positioning of the lamps) , or an index i ( 1 \u2264 i < n ) if you choose to swap lamps i and i+ 1 . If there are multiple answers, print any.",
    "note": "In the first example, it is possible to swap lamps 1 and 2 , or do nothing. In any case, the string \" LL\" is obtained. Not all trophies are illuminated since trophy 2 is not illuminated by any lamp \u2014 lamp 1 illuminates nothing and lamp 2 illuminates only the trophy 1 . In the second example, it is necessary to swap lamps 1 and 2 . The string becomes \" RL\" . Trophy 1 is illuminated by lamp 2 and trophy 2 is illuminated by lamp 1 , hence it is possible to illuminate all trophies. In the third example, all trophies are initially illuminated \u2014 hence, not performing any operation is a valid solution. In the last two examples performing swaps is not necessary as all trophies are illuminated initially. But, the presented solutions are also valid.",
    "topics": [
      "constructive algorithms",
      "greedy",
      "strings"
    ]
  },
  {
    "title": "Hossam and Range Minimum Query",
    "url": "https://codeforces.com/problemset/problem/1771/F",
    "history": "Hossam gives you a sequence of integers a_ 1, a_ 2, . . . , a_ n of length n . Moreover, he will give you q queries of type ( l, r) . For each query, consider the elements a_ l, a_ l + 1, . . . , a_ r . Hossam wants to know the smallest number in this sequence, such that it occurs in this sequence an odd number of times. You need to compute the answer for each query before process the next query.",
    "input": "The first line of the input contains one integer n ( 1 \u2264 n \u2264 2 \u00b7 10^ 5 ) , the length of the sequence. The second line contains n integers a_ 1, a_ 2, . . . , a_ n ( 1 \u2264 a_ i \u2264 10^ 9 ) . The third line contains one integer q ( 1 \u2264 q \u2264 2 \u00b7 10^ 5 ) , the number of queries. Each of the next q lines contains two integers a and b ( 0 \u2264 a, b \u2264 2 \u00b7 10^ 9 ) , the numbers used to encode the queries. Let ans_ i be the answer on the i - th query, and ans_ 0 be zero. Then l_ i = a_ i \u2295ans_ i - 1, r_ i = b_ i \u2295ans_ i - 1, where l_ i, r_ i are parameters of the i - th query and \u2295 means the bitwise exclusive or operation. It is guaranteed that 1 \u2264 l \u2264 r \u2264 n .",
    "output": "For each query, print the smallest number that occurs an odd number of times on the given segment of the sequence. If there is no such number, print 0 .",
    "note": "In the example, l_ 1 = 1, r_ 1 = 2, l_ 2 = 1, r_ 2 = 3, l_ 3 = 2, r_ 3 = 4, l_ 4 = 1, r_ 4 = 4, l_ 5 = 2, r_ 5 = 2, l_ 6 = 1, r_ 6 = 5.",
    "topics": [
      "binary search",
      "bitmasks",
      "data structures",
      "hashing",
      "probabilities",
      "strings",
      "trees"
    ]
  },
  {
    "title": "Hossam and (sub-)palindromic tree",
    "url": "https://codeforces.com/problemset/problem/1771/D",
    "history": "Hossam has an unweighted tree G with letters in vertices. Hossam defines s( v, u) as a string that is obtained by writing down all the letters on the unique simple path from the vertex v to the vertex u in the tree G . A string a is a subsequence of a string s if a can be obtained from s by deletion of several ( possibly, zero) letters. For example, \" dores\" , \" cf\" , and \" for\" are subsequences of \" codeforces\" , while \" decor\" and \" fork\" are not. A palindrome is a string that reads the same from left to right and from right to left. For example, \" abacaba\" is a palindrome, but \" abac\" is not. Hossam defines a sub- palindrome of a string s as a subsequence of s , that is a palindrome. For example, \" k\" , \" abba\" and \" abhba\" are sub- palindromes of the string \" abhbka\" , but \" abka\" and \" cat\" are not. Hossam defines a maximal sub- palindrome of a string s as a sub- palindrome of s , which has the maximal length among all sub- palindromes of s . For example, \" abhbka\" has only one maximal sub- palindrome \u2014 \" abhba\" . But it may also be that the string has several maximum sub- palindromes: the string \" abcd\" has 4 maximum sub- palindromes. Help Hossam find the length of the longest maximal sub- palindrome among all s( v, u) in the tree G . Note that the sub- palindrome is a subsequence, not a substring.",
    "input": "The first line contains one integer t ( 1 \u2264 t \u2264 200 ) \u2014 the number of test cases. The first line of each test case has one integer number n ( 1 \u2264 n \u2264 2 \u00b7 10^ 3 ) \u2014 the number of vertices in the graph. The second line contains a string s of length n , the i - th symbol of which denotes the letter on the vertex i . It is guaranteed that all characters in this string are lowercase English letters. The next n - 1 lines describe the edges of the tree. Each edge is given by two integers v and u ( 1 \u2264 v, u \u2264 n , v = \u0338 u ) . These two numbers mean that there is an edge ( v, u) in the tree. It is guaranteed that the given edges form a tree. It is guaranteed that sum of all n doesn' t exceed 2 \u00b7 10^ 3 .",
    "output": "For each test case output one integer \u2014 the length of the longest maximal sub- palindrome among all s( v, u) .",
    "note": "In the first example the maximal subpalindromes are \" aaa\" with letters in vertices 1, 3, 5 , or \" aca\" with letters in vertices 1, 4, 5 . The tree from the first example. In the second example there is only one maximal palindrome \" bacab\" with letters in vertices 4, 2, 1, 5, 9 . The tree from the second example.",
    "topics": [
      "brute force",
      "data structures",
      "dfs and similar",
      "dp",
      "strings",
      "trees"
    ]
  },
  {
    "title": "Atilla's Favorite Problem",
    "url": "https://codeforces.com/problemset/problem/1760/B",
    "history": "In order to write a string, Atilla needs to first learn all letters that are contained in the string. Atilla needs to write a message which can be represented as a string s . He asks you what is the minimum alphabet size required so that one can write this message. The alphabet of size x ( 1 \u2264 x \u2264 26 ) contains only the first x Latin letters. For example an alphabet of size 4 contains only the characters , , and .",
    "input": "The first line contains a single integer t ( 1 \u2264 t \u2264 1000 ) \u2014 the number of test cases. The first line of each test case contains a single integer n ( 1 \u2264 n \u2264 100 ) \u2014 the length of the string. The second line of each test case contains a string s of length n , consisting of lowercase Latin letters.",
    "output": "For each test case, output a single integer \u2014 the minimum alphabet size required to so that Atilla can write his message s .",
    "note": "For the first test case, Atilla needs to know only the character , so the alphabet of size 1 which only contains is enough. For the second test case, Atilla needs to know the characters , , , . The smallest alphabet size that contains all of them is 23 ( such alphabet can be represented as the string ) .",
    "topics": [
      "greedy",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Yes-Yes?",
    "url": "https://codeforces.com/problemset/problem/1759/A",
    "history": "You talked to Polycarp and asked him a question. You know that when he wants to answer \" yes\" , he repeats Yes many times in a row. Because of the noise, you only heard part of the answer \u2014 some substring of it. That is, if he answered YesYes, then you could hear esY, YesYes, sYes, e, but you couldn' t Yess, YES or se. Determine if it is true that the given string s is a substring of YesYesYes. . . ( Yes repeated many times in a row) .",
    "input": "The first line of input data contains the singular t ( 1 \u2264 t \u2264 1000 ) \u2014 the number of test cases in the test. Each test case is described by a single string of Latin letters s ( 1 \u2264 | s| \u2264 50 ) \u2014 the part of Polycarp' s answer that you heard, where | s| \u2014 is the length of the string s .",
    "output": "Output t lines, each of which is the answer to the corresponding test case. As an answer, output \" YES\" if the specified string s is a substring of the string YesYesYes. . . Yes ( the number of words Yes is arbitrary) , and \" NO\" otherwise. You can output the answer in any case ( for example, the strings \" yEs\" , \" yes\" , \" Yes\" and \" YES\" will be recognized as a positive answer) .",
    "note": "",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "SSeeeeiinngg DDoouubbllee",
    "url": "https://codeforces.com/problemset/problem/1758/A",
    "history": "A palindrome is a string that reads the same backward as forward. For example, the strings , , , and are palindromes, but and are not. The double of a string s is obtained by writing each character twice. For example, the double of is . Given a string s , rearrange its double to form a palindrome. Output the rearranged string. It can be proven that such a rearrangement always exists.",
    "input": "The first line of input contains t ( 1 \u2264 t \u2264 1000 ) \u2014 the number of test cases. The only line of each test case contains a single string s ( 1 \u2264 | s| \u2264 100 ) consisting only of lowercase English letters. Note that the sum of | s| over all test cases is not bounded.",
    "output": "For each test case, output a palindromic string of length 2 \u00b7 | s| that is a rearrangement of the double of s .",
    "note": "In the first test case, the double of is , which is already a palindrome. In the second test case, the double of is . If we move the first to the end, we get , which is a palindrome. In the third test case, the double of is . We can rearrange the characters to form , which is a palindrome.",
    "topics": [
      "constructive algorithms",
      "strings"
    ]
  },
  {
    "title": "Majority",
    "url": "https://codeforces.com/problemset/problem/1750/F",
    "history": "Everyone was happy coding, until suddenly a power shortage happened and the best competitive programming site went down. Fortunately, a system administrator bought some new equipment recently, including some UPSs. Thus there are some servers that are still online, but we need all of them to be working in order to keep the round rated. Imagine the servers being a binary string s of length n . If the i - th server is online, then s_ i = 1 , and s_ i = 0 otherwise. A system administrator can do the following operation called electricity spread, that consists of the following phases: Select two servers at positions 1 \u2264 i < j \u2264 n such that both are online ( i. e. s_ i= s_ j= 1 ) . The spread starts only from online servers. Check if we have enough power to make the spread. We consider having enough power if the number of turned on servers in range [ i, j] is at least the number of turned off servers in range [ i, j] . More formally, check whether 2 \u00b7 ( s_ i + s_ i+ 1 + . . . + s_ j) \u2265 j - i + 1 . If the check is positive, turn on all the offline servers in range [ i, j] . More formally, make s_ k : = 1 for all k from i to j . We call a binary string s of length n rated if we can turn on all servers ( i. e. make s_ i = 1 for 1 \u2264 i \u2264 n ) using the electricity spread operation any number of times ( possibly, 0 ) . Your task is to find the number of rated strings of length n modulo m .",
    "input": "The first and only line contains two integers n and m ( 1 \u2264 n \u2264 5000 , 10 \u2264 m \u2264 10^ 9 ) \u2014 the length of the string and the required module.",
    "output": "Print a single integer \u2014 the number of rated binary strings of length n . Since this number can be large, print it modulo m .",
    "note": "In the first example, the only rated string is 11. So the answer is 1 . In the second example, the rated strings are: 111; 101, because we can perform an operation with i = 1 and j = 3 . So the answer is 2 . In the third sample, the rated strings are: 1001; 1111; 1011; 1101. So the answer is 4 .",
    "topics": [
      "combinatorics",
      "dp",
      "math",
      "strings"
    ]
  },
  {
    "title": "Bracket Cost",
    "url": "https://codeforces.com/problemset/problem/1750/E",
    "history": "Daemon Targaryen decided to stop looking like a Metin2 character. He turned himself into the most beautiful thing, a bracket sequence. For a bracket sequence, we can do two kind of operations: Select one of its substrings ^ \u2020 and cyclic shift it to the right. For example, after a cyclic shift to the right, \" ( ( ) ) \" will become \" ) ( ( ) \" ; Insert any bracket, opening ' ( ' or closing ' ) ' , wherever you want in the sequence. We define the cost of a bracket sequence as the minimum number of such operations to make it balanced ^ . Given a bracket sequence s of length n , find the sum of costs across all its n( n+ 1) / 2 non- empty substrings. Note that for each substring we calculate the cost independently. ^ \u2020 A string a is a substring of a string b if a can be obtained from b by deletion of several ( possibly, zero or all) characters from the beginning and several ( possibly, zero or all) characters from the end. ^ A sequence of brackets is called balanced if one can turn it into a valid math expression by adding characters + and 1 . For example, sequences \" ( ( ) ) ( ) \" , \" ( ) \" , and \" ( ( ) ( ( ) ) ) \" are balanced, while \" ) ( \" , \" ( ( ) \" , and \" ( ( ) ) ) ( \" are not.",
    "input": "Each test consists of multiple test cases. The first line contains a single integer t ( 1 \u2264 t \u2264 10^ 5 ) \u2014 the number of test cases. The description of test cases follows. The first line of each test case contains a single integer n ( 1 \u2264 n \u2264 2 \u00b7 10^ 5 ) \u2014 the length of the bracket sequence. The second line of each test case contains a string s , consisting only of characters ' ( ' and ' ) ' , of length n \u2014 the bracket sequence. It is guaranteed that sum of n across all test cases does not exceed 2 \u00b7 10^ 5 .",
    "output": "For each test case, print a single integer \u2014 the sum of costs of all substrings of s .",
    "note": "In the first test case, there is the only substring \" ) \" . Its cost is 1 because we can insert ' ( ' to the beginning of this substring and get a string \" ( ) \" , that is a balanced string. In the second test case, the cost of each substring of length one is 1 . The cost of a substring \" ) ( \" is 1 because we can cyclically shift it to right and get a string \" ( ) \" . The cost of strings \" ) ( ) \" and \" ( ) ( \" is 1 because its enough to insert one bracket to each of them. The cost of substring \" ) ( ) ( \" is 1 because we can cyclically shift it to right and get a string \" ( ) ( ) \" . So there are 4 + 2 + 2 + 1 = 9 substring of cost 1 and 1 substring of cost 0 . So the sum of the costs is 9 . In the third test case, \" ( \" , the cost is 1 ; \" ( ) \" , the cost is 0 ; \" ( ) ) \" , the cost is 1 ; \" ) \" , the cost is 1 ; \" ) ) \" , the cost is 2 ; \" ) \" , the cost is 1 . So the sum of the costs is 6 .",
    "topics": [
      "binary search",
      "data structures",
      "divide and conquer",
      "dp",
      "greedy",
      "strings"
    ]
  },
  {
    "title": "Diverse Substrings",
    "url": "https://codeforces.com/problemset/problem/1748/B",
    "history": "A non- empty digit string is diverse if the number of occurrences of each character in it doesn' t exceed the number of distinct characters in it. For example: string \" 7\" is diverse because 7 appears in it 1 time and the number of distinct characters in it is 1 ; string \" 77\" is not diverse because 7 appears in it 2 times and the number of distinct characters in it is 1 ; string \" 1010\" is diverse because both 0 and 1 appear in it 2 times and the number of distinct characters in it is 2 ; string \" 6668\" is not diverse because 6 appears in it 3 times and the number of distinct characters in it is 2 . You are given a string s of length n , consisting of only digits 0 to 9 . Find how many of its n( n+ 1) / 2 substrings are diverse. A string a is a substring of a string b if a can be obtained from b by deletion of several ( possibly, zero or all) characters from the beginning and several ( possibly, zero or all) characters from the end. Note that if the same diverse string appears in s multiple times, each occurrence should be counted independently. For example, there are two diverse substrings in \" 77\" both equal to \" 7\" , so the answer for the string \" 77\" is 2 .",
    "input": "Each test contains multiple test cases. The first line contains a single integer t ( 1 \u2264 t \u2264 10^ 4 ) \u2014 the number of test cases. The first line of each test case contains a single integer n ( 1 \u2264 n \u2264 10^ 5 ) \u2014 the length of the string s . The second line of each test case contains a string s of length n . It is guaranteed that all characters of s are digits from 0 to 9 . It is guaranteed that the sum of n over all test cases does not exceed 10^ 5 .",
    "output": "For each test case print one integer \u2014 the number of diverse substrings of the given string s .",
    "note": "In the first test case, the diverse substring is \" 7\" . In the second test case, the only diverse substring is \" 7\" , which appears twice, so the answer is 2 . In the third test case, the diverse substrings are \" 0\" ( 2 times) , \" 01\" , \" 010\" , \" 1\" ( 2 times) , \" 10\" ( 2 times) , \" 101\" and \" 1010\" . In the fourth test case, the diverse substrings are \" 0\" ( 3 times) , \" 01\" , \" 011\" , \" 0110\" , \" 1\" ( 2 times) , \" 10\" , \" 100\" , \" 110\" and \" 1100\" . In the fifth test case, the diverse substrings are \" 3\" , \" 39\" , \" 399\" , \" 6\" , \" 9\" ( 4 times) , \" 96\" and \" 996\" . In the sixth test case, all 15 non- empty substrings of \" 23456\" are diverse.",
    "topics": [
      "brute force",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Smaller",
    "url": "https://codeforces.com/problemset/problem/1742/F",
    "history": "Alperen has two strings, s and t which are both initially equal to \" a\" . He will perform q operations of two types on the given strings: 1 k x \u2014 Append the string x exactly k times at the end of string s . In other words, s : = s + x + . . . + x_ k times . 2 k x \u2014 Append the string x exactly k times at the end of string t . In other words, t : = t + x + . . . + x_ k times . After each operation, determine if it is possible to rearrange the characters of s and t such that s is lexicographically smaller ^ \u2020 than t . Note that the strings change after performing each operation and don' t go back to their initial states. ^ \u2020 Simply speaking, the lexicographical order is the order in which words are listed in a dictionary. A formal definition is as follows: string p is lexicographically smaller than string q if there exists a position i such that p_ i < q_ i , and for all j < i , p_ j = q_ j . If no such i exists, then p is lexicographically smaller than q if the length of p is less than the length of q . For example, < and < , where we write p < q if p is lexicographically smaller than q .",
    "input": "The first line of the input contains an integer t ( 1 \u2264 t \u2264 10^ 4 ) \u2014 the number of test cases. The first line of each test case contains an integer q ( 1 \u2264 q \u2264 10^ 5) \u2014 the number of operations Alperen will perform. Then q lines follow, each containing two positive integers d and k ( 1 \u2264 d \u2264 2 ; 1 \u2264 k \u2264 10^ 5 ) and a non- empty string x consisting of lowercase English letters \u2014 the type of the operation, the number of times we will append string x and the string we need to append respectively. It is guaranteed that the sum of q over all test cases doesn' t exceed 10^ 5 and that the sum of lengths of all strings x in the input doesn' t exceed 5 \u00b7 10^ 5 .",
    "output": "For each operation, output \" YES\" , if it is possible to arrange the elements in both strings in such a way that s is lexicographically smaller than t and \" NO\" otherwise.",
    "note": "In the first test case, the strings are initially s = \" a\" and t = \" a\" . After the first operation the string t becomes \" aaa\" . Since \" a\" is already lexicographically smaller than \" aaa\" , the answer for this operation should be \" YES\" . After the second operation string s becomes \" aaa\" , and since t is also equal to \" aaa\" , we can' t arrange s in any way such that it is lexicographically smaller than t , so the answer is \" NO\" . After the third operation string t becomes \" aaaaaa\" and s is already lexicographically smaller than it so the answer is \" YES\" . After the fourth operation s becomes \" aaabb\" and there is no way to make it lexicographically smaller than \" aaaaaa\" so the answer is \" NO\" . After the fifth operation the string t becomes \" aaaaaaabcaabcaabca\" , and we can rearrange the strings to: \" bbaaa\" and \" caaaaaabcaabcaabaa\" so that s is lexicographically smaller than t , so we should answer \" YES\" .",
    "topics": [
      "constructive algorithms",
      "greedy",
      "strings"
    ]
  },
  {
    "title": "Compare T-Shirt Sizes",
    "url": "https://codeforces.com/problemset/problem/1741/A",
    "history": "Two T- shirt sizes are given: a and b . The T- shirt size is either a string M or a string consisting of several ( possibly zero) characters X and one of the characters S or L. For example, strings M, XXL, S, XXXXXXXS could be the size of some T- shirts. And the strings XM, LL, SX are not sizes. The letter M stands for medium, S for small, L for large. The letter X refers to the degree of size ( from eXtra) . For example, XXL is extra- extra- large ( bigger than XL, and smaller than XXXL) . You need to compare two given sizes of T- shirts a and b . The T- shirts are compared as follows: any small size ( no matter how many letters X) is smaller than the medium size and any large size; any large size ( regardless of the number of letters X) is larger than the medium size and any small size; the more letters X before S, the smaller the size; the more letters X in front of L, the larger the size. For example: XXXS < XS XXXL > XL XL > M XXL = XXL XXXXXS < M XL > XXXS",
    "input": "The first line of the input contains a single integer t ( 1 \u2264 t \u2264 10^ 4 ) \u2014 the number of test cases. Each test case consists of one line, in which a and b T- shirt sizes are written. The lengths of the strings corresponding to the T- shirt sizes do not exceed 50 . It is guaranteed that all sizes are correct.",
    "output": "For each test case, print on a separate line the result of comparing a and b T- shirt sizes ( lines \" < \" , \" > \" or \" = \" without quotes) .",
    "note": "",
    "topics": [
      "implementation",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Keyboard Design",
    "url": "https://codeforces.com/problemset/problem/1739/F",
    "history": "Monocarp has a dictionary of n words, consisting of 12 first letters of the Latin alphabet. The words are numbered from 1 to n . In every pair of adjacent characters in each word, the characters are different. For every word i , Monocarp also has an integer c_ i denoting how often he uses this word. Monocarp wants to design a keyboard that would allow him to type some of the words easily. A keyboard can be denoted as a sequence of 12 first letters of the Latin alphabet, where each letter from a to l appears exactly once. A word can be typed with the keyboard easily if, for every pair of adjacent characters in the word, these characters are adjacent in the keyboard as well. The optimality of the keyboard is the sum of c_ i over all words i that can be typed easily with it. Help Monocarp to design a keyboard with the maximum possible optimality.",
    "input": "The first line contains one integer n ( 1 \u2264 n \u2264 1000 ) \u2014 the number of words. Then, n lines follow. The i - th of them contains an integer c_ i ( 1 \u2264 c_ i \u2264 10^ 5 ) and a string s_ i ( 2 \u2264 | s_ i| \u2264 2000 ) denoting the i - th word. Each character of s_ i is one of 12 first letters of Latin alphabet, in lowercase. For every j \u2208 [ 1, | s_ i| - 1] , the j - th character of s_ i is different from the ( j+ 1) - th one. Additional constraint on the input: \u2211_ i= 1^ n | s_ i| \u2264 2000 .",
    "output": "Print a sequence of 12 first letters of the Latin alphabet, where each letter from a to l appears exactly once, denoting the optimal keyboard. If there are multiple answers, you may print any of them.",
    "note": "",
    "topics": [
      "bitmasks",
      "data structures",
      "dp",
      "string suffix structures",
      "strings"
    ]
  },
  {
    "title": "Palindrome Addicts",
    "url": "https://codeforces.com/problemset/problem/1738/H",
    "history": "Your task is to maintain a queue consisting of lowercase English letters as follows: \" push c \" : insert a letter c at the back of the queue; \" pop\" : delete a letter from the front of the queue. Initially, the queue is empty. After each operation, you are asked to count the number of distinct palindromic substrings in the string that are obtained by concatenating the letters from the front to the back of the queue. Especially, the number of distinct palindromic substrings of the empty string is 0 . A string s[ 1. . n] of length n is palindromic if s[ i] = s[ n- i+ 1] for every 1 \u2264 i \u2264 n . The string s[ l. . r] is a substring of string s[ 1. . n] for every 1 \u2264 l \u2264 r \u2264 n . Two strings s[ 1. . n] and t[ 1. . m] are distinct, if at least one of the following holds. n = \u0338 m ; s[ i] = \u0338 t[ i] for some 1 \u2264 i \u2264min{ n, m} .",
    "input": "The first line is an integer q ( 1 \u2264 q \u2264 10^ 6 ) , indicating the number of operations. Then q lines follow. Each of the following lines contains one of the operations as follows. \" push c \" : insert a letter c at the back of the queue, where c is a lowercase English letter; \" pop\" : delete a letter from the front of the queue. It is guaranteed that no \" pop\" operation will be performed when the queue is empty.",
    "output": "After each operation, print the number of distinct palindromic substrings in the string presented in the queue.",
    "note": "Let s_ k be the string presented in the queue after the k - th operation, and let c_ k be the number of distinct palindromic substrings of s_ k . The following table shows the details of the example. k s_ k c_ k 1 a 1 2 0 3 a 1 4 aa 2 5 aab 3 6 aabb 4 7 aabba 5 8 aabbaa 6 9 abbaa 5 10 bbaa 4 11 baa 3 12 baab 4 It is worth pointing out that After the 2 - nd operation, the string is empty and thus has no substrings. So the answer is 0 ; After the 8 - th operation, the string is \" aabbaa \" . The 6 distinct palindromic substrings are \" a \" , \" aa \" , \" aabbaa \" , \" abba \" , \" b \" , and \" bb \" .",
    "topics": [
      "data structures",
      "strings"
    ]
  },
  {
    "title": "Ela Sorting Books",
    "url": "https://codeforces.com/problemset/problem/1737/A",
    "history": "Ela loves reading a lot, just like her new co- workers in DTL! On her first day after becoming an engineer in DTL, she is challenged by a co- worker to sort a heap of books into different compartments on the shelf. n books must be split into k compartments on the bookshelf ( n is divisible by k ) . Each book is represented by a lowercase Latin letter from ' a' to ' y' inclusively, which is the beginning letter in the title of the book. Ela must stack exactly n/ k books in each compartment. After the books are stacked, for each compartment indexed from 1 to k , she takes the minimum excluded ( MEX) letter of the multiset of letters formed by letters representing all books in that compartment, then combines the resulting letters into a string. The first letter of the resulting string is the MEX letter of the multiset of letters formed by the first compartment, the second letter of the resulting string is the MEX letter of the multiset of letters formed by the second compartment, . . . and so on. Please note, under the constraint of this problem, MEX letter can always be determined for any multiset found in this problem because ' z' is not used. What is the lexicographically greatest resulting string possible that Ela can create? A string a is lexicographically greater than a string b if and only if one of the following holds: b is a prefix of a , but b a ; in the first position where a and b differ, the string a has a letter that appears later in the alphabet than the corresponding letter in b . The minimum excluded ( MEX) letter of a multiset of letters is the letter that appears earliest in the alphabet and is not contained in the multiset. For example, if a multiset of letters contains 7 letters ' b' , ' a' , ' b' , ' c' , ' e' , ' c' , ' f' respectively, then the MEX letter of this compartment is ' d' , because ' d' is not included in the multiset, and all letters comes before ' d' in the alphabet, namely ' a' , ' b' and ' c' , are included in the multiset.",
    "input": "Each test contains multiple test cases. The first line contains the number of test cases t ( 1 \u2264 t \u2264 100 ) . Description of the test cases follows. The first line of each test case contains two integers n and k ( 1 \u2264 n \u2264 200 ; 1 \u2264 k \u2264 n ) . It is guaranteed that n is divisible by k . The second line of each test case contains a string of n lowercase Latin letters from ' a' to ' y' inclusively. Each letter represents the starting letter of the title of a book in the initial heap. It is guaranteed that the sum of n over all test cases does not exceed 1000 .",
    "output": "For each test case, output a string of k letters which is the most optimal string that Ela can find.",
    "note": "In the first test case, the books can be divided into 3 compartments as below: the first compartment contains the books with indices 1, 2, 3, 7 : multiset_ 1 = { ' c' , ' a' , ' b' , ' d' } \u2192 MEX( multiset_ 1) = ' e' the second compartment contains the books with indices 4, 5, 6, 9 : multiset_ 2 = { ' c' , ' c' , ' a' , ' b' } \u2192 MEX( multiset_ 2) = ' d' the third compartment contains the remaining books 8, 10, 11, 12 : multiset_ 3 = { ' a' , ' a' , ' a' , ' c' } \u2192 MEX( multiset_ 3) = ' b' Therefore, the answer is ' edb' . It can be proven that there is no way that Ela can arrange the books so that it results in a lexicographically greater string.",
    "topics": [
      "greedy",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Equal Binary Subsequences",
    "url": "https://codeforces.com/problemset/problem/1736/D",
    "history": "Everool has a binary string s of length 2n . Note that a binary string is a string consisting of only characters 0 and 1 . He wants to partition s into two disjoint equal subsequences. He needs your help to do it. You are allowed to do the following operation exactly once. You can choose any subsequence ( possibly empty) of s and rotate it right by one position. In other words, you can select a sequence of indices b_ 1, b_ 2, . . . , b_ m , where 1 \u2264 b_ 1 < b_ 2 < . . . < b_ m \u2264 2n . After that you simultaneously set s_ b_ 1 : = s_ b_ m, s_ b_ 2 : = s_ b_ 1, . . . , s_ b_ m : = s_ b_ m- 1. Can you partition s into two disjoint equal subsequences after performing the allowed operation exactly once? A partition of s into two disjoint equal subsequences s^ p and s^ q is two increasing arrays of indices p_ 1, p_ 2, . . . , p_ n and q_ 1, q_ 2, . . . , q_ n , such that each integer from 1 to 2n is encountered in either p or q exactly once, s^ p = s_ p_ 1 s_ p_ 2. . . s_ p_ n , s^ q = s_ q_ 1 s_ q_ 2. . . s_ q_ n , and s^ p = s^ q . If it is not possible to partition after performing any kind of operation, report - 1 . If it is possible to do the operation and partition s into two disjoint subsequences s^ p and s^ q , such that s^ p = s^ q , print elements of b and indices of s^ p , i. e. the values p_ 1, p_ 2, . . . , p_ n .",
    "input": "Each test contains multiple test cases. The first line contains the number of test cases t ( 1 \u2264 t \u2264 10^ 5 ) . Description of the test cases follows. The first line of each test case contains a single integer n ( 1 \u2264 n \u2264 10^ 5 ) , where 2n is the length of the binary string. The second line of each test case contains the binary string s of length 2n . It is guaranteed that the sum of n over all test cases does not exceed 10^ 5 .",
    "output": "For each test case, follow the following output format. If there is no solution, print - 1 . Otherwise, In the first line, print an integer m ( 0 \u2264 m \u2264 2n ) , followed by m distinct indices b_ 1 , b_ 2 , . . . , b_ m ( in increasing order) . In the second line, print n distinct indices p_ 1 , p_ 2 , . . . , p_ n ( in increasing order) . If there are multiple solutions, print any.",
    "note": "In the first test case, b is empty. So string s is not changed. Now s^ p = s_ 1 s_ 2 = 10 , and s^ q = s_ 3s_ 4 = 10 . In the second test case, b= [ 3, 5] . Initially s_ 3= 0 , and s_ 5= 1 . On performing the operation, we simultaneously set s_ 3= 1 , and s_ 5= 0 . So s is updated to 101000 on performing the operation. Now if we take characters at indices [ 1, 2, 5] in s^ p , we get s_ 1= 100 . Also characters at indices [ 3, 4, 6] are in s^ q . Thus s^ q= 100 . We are done as s^ p= s^ q . In fourth test case, it can be proved that it is not possible to partition the string after performing any operation.",
    "topics": [
      "constructive algorithms",
      "geometry",
      "greedy",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Phase Shift",
    "url": "https://codeforces.com/problemset/problem/1735/C",
    "history": "There was a string s which was supposed to be encrypted. For this reason, all 26 lowercase English letters were arranged in a circle in some order, afterwards, each letter in s was replaced with the one that follows in clockwise order, in that way the string t was obtained. You are given a string t . Determine the lexicographically smallest string s that could be a prototype of the given string t . A string a is lexicographically smaller than a string b of the same length if and only if: in the first position where a and b differ, the string a has a letter, that appears earlier in the alphabet than the corresponding letter in b .",
    "input": "The first line of the input contains a single integer t ( 1 \u2264 t \u2264 3 \u00b7 10^ 4 ) \u2014 the number of test cases. The description of test cases follows. The first line of each test case contains one integer n ( 1 \u2264 n \u2264 10^ 5 ) \u2014 the length of the string t . The next line contains the string t of the length n , containing lowercase English letters. It is guaranteed that the sum of n over all test cases doesn' t exceed 2 \u00b7 10^ 5 .",
    "output": "For each test case, output a single line containing the lexicographically smallest string s which could be a prototype of t .",
    "note": "In the first test case, we couldn' t have the string \" a\" , since the letter a would transit to itself. Lexicographically the second string \" b\" is suitable as an answer. In the second test case, the string \" aa\" is not suitable, since a would transit to itself. \" ab\" is not suitable, since the circle would be closed with 2 letters, but it must contain all 26 . The next string \" ac\" is suitable. Below you can see the schemes for the first three test cases. The non- involved letters are skipped, they can be arbitrary placed in the gaps.",
    "topics": [
      "dfs and similar",
      "dsu",
      "graphs",
      "greedy",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Prefixes and Suffixes",
    "url": "https://codeforces.com/problemset/problem/1730/D",
    "history": "You have two strings s_ 1 and s_ 2 of length n , consisting of lowercase English letters. You can perform the following operation any ( possibly zero) number of times: Choose a positive integer 1 \u2264 k \u2264 n . Swap the prefix of the string s_ 1 and the suffix of the string s_ 2 of length k . Is it possible to make these two strings equal by doing described operations?",
    "input": "The first line contains a single integer t ( 1 \u2264 t \u2264 10^ 4 ) \u2014 the number of test cases. Then the test cases follow. Each test case consists of three lines. The first line contains a single integer n ( 1 \u2264 n \u2264 10^ 5 ) \u2014 the length of the strings s_ 1 and s_ 2 . The second line contains the string s_ 1 of length n , consisting of lowercase English letters. The third line contains the string s_ 2 of length n , consisting of lowercase English letters. It is guaranteed that the sum of n for all test cases does not exceed 2 \u00b7 10^ 5 .",
    "output": "For each test case, print \" YES\" if it is possible to make the strings equal, and \" NO\" otherwise.",
    "note": "In the first test case: Initially s_ 1 = cbc , s_ 2 = aba . Operation with k = 1 , after the operation s_ 1 = abc , s_ 2 = abc . In the second test case: Initially s_ 1 = abcaa , s_ 2 = cbabb . Operation with k = 2 , after the operation s_ 1 = bbcaa , s_ 2 = cbaab . Operation with k = 3 , after the operation s_ 1 = aabaa , s_ 2 = cbbbc . Operation with k = 1 , after the operation s_ 1 = cabaa , s_ 2 = cbbba . Operation with k = 2 , after the operation s_ 1 = babaa , s_ 2 = cbbca . Operation with k = 1 , after the operation s_ 1 = aabaa , s_ 2 = cbbcb . Operation with k = 2 , after the operation s_ 1 = cbbaa , s_ 2 = cbbaa . In the third test case, it' s impossible to make strings equal.",
    "topics": [
      "constructive algorithms",
      "strings",
      "two pointers"
    ]
  },
  {
    "title": "Cut Substrings",
    "url": "https://codeforces.com/problemset/problem/1729/G",
    "history": "You are given two non- empty strings s and t , consisting of Latin letters. In one move, you can choose an occurrence of the string t in the string s and replace it with dots. Your task is to remove all occurrences of the string t in the string s in the minimum number of moves, and also calculate how many different sequences of moves of the minimum length exist. Two sequences of moves are considered different if the sets of indices at which the removed occurrences of the string t in s begin differ. For example, the sets { 1, 2, 3} and { 1, 2, 4} are considered different, the sets { 2, 4, 6} and { 2, 6} \u2014 too, but sets { 3, 5} and { 5, 3} \u2014 not. For example, let the string s = \" abababacababa\" and the string t = \" aba\" . We can remove all occurrences of the string t in 2 moves by cutting out the occurrences of the string t at the 3 th and 9 th positions. In this case, the string s is an example of the form \" ab. . . bac. . . ba\" . It is also possible to cut occurrences of the string t at the 3 th and 11 th positions. There are two different sequences of minimum length moves. Since the answer can be large, output it modulo 10^ 9 + 7 .",
    "input": "The first line of the input contains a single integer q ( 1 \u2264 q \u2264 50 ) \u2014 the number of test cases. The descriptions of the sets follow. The first line of each set contains a non- empty string s ( 1 \u2264 | s| \u2264 500 ) consisting of lowercase Latin letters. The second line of each set contains a non- empty string t ( 1 \u2264 | t| \u2264 500 ) consisting of lowercase Latin letters. It is guaranteed that the sum of string lengths s over all test cases does not exceed 500 . Similarly, it is guaranteed that the sum of string lengths t over all test cases does not exceed 500 .",
    "output": "For each test case print two integers \u2014 the minimum number of moves and the number of different optimal sequences, modulo 10^ 9 + 7 .",
    "note": "The first test case is explained in the statement. In the second case, it is enough to cut any of the four occurrences. In the third case, string s is the concatenation of two strings t = \" xyz\" , so there is a unique optimal sequence of 2 moves. In the fourth and sixth cases, the string s initially contains no occurrences of the string t . In the fifth case, the string s contains exactly one occurrence of the string t .",
    "topics": [
      "combinatorics",
      "dp",
      "hashing",
      "strings",
      "two pointers"
    ]
  },
  {
    "title": "Jumping on Tiles",
    "url": "https://codeforces.com/problemset/problem/1729/C",
    "history": "Polycarp was given a row of tiles. Each tile contains one lowercase letter of the Latin alphabet. The entire sequence of tiles forms the string s . In other words, you are given a string s consisting of lowercase Latin letters. Initially, Polycarp is on the first tile of the row and wants to get to the last tile by jumping on the tiles. Jumping from i - th tile to j - th tile has a cost equal to | index( s_ i) - index( s_ j) | , where index( c) is the index of the letter c in the alphabet ( for example, index( ' a' ) = 1 , index( ' b' ) = 2 , . . . , index( ' z' ) = 26 ) . Polycarp wants to get to the n - th tile for the minimum total cost, but at the same time make maximum number of jumps. In other words, among all possible ways to get to the last tile for the minimum total cost, he will choose the one with the maximum number of jumps. Polycarp can visit each tile at most once. Polycarp asks you to help \u2014 print the sequence of indices of string s on which he should jump.",
    "input": "The first line of the input contains an integer t ( 1 \u2264 t \u2264 10^ 4 ) \u2014 the number of test cases in the test. Each test case is given by the string s ( 2 \u2264 | s| \u2264 2 \u00b7 10^ 5 ) , where | s| \u2014 is the length of string s . The string s consists of lowercase Latin letters. It is guaranteed that the sum of string lengths s over all test cases does not exceed 2 \u00b7 10^ 5 .",
    "output": "The answer to each test case consists of two lines. In the first line print two integers cost , m , where cost is the minimum total cost of the path, and m is the maximum number of visited tiles Polycarp can make to get to n - th tiles for the minimum total cost cost ( i. e. the number of jumps is m- 1 ) . In the next line print m different numbers j_ 1, j_ 2, . . . , j_ m ( 1 \u2264 j_ i \u2264 | s| ) \u2014 the sequence of indices of the tiles Polycarp will jump on. The first number in the sequence must be 1 ( that is, j_ 1= 1 ) and the last number must be the value of | s| ( that is, j_ m= | s| ) . If there are multiple answers, print any of them.",
    "note": "In the first test case, the required path corresponds to the picture: In this case, the minimum possible total cost of the path is achieved. Since index( ' l' ) = 12 , index( ' o' ) = 15 , index( ' g' ) = 7 , index( ' i' ) = 9 , index( ' c' ) = 3 , then the total cost of the path is | 12- 9| + | 9- 7| + | 7- 3| = 3+ 2+ 4= 9 .",
    "topics": [
      "constructive algorithms",
      "strings"
    ]
  },
  {
    "title": "Decode String",
    "url": "https://codeforces.com/problemset/problem/1729/B",
    "history": "Polycarp has a string s consisting of lowercase Latin letters. He encodes it using the following algorithm. He goes through the letters of the string s from left to right and for each letter Polycarp considers its number in the alphabet: if the letter number is single- digit number ( less than 10 ) , then just writes it out; if the letter number is a two- digit number ( greater than or equal to 10 ) , then it writes it out and adds the number 0 after. For example, if the string s is code, then Polycarp will encode this string as follows: ' c' \u2014 is the 3 - rd letter of the alphabet. Consequently, Polycarp adds 3 to the code ( the code becomes equal to 3) ; ' o' \u2014 is the 15 - th letter of the alphabet. Consequently, Polycarp adds 15 to the code and also 0 ( the code becomes 3150) ; ' d' \u2014 is the 4 - th letter of the alphabet. Consequently, Polycarp adds 4 to the code ( the code becomes 31504) ; ' e' \u2014 is the 5 - th letter of the alphabet. Therefore, Polycarp adds 5 to the code ( the code becomes 315045) . Thus, code of string code is 315045. You are given a string t resulting from encoding the string s . Your task is to decode it ( get the original string s by t ) .",
    "input": "The first line of the input contains an integer q ( 1 \u2264 q \u2264 10^ 4 ) \u2014 the number of test cases in the input. The descriptions of the test cases follow. The first line of description of each test case contains one integer n ( 1 \u2264 n \u2264 50 ) \u2014 the length of the given code. The second line of the description of each test case contains a string t of length n \u2014 the given code. It is guaranteed that there exists such a string of lowercase Latin letters, as a result of encoding which the string t is obtained.",
    "output": "For each test case output the required string s \u2014 the string that gives string t as the result of encoding. It is guaranteed that such a string always exists. It can be shown that such a string is always unique.",
    "note": "The first test case is explained above. In the second test case, the answer is aj. Indeed, the number of the letter a is equal to 1 , so 1 will be appended to the code. The number of the letter j is 10 , so 100 will be appended to the code. The resulting code is 1100. There are no zeros in the third test case, which means that the numbers of all letters are less than 10 and are encoded as one digit. The original string is abacaba. In the fourth test case, the string s is equal to ll. The letter l has the number 12 and is encoded as 120. So ll is indeed 120120.",
    "topics": [
      "greedy",
      "strings"
    ]
  },
  {
    "title": "Prefix Function Queries",
    "url": "https://codeforces.com/problemset/problem/1721/E",
    "history": "You are given a string s , consisting of lowercase Latin letters. You are asked q queries about it: given another string t , consisting of lowercase Latin letters, perform the following steps: concatenate s and t ; calculate the prefix function of the resulting string s+ t ; print the values of the prefix function on positions | s| + 1, | s| + 2, . . . , | s| + | t| ( | s| and | t| denote the lengths of strings s and t , respectively) ; revert the string back to s . The prefix function of a string a is a sequence p_ 1, p_ 2, . . . , p_ | a| , where p_ i is the maximum value of k such that k < i and a[ 1. . k] = a[ i- k+ 1. . i] ( a[ l. . r] denotes a contiguous substring of a string a from a position l to a position r , inclusive) . In other words, it' s the longest proper prefix of the string a[ 1. . i] that is equal to its suffix of the same length.",
    "input": "The first line contains a non- empty string s ( 1 \u2264 | s| \u2264 10^ 6 ) , consisting of lowercase Latin letters. The second line contains a single integer q ( 1 \u2264 q \u2264 10^ 5 ) \u2014 the number of queries. Each of the next q lines contains a query: a non- empty string t ( 1 \u2264 | t| \u2264 10 ) , consisting of lowercase Latin letters.",
    "output": "For each query, print the values of the prefix function of a string s+ t on positions | s| + 1, | s| + 2, . . . , | s| + | t| .",
    "note": "",
    "topics": [
      "dfs and similar",
      "dp",
      "hashing",
      "string suffix structures",
      "strings",
      "trees"
    ]
  },
  {
    "title": "Xor-Subsequence (hard version)",
    "url": "https://codeforces.com/problemset/problem/1720/D2",
    "history": "It is the hard version of the problem. The only difference is that in this version a_ i \u2264 10^ 9 . You are given an array of n integers a_ 0, a_ 1, a_ 2, . . . a_ n - 1 . Bryap wants to find the longest beautiful subsequence in the array. An array b = [ b_ 0, b_ 1, . . . , b_ m- 1] , where 0 \u2264 b_ 0 < b_ 1 < . . . < b_ m - 1 < n , is a subsequence of length m of the array a . Subsequence b = [ b_ 0, b_ 1, . . . , b_ m- 1] of length m is called beautiful, if the following condition holds: For any p ( 0 \u2264 p < m - 1 ) holds: a_ b_ p\u2295 b_ p+ 1 < a_ b_ p+ 1\u2295 b_ p . Here a \u2295 b denotes the bitwise XOR of a and b . For example, 2 \u2295 4 = 6 and 3 \u2295 1= 2 . Bryap is a simple person so he only wants to know the length of the longest such subsequence. Help Bryap and find the answer to his question.",
    "input": "The first line contains a single integer t ( 1 \u2264 t \u2264 10^ 5 ) \u2014 the number of test cases. The description of the test cases follows. The first line of each test case contains a single integer n ( 2 \u2264 n \u2264 3 \u00b7 10^ 5 ) \u2014 the length of the array. The second line of each test case contains n integers a_ 0, a_ 1, . . . , a_ n- 1 ( 0 \u2264 a_ i \u2264 10^ 9 ) \u2014 the elements of the array. It is guaranteed that the sum of n over all test cases does not exceed 3 \u00b7 10^ 5 .",
    "output": "For each test case print a single integer \u2014 the length of the longest beautiful subsequence.",
    "note": "In the first test case, we can pick the whole array as a beautiful subsequence because 1 \u2295 1 < 2 \u2295 0 . In the second test case, we can pick elements with indexes 1 , 2 and 4 ( in 0 indexation) . For this elements holds: 2 \u2295 2 < 4 \u2295 1 and 4 \u2295 4 < 1 \u2295 2 .",
    "topics": [
      "bitmasks",
      "data structures",
      "dp",
      "strings",
      "trees"
    ]
  },
  {
    "title": "Xor-Subsequence (easy version)",
    "url": "https://codeforces.com/problemset/problem/1720/D1",
    "history": "It is the easy version of the problem. The only difference is that in this version a_ i \u2264 200 . You are given an array of n integers a_ 0, a_ 1, a_ 2, . . . a_ n - 1 . Bryap wants to find the longest beautiful subsequence in the array. An array b = [ b_ 0, b_ 1, . . . , b_ m- 1] , where 0 \u2264 b_ 0 < b_ 1 < . . . < b_ m - 1 < n , is a subsequence of length m of the array a . Subsequence b = [ b_ 0, b_ 1, . . . , b_ m- 1] of length m is called beautiful, if the following condition holds: For any p ( 0 \u2264 p < m - 1 ) holds: a_ b_ p\u2295 b_ p+ 1 < a_ b_ p+ 1\u2295 b_ p . Here a \u2295 b denotes the bitwise XOR of a and b . For example, 2 \u2295 4 = 6 and 3 \u2295 1= 2 . Bryap is a simple person so he only wants to know the length of the longest such subsequence. Help Bryap and find the answer to his question.",
    "input": "The first line contains a single integer t ( 1 \u2264 t \u2264 10^ 5 ) \u2014 the number of test cases. The description of the test cases follows. The first line of each test case contains a single integer n ( 2 \u2264 n \u2264 3 \u00b7 10^ 5 ) \u2014 the length of the array. The second line of each test case contains n integers a_ 0, a_ 1, . . . , a_ n- 1 ( 0 \u2264 a_ i \u2264 200 ) \u2014 the elements of the array. It is guaranteed that the sum of n over all test cases does not exceed 3 \u00b7 10^ 5 .",
    "output": "For each test case print a single integer \u2014 the length of the longest beautiful subsequence.",
    "note": "In the first test case, we can pick the whole array as a beautiful subsequence because 1 \u2295 1 < 2 \u2295 0 . In the second test case, we can pick elements with indexes 1 , 2 and 4 ( in 0 - indexation) . For this elements holds: 2 \u2295 2 < 4 \u2295 1 and 4 \u2295 4 < 1 \u2295 2 .",
    "topics": [
      "bitmasks",
      "brute force",
      "dp",
      "strings",
      "trees",
      "two pointers"
    ]
  },
  {
    "title": "Color with Occurrences",
    "url": "https://codeforces.com/problemset/problem/1714/D",
    "history": "You are given some text t and a set of n strings s_ 1, s_ 2, . . . , s_ n . In one step, you can choose any occurrence of any string s_ i in the text t and color the corresponding characters of the text in red. For example, if t= and s_ 1= , s_ 2= , you can get t= , t= or t= in one step. You want to color all the letters of the text t in red. When you color a letter in red again, it stays red. In the example above, three steps are enough: Let' s color t[ 2 . . . 4] = s_ 2= in red, we get t= ; Let' s color t[ 1 . . . 2] = s_ 1= in red, we get t= ; Let' s color t[ 4 . . . 6] = s_ 2= in red, we get t= . Each string s_ i can be applied any number of times ( or not at all) . Occurrences for coloring can intersect arbitrarily. Determine the minimum number of steps needed to color all letters t in red and how to do it. If it is impossible to color all letters of the text t in red, output - 1.",
    "input": "The first line of the input contains an integer q ( 1 \u2264 q \u2264 100 ) \u2014the number of test cases in the test. The descriptions of the test cases follow. The first line of each test case contains the text t ( 1 \u2264 | t| \u2264 100 ) , consisting only of lowercase Latin letters, where | t| is the length of the text t . The second line of each test case contains a single integer n ( 1 \u2264 n \u2264 10 ) \u2014 the number of strings in the set. This is followed by n lines, each containing a string s_ i ( 1 \u2264 | s_ i| \u2264 10 ) consisting only of lowercase Latin letters, where | s_ i| \u2014 the length of string s_ i .",
    "output": "For each test case, print the answer on a separate line. If it is impossible to color all the letters of the text in red, print a single line containing the number - 1. Otherwise, on the first line, print the number m \u2014 the minimum number of steps it will take to turn all the letters t red. Then in the next m lines print pairs of indices: w_ j and p_ j ( 1 \u2264 j \u2264 m ) , which denote that the string with index w_ j was used as a substring to cover the occurrences starting in the text t from position p_ j . The pairs can be output in any order. If there are several answers, output any of them.",
    "note": "The first test case is explained in the problem statement. In the second test case, it is impossible to color all the letters of the text in red.",
    "topics": [
      "brute force",
      "data structures",
      "dp",
      "greedy",
      "strings"
    ]
  },
  {
    "title": "Recover an RBS",
    "url": "https://codeforces.com/problemset/problem/1709/C",
    "history": "A bracket sequence is a string containing only characters \" ( \" and \" ) \" . A regular bracket sequence ( or, shortly, an RBS) is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters \" 1\" and \" + \" between the original characters of the sequence. For example: bracket sequences \" ( ) ( ) \" and \" ( ( ) ) \" are regular ( the resulting expressions are: \" ( 1) + ( 1) \" and \" ( ( 1+ 1) + 1) \" ) ; bracket sequences \" ) ( \" , \" ( \" and \" ) \" are not. There was an RBS. Some brackets have been replaced with question marks. Is it true that there is a unique way to replace question marks with brackets, so that the resulting sequence is an RBS?",
    "input": "The first line contains a single integer t ( 1 \u2264 t \u2264 5 \u00b7 10^ 4 ) \u2014 the number of testcases. The only line of each testcase contains an RBS with some brackets replaced with question marks. Each character is either ' ( ' , ' ) ' or ' ? ' . At least one RBS can be recovered from the given sequence. The total length of the sequences over all testcases doesn' t exceed 2 \u00b7 10^ 5 .",
    "output": "For each testcase, print \" YES\" if the way to replace question marks with brackets, so that the resulting sequence is an RBS, is unique. If there is more than one way, then print \" NO\" .",
    "note": "In the first testcase, the only possible original RBS is \" ( ( ) ) \" . In the second testcase, there are multiple ways to recover an RBS. In the third and the fourth testcases, the only possible original RBS is \" ( ) \" . In the fifth testcase, the original RBS can be either \" ( ( ( ) ( ) ) ) \" or \" ( ( ) ) ( ) ( ) \" .",
    "topics": [
      "constructive algorithms",
      "greedy",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Another String Minimization Problem",
    "url": "https://codeforces.com/problemset/problem/1706/A",
    "history": "You have a sequence a_ 1, a_ 2, . . . , a_ n of length n , consisting of integers between 1 and m . You also have a string s , consisting of m characters B. You are going to perform the following n operations. At the i - th ( 1 \u2264 i \u2264 n ) operation, you replace either the a_ i - th or the ( m + 1 - a_ i) - th character of s with A. You can replace the character at any position multiple times through the operations. Find the lexicographically smallest string you can get after these operations. A string x is lexicographically smaller than a string y of the same length if and only if in the first position where x and y differ, the string x has a letter that appears earlier in the alphabet than the corresponding letter in y .",
    "input": "The first line contains the number of test cases t ( 1 \u2264 t \u2264 2000 ) . The first line of each test case contains two integers n and m ( 1 \u2264 n, m \u2264 50 ) \u2014 the length of the sequence a and the length of the string s respectively. The second line contains n integers a_ 1, a_ 2, . . . , a_ n ( 1 \u2264 a_ i \u2264 m ) \u2014 the sequence a .",
    "output": "For each test case, print a string of length m \u2014 the lexicographically smallest string you can get. Each character of the string should be either capital English letter A or capital English letter B.",
    "note": "In the first test case, the sequence a = [ 1, 1, 3, 1] . One of the possible solutions is the following. At the 1 - st operation, you can replace the 1 - st character of s with A. After it, s becomes ABBBB. At the 2 - nd operation, you can replace the 5 - th character of s with A ( since m+ 1- a_ 2= 5 ) . After it, s becomes ABBBA. At the 3 - rd operation, you can replace the 3 - rd character of s with A. After it, s becomes ABABA. At the 4 - th operation, you can replace the 1 - st character of s with A. After it, s remains equal to ABABA. The resulting string is ABABA. It is impossible to produce a lexicographically smaller string. In the second test case, you are going to perform only one operation. You can replace either the 2 - nd character or 4 - th character of s with A. You can get strings BABBB and BBBAB after the operation. The string BABBB is the lexicographically smallest among these strings. In the third test case, the only string you can get is A. In the fourth test case, you can replace the 1 - st and 2 - nd characters of s with A to get AABB. In the fifth test case, you can replace the 1 - st and 3 - rd characters of s with A to get ABABBBB.",
    "topics": [
      "2-sat",
      "constructive algorithms",
      "greedy",
      "string suffix structures",
      "strings"
    ]
  },
  {
    "title": "Mio and Lucky Array",
    "url": "https://codeforces.com/problemset/problem/1704/G",
    "history": "Mio has an array a consisting of n integers, and an array b consisting of m integers. Mio can do the following operation to a : Choose an integer i ( 1 \u2264 i \u2264 n ) that has not been chosen before, then add 1 to a_ i , subtract 2 from a_ i+ 1 , add 3 to a_ i+ 2 an so on. Formally, the operation is to add ( - 1) ^ j- i\u00b7 ( j- i+ 1) to a_ j for i \u2264 j \u2264 n . Mio wants to transform a so that it will contain b as a subarray. Could you answer her question, and provide a sequence of operations to do so, if it is possible? An array b is a subarray of an array a if b can be obtained from a by deletion of several ( possibly, zero or all) elements from the beginning and several ( possibly, zero or all) elements from the end.",
    "input": "The input consists of multiple test cases. The first line contains a single integer t ( 1 \u2264 t \u2264 10^ 4 ) \u2014 the number of test cases. The description of test cases follows. The first line of each test case contains one integer n ( 2 \u2264 n \u2264 2 \u00b7 10^ 5 ) \u2014 the number of elements in a . The second line of the test case contains n integers a_ 1, a_ 2, \u22ef, a_ n ( - 10^ 5 \u2264 a_ i \u2264 10^ 5 ) , where a_ i is the i - th element of a . The third line of the test case contains one integer m ( 2 \u2264 m \u2264 n ) \u2014 the number of elements in b . The fourth line of the test case contains m integers b_ 1, b_ 2, \u22ef, b_ m ( - 10^ 12\u2264 b_ i \u2264 10^ 12 ) , where b_ i is the i - th element of b . It is guaranteed that the sum of n over all test cases does not exceed 2 \u00b7 10^ 5 .",
    "output": "If it is impossible to transform a so that it contains b as a subarray, output - 1 . Otherwise, the first line of output should contain an integer k ( 0 \u2264 k \u2264 n ) , the number of operations to be done. The second line should contain k distinct integers, representing the operations done in order. If there are multiple solutions, you can output any. Notice that you do not need to minimize the number of operations.",
    "note": "In the first test case, the sequence a = [ 1, 2, 3, 4, 5] . One of the possible solutions is doing one operation at i = 1 ( add 1 to a_ 1 , subtract 2 from a_ 2 , add 3 to a_ 3 , subtract 4 from a_ 4 , add 5 to a_ 5 ) . Then array a is transformed to a = [ 2, 0, 6, 0, 10] , which contains b = [ 2, 0, 6, 0, 10] as a subarray. In the second test case, the sequence a = [ 1, 2, 3, 4, 5] . One of the possible solutions is doing one operation at i = 4 ( add 1 to a_ 4 , subtract 2 from a_ 5 ) . Then array a is transformed to a = [ 1, 2, 3, 5, 3] , which contains b = [ 3, 5, 3] as a subarray. In the third test case, the sequence a = [ - 3, 2, - 3, - 4, 4, 0, 1, - 2] . One of the possible solutions is the following. Choose an integer i= 8 to do the operation. Then array a is transformed to a = [ - 3, 2, - 3, - 4, 4, 0, 1, - 1] . Choose an integer i= 6 to do the operation. Then array a is transformed to a = [ - 3, 2, - 3, - 4, 4, 1, - 1, 2] . Choose an integer i= 4 to do the operation. Then array a is transformed to a = [ - 3, 2, - 3, - 3, 2, 4, - 5, 7] . Choose an integer i= 3 to do the operation. Then array a is transformed to a = [ - 3, 2, - 2, - 5, 5, 0, 0, 1] . Choose an integer i= 1 to do the operation. Then array a is transformed to a = [ - 2, 0, 1, - 9, 10, - 6, 7, - 7] . The resulting a is [ - 2, 0, 1, - 9, 10, - 6, 7, - 7] , which contains b = [ 10, - 6, 7, - 7] as a subarray. In the fourth test case, it is impossible to transform a so that it contains b as a subarray. In the fifth test case, it is impossible to transform a so that it contains b as a subarray.",
    "topics": [
      "constructive algorithms",
      "fft",
      "math",
      "strings"
    ]
  },
  {
    "title": "Double Strings",
    "url": "https://codeforces.com/problemset/problem/1703/D",
    "history": "You are given n strings s_ 1, s_ 2, . . . , s_ n of length at most 8 . For each string s_ i , determine if there exist two strings s_ j and s_ k such that s_ i = s_ j + s_ k . That is, s_ i is the concatenation of s_ j and s_ k . Note that j can be equal to k . Recall that the concatenation of strings s and t is s + t = s_ 1 s_ 2 . . . s_ p t_ 1 t_ 2 . . . t_ q , where p and q are the lengths of strings s and t respectively. For example, concatenation of \" code\" and \" forces\" is \" codeforces\" .",
    "input": "The first line contains a single integer t ( 1 \u2264 t \u2264 10^ 4 ) \u2014 the number of test cases. The first line of each test case contains a single integer n ( 1 \u2264 n \u2264 10^ 5 ) \u2014 the number of strings. Then n lines follow, the i - th of which contains non- empty string s_ i of length at most 8 , consisting of lowercase English letters. Among the given n strings, there may be equal ( duplicates) . The sum of n over all test cases doesn' t exceed 10^ 5 .",
    "output": "For each test case, output a binary string of length n . The i - th bit should be if there exist two strings s_ j and s_ k where s_ i = s_ j + s_ k , and otherwise. Note that j can be equal to k .",
    "note": "In the first test case, we have the following: s_ 1 = s_ 2 + s_ 2 , since = + . Remember that j can be equal to k . s_ 2 is not the concatenation of any two strings in the list. s_ 3 = s_ 2 + s_ 5 , since = + . s_ 4 is not the concatenation of any two strings in the list. s_ 5 is not the concatenation of any two strings in the list. Since only s_ 1 and s_ 3 satisfy the conditions, only the first and third bits in the answer should be , so the answer is .",
    "topics": [
      "brute force",
      "data structures",
      "strings"
    ]
  },
  {
    "title": "Cypher",
    "url": "https://codeforces.com/problemset/problem/1703/C",
    "history": "Luca has a cypher made up of a sequence of n wheels, each with a digit a_ i written on it. On the i - th wheel, he made b_ i moves. Each move is one of two types: up move ( denoted by ) : it increases the i - th digit by 1 . After applying the up move on 9 , it becomes 0 . down move ( denoted by ) : it decreases the i - th digit by 1 . After applying the down move on 0 , it becomes 9 . Example for n= 4 . The current sequence is 0 0 0 0. Luca knows the final sequence of wheels and the moves for each wheel. Help him find the original sequence and crack the cypher.",
    "input": "The first line contains a single integer t ( 1 \u2264 t \u2264 100 ) \u2014 the number of test cases. The first line of each test case contains a single integer n ( 1 \u2264 n \u2264 100 ) \u2014 the number of wheels. The second line contains n integers a_ i ( 0 \u2264 a_ i \u2264 9 ) \u2014 the digit shown on the i - th wheel after all moves have been performed. Then n lines follow, the i - th of which contains the integer b_ i ( 1 \u2264 b_ i \u2264 10 ) and b_ i characters that are either or \u2014 the number of moves performed on the i - th wheel, and the moves performed. and represent an up move and a down move respectively.",
    "output": "For each test case, output n space- separated digits \u2014 the initial sequence of the cypher.",
    "note": "In the first test case, we can prove that initial sequence was [ 2, 1, 1] . In that case, the following moves were performed: On the first wheel: 2 1 0 9 . On the second wheel: 1 2 1 2 3 . On the third wheel: 1 0 1 . The final sequence was [ 9, 3, 1] , which matches the input.",
    "topics": [
      "brute force",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "YES or YES?",
    "url": "https://codeforces.com/problemset/problem/1703/A",
    "history": "There is a string s of length 3 , consisting of uppercase and lowercase English letters. Check if it is equal to \" YES\" ( without quotes) , where each letter can be in any case. For example, \" yES\" , \" Yes\" , \" yes\" are all allowable.",
    "input": "The first line of the input contains an integer t ( 1 \u2264 t \u2264 10^ 3 ) \u2014 the number of testcases. The description of each test consists of one line containing one string s consisting of three characters. Each character of s is either an uppercase or lowercase English letter.",
    "output": "For each test case, output \" YES\" ( without quotes) if s satisfies the condition, and \" NO\" ( without quotes) otherwise. You can output \" YES\" and \" NO\" in any case ( for example, strings \" yES\" , \" yes\" and \" Yes\" will be recognized as a positive response) .",
    "note": "The first five test cases contain the strings \" YES\" , \" yES\" , \" yes\" , \" Yes\" , \" YeS\" . All of these are equal to \" YES\" , where each character is either uppercase or lowercase.",
    "topics": [
      "brute force",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Text Editor",
    "url": "https://codeforces.com/problemset/problem/1701/E",
    "history": "You wanted to write a text t consisting of m lowercase Latin letters. But instead, you have written a text s consisting of n lowercase Latin letters, and now you want to fix it by obtaining the text t from the text s . Initially, the cursor of your text editor is at the end of the text s ( after its last character) . In one move, you can do one of the following actions: press the \" left\" button, so the cursor is moved to the left by one position ( or does nothing if it is pointing at the beginning of the text, i. e. before its first character) ; press the \" right\" button, so the cursor is moved to the right by one position ( or does nothing if it is pointing at the end of the text, i. e. after its last character) ; press the \" home\" button, so the cursor is moved to the beginning of the text ( before the first character of the text) ; press the \" end\" button, so the cursor is moved to the end of the text ( after the last character of the text) ; press the \" backspace\" button, so the character before the cursor is removed from the text ( if there is no such character, nothing happens) . Your task is to calculate the minimum number of moves required to obtain the text t from the text s using the given set of actions, or determine it is impossible to obtain the text t from the text s . You have to answer T independent test cases.",
    "input": "The first line of the input contains one integer T ( 1 \u2264 T \u2264 5000 ) \u2014 the number of test cases. Then T test cases follow. The first line of the test case contains two integers n and m ( 1 \u2264 m \u2264 n \u2264 5000 ) \u2014 the length of s and the length of t , respectively. The second line of the test case contains the string s consisting of n lowercase Latin letters. The third line of the test case contains the string t consisting of m lowercase Latin letters. It is guaranteed that the sum of n over all test cases does not exceed 5000 ( \u2211 n \u2264 5000 ) .",
    "output": "For each test case, print one integer \u2014 the minimum number of moves required to obtain the text t from the text s using the given set of actions, or - 1 if it is impossible to obtain the text t from the text s in the given test case.",
    "note": "",
    "topics": [
      "brute force",
      "dp",
      "greedy",
      "strings"
    ]
  },
  {
    "title": "awoo's Favorite Problem",
    "url": "https://codeforces.com/problemset/problem/1697/C",
    "history": "You are given two strings s and t , both of length n . Each character in both string is ' a' , ' b' or ' c' . In one move, you can perform one of the following actions: choose an occurrence of \" ab\" in s and replace it with \" ba\" ; choose an occurrence of \" bc\" in s and replace it with \" cb\" . You are allowed to perform an arbitrary amount of moves ( possibly, zero) . Can you change string s to make it equal to string t ?",
    "input": "The first line contains a single integer q ( 1 \u2264 q \u2264 10^ 4 ) \u2014 the number of testcases. The first line of each testcase contains a single integer n ( 1 \u2264 n \u2264 10^ 5 ) \u2014 the length of strings s and t . The second line contains string s of length n . Each character is ' a' , ' b' or ' c' . The third line contains string t of length n . Each character is ' a' , ' b' or ' c' . The sum of n over all testcases doesn' t exceed 10^ 5 .",
    "output": "For each testcase, print \" YES\" if you can change string s to make it equal to string t by performing an arbitrary amount of moves ( possibly, zero) . Otherwise, print \" NO\" .",
    "note": "",
    "topics": [
      "binary search",
      "constructive algorithms",
      "data structures",
      "greedy",
      "implementation",
      "strings",
      "two pointers"
    ]
  },
  {
    "title": "Sum of Substrings",
    "url": "https://codeforces.com/problemset/problem/1691/C",
    "history": "You are given a binary string s of length n . Let' s define d_ i as the number whose decimal representation is s_ i s_ i+ 1 ( possibly, with a leading zero) . We define f( s) to be the sum of all the valid d_ i . In other words, f( s) = \u2211_ i= 1^ n- 1 d_ i . For example, for the string s = 1011 : d_ 1 = 10 ( ten) ; d_ 2 = 01 ( one) d_ 3 = 11 ( eleven) ; f( s) = 10 + 01 + 11 = 22 . In one operation you can swap any two adjacent elements of the string. Find the minimum value of f( s) that can be achieved if at most k operations are allowed.",
    "input": "Each test contains multiple test cases. The first line contains the number of test cases t ( 1 \u2264 t \u2264 10^ 5 ) . Description of the test cases follows. First line of each test case contains two integers n and k ( 2 \u2264 n \u2264 10^ 5 , 0 \u2264 k \u2264 10^ 9 ) \u2014 the length of the string and the maximum number of operations allowed. The second line of each test case contains the binary string s of length n , consisting of only zeros and ones. It is also given that sum of n over all the test cases doesn' t exceed 10^ 5 .",
    "output": "For each test case, print the minimum value of f( s) you can obtain with at most k operations.",
    "note": "For the first example, you can' t do any operation so the optimal string is s itself. f( s) = f( 1010) = 10 + 01 + 10 = 21 . For the second example, one of the optimal strings you can obtain is \" 0011000\" . The string has an f value of 22 . For the third example, one of the optimal strings you can obtain is \" 00011\" . The string has an f value of 12 .",
    "topics": [
      "brute force",
      "constructive algorithms",
      "greedy",
      "math",
      "strings"
    ]
  },
  {
    "title": "Shifting String",
    "url": "https://codeforces.com/problemset/problem/1690/F",
    "history": "Polycarp found the string s and the permutation p . Their lengths turned out to be the same and equal to n . A permutation of n elements \u2014 is an array of length n , in which every integer from 1 to n occurs exactly once. For example, [ 1, 2, 3] and [ 4, 3, 5, 1, 2] are permutations, but [ 1, 2, 4] , [ 4, 3, 2, 1, 2] and [ 0, 1, 2] are not. In one operation he can multiply s by p , so he replaces s with string new , in which for any i from 1 to n it is true that new_ i = s_ p_ i . For example, with s= wmbe and p = [ 3, 1, 4, 2] , after operation the string will turn to s= s_ 3 s_ 1 s_ 4 s_ 2= bwem . Polycarp wondered after how many operations the string would become equal to its initial value for the first time. Since it may take too long, he asks for your help in this matter. It can be proved that the required number of operations always exists. It can be very large, so use a 64- bit integer type.",
    "input": "The first line of input contains one integer t ( 1 \u2264 t \u2264 5000 ) \u2014 the number of test cases in input. The first line of each case contains single integer n ( 1 \u2264 n \u2264 200 ) \u2014 the length of string and permutation. The second line of each case contains a string s of length n , containing lowercase Latin letters. The third line of each case contains n integers \u2014 permutation p ( 1 \u2264 p_ i \u2264 n ) , all p_ i are different.",
    "output": "Output t lines, each of which contains the answer to the corresponding test case of input. As an answer output single integer \u2014 the minimum number of operations, after which the string s will become the same as it was before operations.",
    "note": "In the first sample operation doesn' t change the string, so it will become the same as it was after 1 operations. In the second sample the string will change as follows: s = babaa s = abaab s = baaba s = abbaa s = baaab s = ababa",
    "topics": [
      "graphs",
      "math",
      "number theory",
      "strings"
    ]
  },
  {
    "title": "Manipulating History",
    "url": "https://codeforces.com/problemset/problem/1688/C",
    "history": "As a human, she can erase history of its entirety. As a Bai Ze ( Hakutaku) , she can create history out of nothingness. \u2014Perfect Memento in Strict SenseKeine has the ability to manipulate history. The history of Gensokyo is a string s of length 1 initially. To fix the chaos caused by Yukari, she needs to do the following operations n times, for the i - th time: She chooses a non- empty substring t_ 2i- 1 of s . She replaces t_ 2i- 1 with a non- empty string, t_ 2i . Note that the lengths of strings t_ 2i- 1 and t_ 2i can be different. Note that if t_ 2i- 1 occurs more than once in s , exactly one of them will be replaced. For example, let s= \" marisa\" , t_ 2i- 1= \" a\" , and t_ 2i= \" z\" . After the operation, s becomes \" mzrisa\" or \" marisz\" . After n operations, Keine got the final string and an operation sequence t of length 2n . Just as Keine thinks she has finished, Yukari appears again and shuffles the order of t . Worse still, Keine forgets the initial history. Help Keine find the initial history of Gensokyo! Recall that a substring is a sequence of consecutive characters of the string. For example, for string \" abc\" its substrings are: \" ab\" , \" c\" , \" bc\" and some others. But the following strings are not its substring: \" ac\" , \" cba\" , \" acb\" . HacksYou cannot make hacks in this problem.",
    "input": "Each test contains multiple test cases. The first line contains a single integer T ( 1 \u2264 T \u2264 10^ 3 ) \u2014 the number of test cases. The description of the test cases follows. The first line of each test case contains a single integer n ( 1 \u2264 n < 10 ^ 5 ) \u2014 the number of operations. The next 2n lines contains one non- empty string t_ i \u2014 the i - th string of the shuffled sequence t . The next line contains one non- empty string s \u2014 the final string. It is guaranteed that the total length of given strings ( including t_ i and s ) over all test cases does not exceed 2 \u00b7 10 ^ 5 . All given strings consist of lowercase English letters only. It is guaranteed that the initial string exists. It can be shown that the initial string is unique.",
    "output": "For each test case, print the initial string in one line.",
    "note": "Test case 1: Initially s is \" a\" . In the first operation, Keine chooses \" a\" , and replaces it with \" ab\" . s becomes \" ab\" . In the second operation, Keine chooses \" b\" , and replaces it with \" cd\" . s becomes \" acd\" . So the final string is \" acd\" , and t= [ \" a\" , \" ab\" , \" b\" , \" cd\" ] before being shuffled. Test case 2: Initially s is \" z\" . In the first operation, Keine chooses \" z\" , and replaces it with \" aa\" . s becomes \" aa\" . In the second operation, Keine chooses \" a\" , and replaces it with \" ran\" . s becomes \" aran\" . In the third operation, Keine chooses \" a\" , and replaces it with \" yakumo\" . s becomes \" yakumoran\" . So the final string is \" yakumoran\" , and t= [ \" z\" , \" aa\" , \" a\" , \" ran\" , \" a\" , \" yakumo\" ] before being shuffled.",
    "topics": [
      "constructive algorithms",
      "greedy",
      "strings"
    ]
  },
  {
    "title": "Linguistics",
    "url": "https://codeforces.com/problemset/problem/1685/B",
    "history": "Alina has discovered a weird language, which contains only 4 words: , , , . It also turned out that there are no spaces in this language: a sentence is written by just concatenating its words into a single string. Alina has found one such sentence s and she is curious: is it possible that it consists of precisely a words , b words , c words , and d words ? In other words, determine, if it' s possible to concatenate these a+ b+ c+ d words in some order so that the resulting string is s . Each of the a+ b+ c+ d words must be used exactly once in the concatenation, but you can choose the order in which they are concatenated.",
    "input": "The first line of the input contains a single integer t ( 1 \u2264 t \u2264 10^ 5 ) \u2014 the number of test cases. The description of the test cases follows. The first line of each test case contains four integers a , b , c , d ( 0\u2264 a, b, c, d\u2264 2\u00b7 10^ 5 ) \u2014 the number of times that words , , , respectively must be used in the sentence. The second line contains the string s ( s consists only of the characters and , 1\u2264 | s| \u2264 2\u00b7 10^ 5 , | s| = a+ b+ 2c+ 2d ) \u2014 the sentence. Notice that the condition | s| = a+ b+ 2c+ 2d ( here | s| denotes the length of the string s ) is equivalent to the fact that s is as long as the concatenation of the a+ b+ c+ d words. The sum of the lengths of s over all test cases doesn' t exceed 2\u00b7 10^ 5 .",
    "output": "For each test case output if it is possible that the sentence s consists of precisely a words , b words , c words , and d words , and otherwise. You can output each letter in any case.",
    "note": "In the first test case, the sentence s is . Clearly, it can' t consist of a single word , so the answer is . In the second test case, the sentence s is , and it' s possible that it consists of a single word , so the answer is . In the third test case, the sentence s is , and it' s possible that it consists of one word , one word , and one word , as + + = . In the fourth test case, the sentence s is , and it' s possible that it consists of one word , one word , and one word , as + + = . In the fifth test case, the sentence s is , and it' s possible that it consists of one word , one word , two words , and two words , as + + + + + = .",
    "topics": [
      "greedy",
      "implementation",
      "sortings",
      "strings"
    ]
  },
  {
    "title": "Digit Minimization",
    "url": "https://codeforces.com/problemset/problem/1684/A",
    "history": "There is an integer n without zeros in its decimal representation. Alice and Bob are playing a game with this integer. Alice starts first. They play the game in turns. On her turn, Alice must swap any two digits of the integer that are on different positions. Bob on his turn always removes the last digit of the integer. The game ends when there is only one digit left. You have to find the smallest integer Alice can get in the end, if she plays optimally.",
    "input": "The input consists of multiple test cases. The first line contains a single integer t ( 1 \u2264 t \u2264 10^ 4 ) \u2014 the number of test cases. Description of the test cases follows. The first and the only line of each test case contains the integer n ( 10 \u2264 n \u2264 10^ 9 ) \u2014 the integer for the game. n does not have zeros in its decimal representation.",
    "output": "For each test case output a single integer \u2014 the smallest integer Alice can get in the end of the game.",
    "note": "In the first test case Alice has to swap 1 and 2 . After that Bob removes the last digit, 1 , so the answer is 2 . In the second test case Alice can swap 3 and 1 : 312 . After that Bob deletes the last digit: 31 . Then Alice swaps 3 and 1 : 13 and Bob deletes 3 , so the answer is 1 .",
    "topics": [
      "constructive algorithms",
      "games",
      "math",
      "strings"
    ]
  },
  {
    "title": "Palindromic Indices",
    "url": "https://codeforces.com/problemset/problem/1682/A",
    "history": "You are given a palindromic string s of length n . You have to count the number of indices i ( 1 \u2264 i \u2264 n) such that the string after removing s_ i from s still remains a palindrome. For example, consider s = \" aba\" If we remove s_ 1 from s , the string becomes \" ba\" which is not a palindrome. If we remove s_ 2 from s , the string becomes \" aa\" which is a palindrome. If we remove s_ 3 from s , the string becomes \" ab\" which is not a palindrome. A palindrome is a string that reads the same backward as forward. For example, \" abba\" , \" a\" , \" fef\" are palindromes whereas \" codeforces\" , \" acd\" , \" xy\" are not.",
    "input": "The input consists of multiple test cases. The first line of the input contains a single integer t ( 1 \u2264 t \u2264 10^ 3) \u2014 the number of test cases. Description of the test cases follows. The first line of each testcase contains a single integer n ( 2 \u2264 n \u2264 10^ 5) \u2014 the length of string s . The second line of each test case contains a string s consisting of lowercase English letters. It is guaranteed that s is a palindrome. It is guaranteed that sum of n over all test cases does not exceed 2 \u00b7 10^ 5 .",
    "output": "For each test case, output a single integer \u2014 the number of indices i ( 1 \u2264 i \u2264 n) such that the string after removing s_ i from s still remains a palindrome.",
    "note": "The first test case is described in the statement. In the second test case, the indices i that result in palindrome after removing s_ i are 3, 4, 5, 6 . Hence the answer is 4 . In the third test case, removal of any of the indices results in \" d\" which is a palindrome. Hence the answer is 2 .",
    "topics": [
      "greedy",
      "strings"
    ]
  },
  {
    "title": "Binary String",
    "url": "https://codeforces.com/problemset/problem/1680/C",
    "history": "You are given a string s consisting of characters 0 and/ or 1. You have to remove several ( possibly zero) characters from the beginning of the string, and then several ( possibly zero) characters from the end of the string. The string may become empty after the removals. The cost of the removal is the maximum of the following two values: the number of characters 0 left in the string; the number of characters 1 removed from the string. What is the minimum cost of removal you can achieve?",
    "input": "The first line contains one integer t ( 1 \u2264 t \u2264 10^ 4 ) \u2014 the number of test cases. Each test case consists of one line containing the string s ( 1 \u2264 | s| \u2264 2 \u00b7 10^ 5 ) , consisting of characters 0 and/ or 1. The total length of strings s in all test cases does not exceed 2 \u00b7 10^ 5 .",
    "output": "For each test case, print one integer \u2014 the minimum cost of removal you can achieve.",
    "note": "Consider the test cases of the example: in the first test case, it' s possible to remove two characters from the beginning and one character from the end. Only one 1 is deleted, only one 0 remains, so the cost is 1 ; in the second test case, it' s possible to remove three characters from the beginning and six characters from the end. Two characters 0 remain, three characters 1 are deleted, so the cost is 3 ; in the third test case, it' s optimal to remove four characters from the beginning; in the fourth test case, it' s optimal to remove the whole string; in the fifth test case, it' s optimal to leave the string as it is.",
    "topics": [
      "binary search",
      "greedy",
      "strings",
      "two pointers"
    ]
  },
  {
    "title": "Typical Party in Dorm",
    "url": "https://codeforces.com/problemset/problem/1679/E",
    "history": "Today is a holiday in the residence hall \u2014 Oleh arrived, in honor of which the girls gave him a string. Oleh liked the gift a lot, so he immediately thought up and offered you, his best friend, the following problem. You are given a string s of length n , which consists of the first 17 lowercase Latin letters a , b , c , . . . , p , q and question marks. And q queries. Each query is defined by a set of pairwise distinct lowercase first 17 letters of the Latin alphabet, which can be used to replace the question marks in the string s . The answer to the query is the sum of the number of distinct substrings that are palindromes over all strings that can be obtained from the original string s by replacing question marks with available characters. The answer must be calculated modulo 998 244 353 . Pay attention! Two substrings are different when their start and end positions in the string are different. So, the number of different substrings that are palindromes for the string aba will be 4 : a, b, a, aba. Consider examples of replacing question marks with letters. For example, from the string aba? ? ee when querying a , b you can get the strings ababaee or abaaaee but you cannot get the strings pizza, abaee, abacaba, aba? fee, aba47ee, or abatree. Recall that a palindrome is a string that reads the same from left to right as from right to left.",
    "input": "The first line contains a single integer n ( 1 \u2264 n \u2264 1 000 ) \u2014 the length of the string s . The second line contains the string s , which consists of n lowercase Latin letters and question marks. It is guaranteed that all letters in the string belong to the set a , b , c , . . . , p , q . The third line contains a single integer q ( 1 \u2264 q \u2264 2 \u00b7 10^ 5 ) \u2014 the number of queries. This is followed by q lines, each containing a single line t \u2014 a set of characters that can replace question marks ( 1 \u2264 | t| \u2264 17 ) . It is guaranteed that all letters in the string belong to the set a , b , c , . . . , p , q and occur at most once.",
    "output": "For each query print one number \u2014 the total numbers of palindromic substrings in all strings that can be obtained from the string s , modulo 998 244 353 .",
    "note": "Consider the first example and the first query in it. We can get only one string as a result of replacing the question marks \u2014 abaaaba. It has the following palindrome substrings: a \u2014 substring [ 1 ; 1 ] . b \u2014 substring [ 2 ; 2 ] . a \u2014 substring [ 3 ; 3 ] . a \u2014 substring [ 4 ; 4 ] . a \u2014 substring [ 5 ; 5 ] . b \u2014 substring [ 6 ; 6 ] . a \u2014 substring [ 7 ; 7 ] . aa \u2014 substring [ 3 ; 4 ] . aa \u2014 substring [ 4 ; 5 ] . aba \u2014 substring [ 1 ; 3 ] . aaa \u2014 substring [ 3 ; 5 ] . aba \u2014 substring [ 5 ; 7 ] . baaab \u2014 substring [ 2 ; 6 ] . abaaaba \u2014 substring [ 1 ; 7 ] . In the third request, we get 4 lines: abaaaba, abababa, abbaaba, abbbaba.",
    "topics": [
      "bitmasks",
      "combinatorics",
      "dp",
      "strings"
    ]
  },
  {
    "title": "Most Similar Words",
    "url": "https://codeforces.com/problemset/problem/1676/C",
    "history": "You are given n words of equal length m , consisting of lowercase Latin alphabet letters. The i - th word is denoted s_ i . In one move you can choose any position in any single word and change the letter at that position to the previous or next letter in alphabetical order. For example: you can change ' e' to ' d' or to ' f' ; ' a' can only be changed to ' b' ; ' z' can only be changed to ' y' . The difference between two words is the minimum number of moves required to make them equal. For example, the difference between \" best\" and \" cost\" is 1 + 10 + 0 + 0 = 11 . Find the minimum difference of s_ i and s_ j such that ( i < j) . In other words, find the minimum difference over all possible pairs of the n words.",
    "input": "The first line of the input contains a single integer t ( 1 \u2264 t \u2264 100 ) \u2014 the number of test cases. The description of test cases follows. The first line of each test case contains 2 integers n and m ( 2 \u2264 n \u2264 50 , 1 \u2264 m \u2264 8 ) \u2014 the number of strings and their length respectively. Then follows n lines, the i - th of which containing a single string s_ i of length m , consisting of lowercase Latin letters.",
    "output": "For each test case, print a single integer \u2014 the minimum difference over all possible pairs of the given strings.",
    "note": "For the second test case, one can show that the best pair is ( \" abb\" , \" bef\" ) , which has difference equal to 8 , which can be obtained in the following way: change the first character of the first string to ' b' in one move, change the second character of the second string to ' b' in 3 moves and change the third character of the second string to ' b' in 4 moves, thus making in total 1 + 3 + 4 = 8 moves. For the third test case, there is only one possible pair and it can be shown that the minimum amount of moves necessary to make the strings equal is 35 . For the fourth test case, there is a pair of strings which is already equal, so the answer is 0 .",
    "topics": [
      "brute force",
      "greedy",
      "implementation",
      "implementation",
      "math",
      "strings"
    ]
  },
  {
    "title": "Replace With the Previous, Minimize",
    "url": "https://codeforces.com/problemset/problem/1675/E",
    "history": "You are given a string s of lowercase Latin letters. The following operation can be used: select one character ( from ' a' to ' z' ) that occurs at least once in the string. And replace all such characters in the string with the previous one in alphabetical order on the loop. For example, replace all ' c' with ' b' or replace all ' a' with ' z' . And you are given the integer k \u2014 the maximum number of operations that can be performed. Find the minimum lexicographically possible string that can be obtained by performing no more than k operations. The string a= a_ 1a_ 2 . . . a_ n is lexicographically smaller than the string b = b_ 1b_ 2 . . . b_ n if there exists an index k ( 1 \u2264 k \u2264 n ) such that a_ 1= b_ 1 , a_ 2= b_ 2 , . . . , a_ k- 1= b_ k- 1 , but a_ k < b_ k .",
    "input": "The first line contains a single integer t ( 1 \u2264 t \u2264 10^ 4 ) \u2014the number of test cases in the test. This is followed by descriptions of the test cases. The first line of each test case contains two integers n and k ( 1 \u2264 n \u2264 2 \u00b7 10^ 5 , 1 \u2264 k \u2264 10^ 9 ) \u2014 the size of the string s and the maximum number of operations that can be performed on the string s . The second line of each test case contains a string s of length n consisting of lowercase Latin letters. It is guaranteed that the sum n over all test cases does not exceed 2 \u00b7 10^ 5 .",
    "output": "For each test case, output the lexicographically minimal string that can be obtained from the string s by performing no more than k operations.",
    "note": "",
    "topics": [
      "dsu",
      "greedy",
      "strings"
    ]
  },
  {
    "title": "Infinite Replacement",
    "url": "https://codeforces.com/problemset/problem/1674/C",
    "history": "You are given a string s , consisting only of Latin letters ' a' , and a string t , consisting of lowercase Latin letters. In one move, you can replace any letter ' a' in the string s with a string t . Note that after the replacement string s might contain letters other than ' a' . You can perform an arbitrary number of moves ( including zero) . How many different strings can you obtain? Print the number, or report that it is infinitely large. Two strings are considered different if they have different length, or they differ at some index.",
    "input": "The first line contains a single integer q ( 1 \u2264 q \u2264 10^ 4 ) \u2014 the number of testcases. The first line of each testcase contains a non- empty string s , consisting only of Latin letters ' a' . The length of s doesn' t exceed 50 . The second line contains a non- empty string t , consisting of lowercase Latin letters. The length of t doesn' t exceed 50 .",
    "output": "For each testcase, print the number of different strings s that can be obtained after an arbitrary amount of moves ( including zero) . If the number is infinitely large, print - 1. Otherwise, print the number.",
    "note": "In the first example, you can replace any letter ' a' with the string \" a\" , but that won' t change the string. So no matter how many moves you make, you can' t obtain a string other than the initial one. In the second example, you can replace the second letter ' a' with \" abc\" . String s becomes equal to \" aabc\" . Then the second letter ' a' again. String s becomes equal to \" aabcbc\" . And so on, generating infinitely many different strings. In the third example, you can either leave string s as is, performing zero moves, or replace the only ' a' with \" b\" . String s becomes equal to \" b\" , so you can' t perform more moves on it.",
    "topics": [
      "combinatorics",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "A Perfectly Balanced String?",
    "url": "https://codeforces.com/problemset/problem/1673/B",
    "history": "Let' s call a string s perfectly balanced if for all possible triplets ( t, u, v) such that t is a non- empty substring of s and u and v are characters present in s , the difference between the frequencies of u and v in t is not more than 1 . For example, the strings \" aba\" and \" abc\" are perfectly balanced but \" abb\" is not because for the triplet ( \" bb\" , ' a' , ' b' ) , the condition is not satisfied. You are given a string s consisting of lowercase English letters only. Your task is to determine whether s is perfectly balanced or not. A string b is called a substring of another string a if b can be obtained by deleting some characters ( possibly 0 ) from the start and some characters ( possibly 0 ) from the end of a .",
    "input": "The first line of input contains a single integer t ( 1\u2264 t\u2264 2\u00b7 10^ 4 ) denoting the number of testcases. Each of the next t lines contain a single string s ( 1\u2264 | s| \u2264 2\u00b7 10^ 5 ) , consisting of lowercase English letters. It is guaranteed that the sum of | s| over all testcases does not exceed 2\u00b7 10^ 5 .",
    "output": "For each test case, print \" YES\" if s is a perfectly balanced string, and \" NO\" otherwise. You may print each letter in any case ( for example, \" YES\" , \" Yes\" , \" yes\" , \" yEs\" will all be recognized as positive answer) .",
    "note": "Let f_ t( c) represent the frequency of character c in string t . For the first testcase we have t f_ t( a) f_ t( b) a 1 0 ab 1 1 aba 2 1 b 0 1 ba 1 1 It can be seen that for any substring t of s , the difference between f_ t( a) and f_ t( b) is not more than 1 . Hence the string s is perfectly balanced. For the second testcase we have t f_ t( a) f_ t( b) a 1 0 ab 1 1 abb 1 2 b 0 1 bb 0 2 It can be seen that for the substring t= bb , the difference between f_ t( a) and f_ t( b) is 2 which is greater than 1 . Hence the string s is not perfectly balanced. For the third testcase we have t f_ t( a) f_ t( b) f_ t( c) a 1 0 0 ab 1 1 0 abc 1 1 1 b 0 1 0 bc 0 1 1 c 0 0 1 It can be seen that for any substring t of s and any two characters u, v\u2208{ a, b, c} , the difference between f_ t( u) and f_ t( v) is not more than 1 . Hence the string s is perfectly balanced.",
    "topics": [
      "brute force",
      "greedy",
      "strings"
    ]
  },
  {
    "title": "Subtle Substring Subtraction",
    "url": "https://codeforces.com/problemset/problem/1673/A",
    "history": "Alice and Bob are playing a game with strings. There will be t rounds in the game. In each round, there will be a string s consisting of lowercase English letters. Alice moves first and both the players take alternate turns. Alice is allowed to remove any substring of even length ( possibly empty) and Bob is allowed to remove any substring of odd length from s . More formally, if there was a string s = s_ 1s_ 2 . . . s_ k the player can choose a substring s_ ls_ l+ 1. . . s_ r- 1s_ r with length of corresponding parity and remove it. After that the string will become s = s_ 1 . . . s_ l- 1s_ r+ 1. . . s_ k . After the string becomes empty, the round ends and each player calculates his/ her score for this round. The score of a player is the sum of values of all characters removed by him/ her. The value of is 1 , the value of is 2 , the value of is 3 , . . . , and the value of is 26 . The player with higher score wins the round. For each round, determine the winner and the difference between winner' s and loser' s scores. Assume that both players play optimally to maximize their score. It can be proved that a draw is impossible.",
    "input": "The first line of input contains a single integer t ( 1\u2264 t\u2264 5\u00b7 10^ 4 ) denoting the number of rounds. Each of the next t lines contain a single string s ( 1\u2264 | s| \u2264 2\u00b7 10^ 5 ) consisting of lowercase English letters, denoting the string used for the round. Here | s| denotes the length of the string s . It is guaranteed that the sum of | s| over all rounds does not exceed 2\u00b7 10^ 5 .",
    "output": "For each round, print a single line containing a string and an integer. If Alice wins the round, the string must be \" Alice\" . If Bob wins the round, the string must be \" Bob\" . The integer must be the difference between their scores assuming both players play optimally.",
    "note": "For the first round, . Alice' s total score is 1+ 2= 3 . Bob' s total score is 1 . For the second round, . Alice' s total score is 2+ 3= 5 . Bob' s total score is 1 . For the third round, . Alice' s total score is 3+ 2= 5 . Bob' s total score is 1 . For the fourth round, . Alice' s total score is 0 . Bob' s total score is 14 . For the fifth round, . Alice' s total score is 3+ 15+ 4+ 5+ 6+ 15+ 18+ 3+ 5+ 19= 93 . Bob' s total score is 0 .",
    "topics": [
      "games",
      "greedy",
      "strings"
    ]
  },
  {
    "title": "Dorms War",
    "url": "https://codeforces.com/problemset/problem/1670/B",
    "history": "Hosssam decided to sneak into Hemose' s room while he is sleeping and change his laptop' s password. He already knows the password, which is a string s of length n . He also knows that there are k special letters of the alphabet: c_ 1, c_ 2, . . . , c_ k . Hosssam made a program that can do the following. The program considers the current password s of some length m . Then it finds all positions i ( 1\u2264 i< m ) such that s_ i+ 1 is one of the k special letters. Then it deletes all of those positions from the password s even if s_ i is a special character. If there are no positions to delete, then the program displays an error message which has a very loud sound. For example, suppose the string s is \" abcdef\" and the special characters are ' b' and ' d' . If he runs the program once, the positions 1 and 3 will be deleted as they come before special characters, so the password becomes \" bdef\" . If he runs the program again, it deletes position 1 , and the password becomes \" def\" . If he is wise, he won' t run it a third time. Hosssam wants to know how many times he can run the program on Hemose' s laptop without waking him up from the sound of the error message. Can you help him?",
    "input": "The first line contains a single integer t ( 1 \u2264 t \u2264 10^ 5 ) \u2014 the number of test cases. Then t test cases follow. The first line of each test case contains a single integer n ( 2 \u2264 n \u2264 10^ 5 ) \u2014 the initial length of the password. The next line contains a string s consisting of n lowercase English letters \u2014 the initial password. The next line contains an integer k ( 1 \u2264 k \u2264 26 ) , followed by k distinct lowercase letters c_ 1, c_ 2, . . . , c_ k \u2014 the special letters. It is guaranteed that the sum of n over all test cases does not exceed 2\u00b7 10^ 5 .",
    "output": "For each test case, print the maximum number of times Hosssam can run the program without displaying the error message, on a new line.",
    "note": "In the first test case, the program can run 5 times as follows: iloveslim\u2192ilovslim\u2192iloslim\u2192ilslim\u2192islim\u2192slim In the second test case, the program can run 2 times as follows: joobeel\u2192oel\u2192el In the third test case, the program can run 3 times as follows: basiozi\u2192bioi\u2192ii\u2192i . In the fourth test case, the program can run 5 times as follows: khater\u2192khatr\u2192khar\u2192khr\u2192kr\u2192r In the fifth test case, the program can run only once as follows: abobeih\u2192h In the sixth test case, the program cannot run as none of the characters in the password is a special character.",
    "topics": [
      "brute force",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "2-Letter Strings",
    "url": "https://codeforces.com/problemset/problem/1669/E",
    "history": "Given n strings, each of length 2 , consisting of lowercase Latin alphabet letters from ' a' to ' k' , output the number of pairs of indices ( i, j) such that i < j and the i - th string and the j - th string differ in exactly one position. In other words, count the number of pairs ( i, j) ( i < j ) such that the i - th string and the j - th string have exactly one position p ( 1 \u2264 p \u2264 2 ) such that s_ i_ p= \u0338s_ j_ p . The answer may not fit into 32- bit integer type, so you should use 64- bit integers like long long in C+ + to avoid integer overflow.",
    "input": "The first line of the input contains a single integer t ( 1 \u2264 t \u2264 100 ) \u2014 the number of test cases. The description of test cases follows. The first line of each test case contains a single integer n ( 1 \u2264 n \u2264 10^ 5 ) \u2014 the number of strings. Then follows n lines, the i - th of which containing a single string s_ i of length 2 , consisting of lowercase Latin letters from ' a' to ' k' . It is guaranteed that the sum of n over all test cases does not exceed 10^ 5 .",
    "output": "For each test case, print a single integer \u2014 the number of pairs ( i, j) ( i < j ) such that the i - th string and the j - th string have exactly one position p ( 1 \u2264 p \u2264 2 ) such that s_ i_ p= \u0338s_ j_ p . Please note, that the answer for some test cases won' t fit into 32- bit integer type, so you should use at least 64- bit integer type in your programming language ( like long long for C+ + ) .",
    "note": "For the first test case the pairs that differ in exactly one position are: ( \" ab\" , \" cb\" ) , ( \" ab\" , \" db\" ) , ( \" ab\" , \" aa\" ) , ( \" cb\" , \" db\" ) and ( \" cb\" , \" cc\" ) . For the second test case the pairs that differ in exactly one position are: ( \" aa\" , \" ac\" ) , ( \" aa\" , \" ca\" ) , ( \" cc\" , \" ac\" ) , ( \" cc\" , \" ca\" ) , ( \" ac\" , \" aa\" ) and ( \" ca\" , \" aa\" ) . For the third test case, the are no pairs satisfying the conditions.",
    "topics": [
      "data structures",
      "math",
      "strings"
    ]
  },
  {
    "title": "Six Characters",
    "url": "https://codeforces.com/problemset/problem/1663/G",
    "history": "Aenar should go to the string' s home.",
    "input": "A string consisting of only 6 letters.",
    "output": "A string consisting of only 6 characters.",
    "note": "If many answers are possible, the jury will still only accept one!",
    "topics": [
      "*special",
      "constructive algorithms",
      "strings"
    ]
  },
  {
    "title": "In Every Generation...",
    "url": "https://codeforces.com/problemset/problem/1663/F",
    "history": "In every generation there is a Chosen One. She alone will stand against the vampires, the demons, and the forces of darkness. She is the Slayer. \u2014 Joss Whedon",
    "input": "A string s ( 3 \u2264 | s| \u2264 7 ) consisting of lowercase English letters.",
    "output": "A single string. If there is no answer, print \" none\" ( without the quotes) .",
    "note": "",
    "topics": [
      "*special",
      "strings"
    ]
  },
  {
    "title": "Evolution of Weasels",
    "url": "https://codeforces.com/problemset/problem/1662/D",
    "history": "A wild basilisk just appeared at your doorstep. You are not entirely sure what a basilisk is and you wonder whether it evolved from your favorite animal, the weasel. How can you find out whether basilisks evolved from weasels? Certainly, a good first step is to sequence both of their DNAs. Then you can try to check whether there is a sequence of possible mutations from the DNA of the weasel to the DNA of the basilisk. Your friend Ron is a talented alchemist and has studied DNA sequences in many of his experiments. He has found out that DNA strings consist of the letters A, B and C and that single mutations can only remove or add substrings at any position in the string ( a substring is a contiguous sequence of characters) . The substrings that can be removed or added by a mutation are AA, BB, CC, ABAB or BCBC. During a sequence of mutations a DNA string may even become empty. Ron has agreed to sequence the DNA of the weasel and the basilisk for you, but finding out whether there is a sequence of possible mutations that leads from one to the other is too difficult for him, so you have to do it on your own.",
    "input": "Each test contains multiple test cases. The first line contains an integer t ( 1\u2264 t\u2264 100 ) \u2014 the number of test cases. The descriptions of the t test cases follow. The first line of each test case contains a string u ( 1\u2264 | u| \u2264 200 ) \u2014 the DNA of the weasel. The second line of each test case contains a string v ( 1\u2264 | v| \u2264 200 ) \u2014 the DNA of the basilisk. The values | u| , | v| denote the lengths of the strings u and v . It is guaranteed that both strings u and v consist of the letters A, B and C.",
    "output": "For each test case, print YES if there is a sequence of mutations to get from u to v and NO otherwise.",
    "note": "",
    "topics": [
      "greedy",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Toys",
    "url": "https://codeforces.com/problemset/problem/1662/B",
    "history": "Vittorio has three favorite toys: a teddy bear, an owl, and a raccoon. Each of them has a name. Vittorio takes several sheets of paper and writes a letter on each side of every sheet so that it is possible to spell any of the three names by arranging some of the sheets in a row ( sheets can be reordered and flipped as needed) . The three names do not have to be spelled at the same time, it is sufficient that it is possible to spell each of them using all the available sheets ( and the same sheet can be used to spell different names) . Find the minimum number of sheets required. In addition, produce a list of sheets with minimum cardinality which can be used to spell the three names ( if there are multiple answers, print any) .",
    "input": "The first line contains a string t consisting of uppercase letters of the English alphabet ( 1\u2264 | t| \u2264 1000 ) \u2014 the name of the teddy bear. The second line contains a string o consisting of uppercase letters of the English alphabet ( 1\u2264 | o| \u2264 1000 ) \u2014 the name of the owl. The third line contains a string r consisting of uppercase letters of the English alphabet ( 1\u2264 | r| \u2264 1000 ) \u2014 the name of the raccoon. The values | t| , | o| , | r| denote the length of the three names t , o , r .",
    "output": "The first line of the output contains a single integer m \u2014 the minimum number of sheets required. Then m lines follow: the j - th of these lines contains a string of two uppercase letters of the English alphabet \u2014 the letters appearing on the two sides of the j - th sheet. Note that you can print the sheets and the two letters of each sheet in any order.",
    "note": "In the first sample, the solution uses two sheets: the first sheet has A on one side and G on the other side; the second sheet has A on one side and M on the other side. The name AA can be spelled using the A side of both sheets. The name GA can be spelled using the G side of the first sheet and the A side of the second sheet. Finally, the name MA can be spelled using the M side of the second sheet and the A side of the first sheet.",
    "topics": [
      "greedy",
      "strings"
    ]
  },
  {
    "title": "Promising String (hard version)",
    "url": "https://codeforces.com/problemset/problem/1660/F2",
    "history": "This is the hard version of Problem F. The only difference between the easy version and the hard version is the constraints. We will call a non- empty string balanced if it contains the same number of plus and minus signs. For example: strings \" + \u2013+ \" and \" + + - + \u2013\" are balanced, and strings \" + \u2013\" , \" \u2013\" and \" \" are not balanced. We will call a string promising if the string can be made balanced by several ( possibly zero) uses of the following operation: replace two adjacent minus signs with one plus sign. In particular, every balanced string is promising. However, the converse is not true: not every promising string is balanced. For example, the string \" - + \u2014\" is promising, because you can replace two adjacent minuses with plus and get a balanced string \" - + + - \" , or get another balanced string \" - + - + \" . How many non- empty substrings of the given string s are promising? Each non- empty promising substring must be counted in the answer as many times as it occurs in string s . Recall that a substring is a sequence of consecutive characters of the string. For example, for string \" + - + \" its substring are: \" + - \" , \" - + \" , \" + \" , \" + - + \" ( the string is a substring of itself) and some others. But the following strings are not its substring: \" \u2013\" , \" + + \" , \" - + + \" .",
    "input": "The first line of the input contains an integer t ( 1 \u2264 t \u2264 10^ 4 ) \u2014the number of test cases in the test. Then the descriptions of test cases follow. Each test case of input data consists of two lines. The first line consists of the number n ( 1 \u2264 n \u2264 2 \u00b7 10^ 5 ) : the length of s . The second line of the test case contains the string s of length n , consisting only of characters \" + \" and \" - \" . It is guaranteed that the sum of values n over all test cases does not exceed 2 \u00b7 10^ 5 .",
    "output": "For each test case, print a single number: the number of the promising non- empty substrings of string s . Each non- empty promising substring must be counted in the answer as many times as it occurs in string s .",
    "note": "The following are the promising substrings for the first three test cases in the example: s[ 1 . . . 2] = \" + - \" , s[ 2 . . . 3] = \" - + \" ; s[ 1 . . . 2] = \" - + \" , s[ 2 . . . 3] = \" + - \" , s[ 1 . . . 5] = \" - + \u2014\" , s[ 3 . . . 5] = \" \u2014\" ; s[ 1 . . . 3] = \" \u2014\" , s[ 2 . . . 4] = \" \u2014\" .",
    "topics": [
      "data structures",
      "implementation",
      "math",
      "strings"
    ]
  },
  {
    "title": "Promising String (easy version)",
    "url": "https://codeforces.com/problemset/problem/1660/F1",
    "history": "This is the easy version of Problem F. The only difference between the easy version and the hard version is the constraints. We will call a non- empty string balanced if it contains the same number of plus and minus signs. For example: strings \" + \u2013+ \" and \" + + - + \u2013\" are balanced, and strings \" + \u2013\" , \" \u2013\" and \" \" are not balanced. We will call a string promising if the string can be made balanced by several ( possibly zero) uses of the following operation: replace two adjacent minus signs with one plus sign. In particular, every balanced string is promising. However, the converse is not true: not every promising string is balanced. For example, the string \" - + \u2014\" is promising, because you can replace two adjacent minuses with plus and get a balanced string \" - + + - \" , or get another balanced string \" - + - + \" . How many non- empty substrings of the given string s are promising? Each non- empty promising substring must be counted in the answer as many times as it occurs in string s . Recall that a substring is a sequence of consecutive characters of the string. For example, for string \" + - + \" its substring are: \" + - \" , \" - + \" , \" + \" , \" + - + \" ( the string is a substring of itself) and some others. But the following strings are not its substring: \" \u2013\" , \" + + \" , \" - + + \" .",
    "input": "The first line of the input contains an integer t ( 1 \u2264 t \u2264 500 ) \u2014the number of test cases in the test. Then the descriptions of test cases follow. Each test case of input data consists of two lines. The first line consists of the number n ( 1 \u2264 n \u2264 3000 ) : the length of s . The second line of the test case contains the string s of length n , consisting only of characters \" + \" and \" - \" . It is guaranteed that the sum of values n over all test cases does not exceed 3000 .",
    "output": "For each test case, print a single number: the number of the promising non- empty substrings of string s . Each non- empty promising substring must be counted in the answer as many times as it occurs in string s .",
    "note": "The following are the promising substrings for the first three test cases in the example: s[ 1 . . . 2] = \" + - \" , s[ 2 . . . 3] = \" - + \" ; s[ 1 . . . 2] = \" - + \" , s[ 2 . . . 3] = \" + - \" , s[ 1 . . . 5] = \" - + \u2014\" , s[ 3 . . . 5] = \" \u2014\" ; s[ 1 . . . 3] = \" \u2014\" , s[ 2 . . . 4] = \" \u2014\" .",
    "topics": [
      "brute force",
      "implementation",
      "math",
      "strings"
    ]
  },
  {
    "title": "Get an Even String",
    "url": "https://codeforces.com/problemset/problem/1660/C",
    "history": "A string a= a_ 1a_ 2. . . a_ n is called even if it consists of a concatenation ( joining) of strings of length 2 consisting of the same characters. In other words, a string a is even if two conditions are satisfied at the same time: its length n is even; for all odd i ( 1 \u2264 i \u2264 n - 1 ) , a_ i = a_ i+ 1 is satisfied. For example, the following strings are even: \" \" ( empty string) , \" tt\" , \" aabb\" , \" oooo\" , and \" ttrrrroouuuuuuuukk\" . The following strings are not even: \" aaa\" , \" abab\" and \" abba\" . Given a string s consisting of lowercase Latin letters. Find the minimum number of characters to remove from the string s to make it even. The deleted characters do not have to be consecutive.",
    "input": "The first line of input data contains an integer t ( 1 \u2264 t \u2264 10^ 4 ) \u2014the number of test cases in the test. The descriptions of the test cases follow. Each test case consists of one string s ( 1 \u2264 | s| \u2264 2 \u00b7 10^ 5 ) , where | s| \u2014 the length of the string s . The string consists of lowercase Latin letters. It is guaranteed that the sum of | s| on all test cases does not exceed 2 \u00b7 10^ 5 .",
    "output": "For each test case, print a single number \u2014 the minimum number of characters that must be removed to make s even.",
    "note": "In the first test case you can remove the characters with indices 6 , 7 , and 9 to get an even string \" aabbddcc\" . In the second test case, each character occurs exactly once, so in order to get an even string, you must remove all characters from the string. In the third test case, you can get an even string \" aaaabb\" by removing, for example, 4 - th and 6 - th characters, or a string \" aabbbb\" by removing the 5 - th character and any of the first three.",
    "topics": [
      "dp",
      "greedy",
      "strings"
    ]
  },
  {
    "title": "Bit Flipping",
    "url": "https://codeforces.com/problemset/problem/1659/B",
    "history": "You are given a binary string of length n . You have exactly k moves. In one move, you must select a single bit. The state of all bits except that bit will get flipped ( 0 becomes 1 , 1 becomes 0 ) . You need to output the lexicographically largest string that you can get after using all k moves. Also, output the number of times you will select each bit. If there are multiple ways to do this, you may output any of them. A binary string a is lexicographically larger than a binary string b of the same length, if and only if the following holds: in the first position where a and b differ, the string a contains a 1 , and the string b contains a 0 .",
    "input": "The first line contains a single integer t ( 1 \u2264 t \u2264 1000 ) \u2014 the number of test cases. Each test case has two lines. The first line has two integers n and k ( 1 \u2264 n \u2264 2 \u00b7 10^ 5 ; 0 \u2264 k \u2264 10^ 9 ) . The second line has a binary string of length n , each character is either 0 or 1 . The sum of n over all test cases does not exceed 2 \u00b7 10^ 5 .",
    "output": "For each test case, output two lines. The first line should contain the lexicographically largest string you can obtain. The second line should contain n integers f_ 1, f_ 2, . . . , f_ n , where f_ i is the number of times the i - th bit is selected. The sum of all the integers must be equal to k .",
    "note": "Here is the explanation for the first testcase. Each step shows how the binary string changes in a move. Choose bit 1 : 100001\u2192111110 . Choose bit 4 : 111110\u2192000101 . Choose bit 4 : 000101\u2192111110 . The final string is 111110 and this is the lexicographically largest string we can get.",
    "topics": [
      "bitmasks",
      "constructive algorithms",
      "greedy",
      "strings"
    ]
  },
  {
    "title": "Minimal String Xoration",
    "url": "https://codeforces.com/problemset/problem/1654/F",
    "history": "You are given an integer n and a string s consisting of 2^ n lowercase letters of the English alphabet. The characters of the string s are s_ 0s_ 1s_ 2\u22ef s_ 2^ n- 1 . A string t of length 2^ n ( whose characters are denoted by t_ 0t_ 1t_ 2\u22ef t_ 2^ n- 1 ) is a xoration of s if there exists an integer j ( 0\u2264 j \u2264 2^ n- 1 ) such that, for each 0 \u2264 i \u2264 2^ n- 1 , t_ i = s_ i \u2295 j ( where \u2295 denotes the operation bitwise XOR) . Find the lexicographically minimal xoration of s . A string a is lexicographically smaller than a string b if and only if one of the following holds: a is a prefix of b , but a b ; in the first position where a and b differ, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b .",
    "input": "The first line contains a single integer n ( 1 \u2264 n \u2264 18 ) . The second line contains a string s consisting of 2^ n lowercase letters of the English alphabet.",
    "output": "Print a single line containing the lexicographically minimal xoration of s .",
    "note": "In the first test, the lexicographically minimal xoration t of s = \" acba\" is \" abca\" . It' s a xoration because, for j = 3 , t_ 0 = s_ 0 \u2295 j = s_ 3 = \" a\" ; t_ 1 = s_ 1 \u2295 j = s_ 2 = \" b\" ; t_ 2 = s_ 2 \u2295 j = s_ 1 = \" c\" ; t_ 3 = s_ 3 \u2295 j = s_ 0 = \" a\" . There isn' t any xoration of s lexicographically smaller than \" abca\" . In the second test, the minimal string xoration corresponds to choosing j = 4 in the definition of xoration. In the third test, the minimal string xoration corresponds to choosing j = 11 in the definition of xoration. In the fourth test, the minimal string xoration corresponds to choosing j = 10 in the definition of xoration. In the fifth test, the minimal string xoration corresponds to choosing either j = 0 or j = 1 in the definition of xoration.",
    "topics": [
      "bitmasks",
      "data structures",
      "divide and conquer",
      "greedy",
      "hashing",
      "sortings",
      "strings"
    ]
  },
  {
    "title": "Prefix Removals",
    "url": "https://codeforces.com/problemset/problem/1654/B",
    "history": "You are given a string s consisting of lowercase letters of the English alphabet. You must perform the following algorithm on s : Let x be the length of the longest prefix of s which occurs somewhere else in s as a contiguous substring ( the other occurrence may also intersect the prefix) . If x = 0 , break. Otherwise, remove the first x characters of s , and repeat. A prefix is a string consisting of several first letters of a given string, without any reorders. An empty prefix is also a valid prefix. For example, the string \" abcd\" has 5 prefixes: empty string, \" a\" , \" ab\" , \" abc\" and \" abcd\" . For instance, if we perform the algorithm on s = \" abcabdc\" , Initially, \" ab\" is the longest prefix that also appears somewhere else as a substring in s , so s = \" cabdc\" after 1 operation. Then, \" c\" is the longest prefix that also appears somewhere else as a substring in s , so s = \" abdc\" after 2 operations. Now x= 0 ( because there are no non- empty prefixes of \" abdc\" that also appear somewhere else as a substring in s ) , so the algorithm terminates. Find the final state of the string after performing the algorithm.",
    "input": "The first line contains a single integer t ( 1 \u2264 t \u2264 10^ 4 ) \u2014 the number of test cases. This is followed by t lines, each containing a description of one test case. Each line contains a string s . The given strings consist only of lowercase letters of the English alphabet and have lengths between 1 and 2 \u00b7 10^ 5 inclusive. It is guaranteed that the sum of the lengths of s over all test cases does not exceed 2 \u00b7 10^ 5 .",
    "output": "For each test case, print a single line containing the string s after executing the algorithm. It can be shown that such string is non- empty.",
    "note": "The first test case is explained in the statement. In the second test case, no operations can be performed on s . In the third test case, Initially, s = \" bbbbbbbbbb\" . After 1 operation, s = \" b\" . In the fourth test case, Initially, s = \" codeforces\" . After 1 operation, s = \" odeforces\" . After 2 operations, s = \" deforces\" .",
    "topics": [
      "strings"
    ]
  },
  {
    "title": "Deletions of Two Adjacent Letters",
    "url": "https://codeforces.com/problemset/problem/1650/A",
    "history": "The string s is given, the string length is odd number. The string consists of lowercase letters of the Latin alphabet. As long as the string length is greater than 1 , the following operation can be performed on it: select any two adjacent letters in the string s and delete them from the string. For example, from the string \" lemma\" in one operation, you can get any of the four strings: \" mma\" , \" lma\" , \" lea\" or \" lem\" In particular, in one operation, the length of the string reduces by 2 . Formally, let the string s have the form s= s_ 1s_ 2 . . . s_ n ( n> 1 ) . During one operation, you choose an arbitrary index i ( 1 \u2264 i < n ) and replace s= s_ 1s_ 2 . . . s_ i- 1s_ i+ 2. . . s_ n . For the given string s and the letter c , determine whether it is possible to make such a sequence of operations that in the end the equality s= c will be true? In other words, is there such a sequence of operations that the process will end with a string of length 1 , which consists of the letter c ?",
    "input": "The first line of input data contains an integer t ( 1 \u2264 t \u2264 10^ 3 ) \u2014 the number of input test cases. The descriptions of the t cases follow. Each test case is represented by two lines: string s , which has an odd length from 1 to 49 inclusive and consists of lowercase letters of the Latin alphabet; is a string containing one letter c , where c is a lowercase letter of the Latin alphabet.",
    "output": "For each test case in a separate line output: YES, if the string s can be converted so that s= c is true; NO otherwise. You can output YES and NO in any case ( for example, the strings yEs, yes, Yes and YES will be recognized as a positive response) .",
    "note": "In the first test case, s = \" abcde\" . You need to get s = \" c\" . For the first operation, delete the first two letters, we get s = \" cde\" . In the second operation, we delete the last two letters, so we get the expected value of s = \" c\" . In the third test case, s = \" x\" , it is required to get s = \" y\" . Obviously, this cannot be done.",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Infinite Set",
    "url": "https://codeforces.com/problemset/problem/1635/D",
    "history": "You are given an array a consisting of n distinct positive integers. Let' s consider an infinite integer set S which contains all integers x that satisfy at least one of the following conditions: x = a_ i for some 1 \u2264 i \u2264 n . x = 2y + 1 and y is in S . x = 4y and y is in S . For example, if a = [ 1, 2] then the 10 smallest elements in S will be { 1, 2, 3, 4, 5, 7, 8, 9, 11, 12} . Find the number of elements in S that are strictly smaller than 2^ p . Since this number may be too large, print it modulo 10^ 9 + 7 .",
    "input": "The first line contains two integers n and p ( 1 \u2264 n, p \u2264 2 \u00b7 10^ 5) . The second line contains n integers a_ 1, a_ 2, . . . , a_ n ( 1 \u2264 a_ i \u2264 10^ 9) . It is guaranteed that all the numbers in a are distinct.",
    "output": "Print a single integer, the number of elements in S that are strictly smaller than 2^ p . Remember to print it modulo 10^ 9 + 7 .",
    "note": "In the first example, the elements smaller than 2^ 4 are { 1, 3, 4, 6, 7, 9, 12, 13, 15} . In the second example, the elements smaller than 2^ 7 are { 5, 11, 20, 23, 39, 41, 44, 47, 79, 80, 83, 89, 92, 95} .",
    "topics": [
      "bitmasks",
      "dp",
      "math",
      "matrices",
      "number theory",
      "strings"
    ]
  },
  {
    "title": "Reverse and Concatenate",
    "url": "https://codeforces.com/problemset/problem/1634/A",
    "history": "Real stupidity beats artificial intelligence every time. \u2014 Terry Pratchett, Hogfather, DiscworldYou are given a string s of length n and a number k . Let' s denote by rev( s) the reversed string s ( i. e. rev( s) = s_ n s_ n- 1 . . . s_ 1 ) . You can apply one of the two kinds of operations to the string: replace the string s with s + rev( s) replace the string s with rev( s) + s How many different strings can you get as a result of performing exactly k operations ( possibly of different kinds) on the original string s ? In this statement we denoted the concatenation of strings s and t as s + t . In other words, s + t = s_ 1 s_ 2 . . . s_ n t_ 1 t_ 2 . . . t_ m , where n and m are the lengths of strings s and t respectively.",
    "input": "The first line contains one integer t ( 1 \u2264 t \u2264 100 ) \u2014 number of test cases. Next 2 \u00b7 t lines contain t test cases: The first line of a test case contains two integers n and k ( 1 \u2264 n \u2264 100 , 0 \u2264 k \u2264 1000 ) \u2014 the length of the string and the number of operations respectively. The second string of a test case contains one string s of length n consisting of lowercase Latin letters.",
    "output": "For each test case, print the answer ( that is, the number of different strings that you can get after exactly k operations) on a separate line. It can be shown that the answer does not exceed 10^ 9 under the given constraints.",
    "note": "In the first test case of the example: After the first operation the string s can become either aabbaa or baaaab. After the second operation there are 2 possibilities for s : aabbaaaabbaa and baaaabbaaaab.",
    "topics": [
      "greedy",
      "strings"
    ]
  },
  {
    "title": "Peculiar Movie Preferences",
    "url": "https://codeforces.com/problemset/problem/1628/B",
    "history": "Mihai plans to watch a movie. He only likes palindromic movies, so he wants to skip some ( possibly zero) scenes to make the remaining parts of the movie palindromic. You are given a list s of n non- empty strings of length at most 3 , representing the scenes of Mihai' s movie. A subsequence of s is called awesome if it is non- empty and the concatenation of the strings in the subsequence, in order, is a palindrome. Can you help Mihai check if there is at least one awesome subsequence of s ? A palindrome is a string that reads the same backward as forward, for example strings \" z\" , \" aaa\" , \" aba\" , \" abccba\" are palindromes, but strings \" codeforces\" , \" reality\" , \" ab\" are not. A sequence a is a non- empty subsequence of a non- empty sequence b if a can be obtained from b by deletion of several ( possibly zero, but not all) elements.",
    "input": "The first line of the input contains a single integer t ( 1 \u2264 t \u2264 100 ) \u2014 the number of test cases. The description of test cases follows. The first line of each test case contains a single integer n ( 1 \u2264 n \u2264 10^ 5 ) \u2014 the number of scenes in the movie. Then follows n lines, the i - th of which containing a single non- empty string s_ i of length at most 3 , consisting of lowercase Latin letters. It is guaranteed that the sum of n over all test cases does not exceed 10^ 5 .",
    "output": "For each test case, print \" YES\" if there is an awesome subsequence of s , or \" NO\" otherwise ( case insensitive) .",
    "note": "In the first test case, an awesome subsequence of s is [ ab, cc, ba]",
    "topics": [
      "greedy",
      "strings"
    ]
  },
  {
    "title": "Minor Reduction",
    "url": "https://codeforces.com/problemset/problem/1626/B",
    "history": "You are given a decimal representation of an integer x without leading zeros. You have to perform the following reduction on it exactly once: take two neighboring digits in x and replace them with their sum without leading zeros ( if the sum is 0 , it' s represented as a single 0 ) . For example, if x = 10057 , the possible reductions are: choose the first and the second digits 1 and 0 , replace them with 1+ 0= 1 ; the result is 1057 ; choose the second and the third digits 0 and 0 , replace them with 0+ 0= 0 ; the result is also 1057 ; choose the third and the fourth digits 0 and 5 , replace them with 0+ 5= 5 ; the result is still 1057 ; choose the fourth and the fifth digits 5 and 7 , replace them with 5+ 7= 12 ; the result is 10012 . What' s the largest number that can be obtained?",
    "input": "The first line contains a single integer t ( 1 \u2264 t \u2264 10^ 4 ) \u2014 the number of testcases. Each testcase consists of a single integer x ( 10 \u2264 x < 10^ 200000 ) . x doesn' t contain leading zeros. The total length of the decimal representations of x over all testcases doesn' t exceed 2 \u00b7 10^ 5 .",
    "output": "For each testcase, print a single integer \u2014 the largest number that can be obtained after the reduction is applied exactly once. The number should not contain leading zeros.",
    "note": "The first testcase of the example is already explained in the statement. In the second testcase, there is only one possible reduction: the first and the second digits.",
    "topics": [
      "greedy",
      "strings"
    ]
  },
  {
    "title": "Masha-forgetful",
    "url": "https://codeforces.com/problemset/problem/1624/E",
    "history": "Masha meets a new friend and learns his phone number \u2014 s . She wants to remember it as soon as possible. The phone number \u2014 is a string of length m that consists of digits from 0 to 9 . The phone number may start with 0. Masha already knows n phone numbers ( all numbers have the same length m ) . It will be easier for her to remember a new number if the s is represented as segments of numbers she already knows. Each such segment must be of length at least 2 , otherwise there will be too many segments and Masha will get confused. For example, Masha needs to remember the number: s = ' 12345678' and she already knows n = 4 numbers: ' 12340219' , ' 20215601' , ' 56782022' , ' 12300678' . You can represent s as a 3 segment: ' 1234' of number one, ' 56' of number two, and ' 78' of number three. There are other ways to represent s . Masha asks you for help, she asks you to break the string s into segments of length 2 or more of the numbers she already knows. If there are several possible answers, print any of them.",
    "input": "The first line of input data contains an integer t ( 1 \u2264 t \u2264 10^ 4 ) \u2014the number of test cases. Before each test case there is a blank line. Then there is a line containing integers n and m ( 1 \u2264 n, m \u2264 10^ 3 ) \u2014the number of phone numbers that Masha knows and the number of digits in each phone number. Then follow n line, i - th of which describes the i - th number that Masha knows. The next line contains the phone number of her new friend s . Among the given n+ 1 phones, there may be duplicates ( identical phones) . It is guaranteed that the sum of n \u00b7 m ( n multiplied by m ) values over all input test cases does not exceed 10^ 6 .",
    "output": "You need to print the answers to t test cases. The first line of the answer should contain one number k , corresponding to the number of segments into which you split the phone number s . Print - 1 if you cannot get such a split. If the answer is yes, then follow k lines containing triples of numbers l, r, i . Such triplets mean that the next r- l+ 1 digits of number s are equal to a segment ( substring) with boundaries [ l, r] of the phone under number i . Both the phones and the digits in them are numbered from 1 . Note that r- l+ 1 \u2265 2 for all k lines.",
    "note": "The example from the statement. In the second case, it is impossible to represent by segments of known numbers of length 2 or more. In the third case, you can get the segments ' 12' and ' 21' from the first phone number.",
    "topics": [
      "brute force",
      "constructive algorithms",
      "dp",
      "hashing",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Palindromes Coloring",
    "url": "https://codeforces.com/problemset/problem/1624/D",
    "history": "You have a string s consisting of lowercase Latin alphabet letters. You can color some letters in colors from 1 to k . It is not necessary to paint all the letters. But for each color, there must be a letter painted in that color. Then you can swap any two symbols painted in the same color as many times as you want. After that, k strings will be created, i - th of them will contain all the characters colored in the color i , written in the order of their sequence in the string s . Your task is to color the characters of the string so that all the resulting k strings are palindromes, and the length of the shortest of these k strings is as large as possible. Read the note for the first test case of the example if you need a clarification. Recall that a string is a palindrome if it reads the same way both from left to right and from right to left. For example, the strings abacaba, cccc, z and dxd are palindromes, but the strings abab and aaabaa \u2014 are not.",
    "input": "The first line of input data contains a single integer t ( 1 \u2264 t \u2264 10^ 4 ) \u2014 the number of input data sets in the test. The descriptions of the input data sets follow. The first line of the description of each input data set contains two integers n and k ( 1 \u2264 k \u2264 n \u2264 2 \u00b7 10^ 5 ) \u2014 the length of the string and the number of colors in which its letters can be painted. The second line of the description of each input data set contains a string s of length n consisting of lowercase letters of the Latin alphabet. It is guaranteed that the sum of n over all test cases does not exceed 2 \u00b7 10^ 5 .",
    "output": "For each set of input data, output a single integer \u2014 the maximum length of the shortest palindrome string that can be obtained.",
    "note": "In the first test case, s = \" bxyaxzay\" , k= 2 . We use indices in the string from 1 to 8 . The following coloring will work: bxyaxzay ( the letter z remained uncolored) . After painting: swap two red characters ( with the indices 1 and 4 ) , we get axybxzay ; swap two blue characters ( with the indices 5 and 8 ) , we get axybyzax . Now, for each of the two colors we write out the corresponding characters from left to right, we get two strings aba and xyyx . Both of them are palindromes, the length of the shortest is 3 . It can be shown that the greatest length of the shortest palindrome cannot be achieved. In the second set of input data, the following coloring is suitable: [ 1, 1, 2, 2, 3, 3] . There is no need to swap characters. Both received strings are equal to aa, they are palindromes and their length is 2 . In the third set of input data, you can color any character and take it into a string. In the fourth set of input data, you can color the i th character in the color i . In the fifth set of input data can be colored in each of the colors of one character. In the sixth set of input data, the following coloring is suitable: [ 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 0] . Rearrange the characters so as to get the palindromes abcba and acbca.",
    "topics": [
      "binary search",
      "greedy",
      "sortings",
      "strings"
    ]
  },
  {
    "title": "Middle Duplication",
    "url": "https://codeforces.com/problemset/problem/1623/E",
    "history": "A binary tree of n nodes is given. Nodes of the tree are numbered from 1 to n and the root is the node 1 . Each node can have no child, only one left child, only one right child, or both children. For convenience, let' s denote l_ u and r_ u as the left and the right child of the node u respectively, l_ u = 0 if u does not have the left child, and r_ u = 0 if the node u does not have the right child. Each node has a string label, initially is a single character c_ u . Let' s define the string representation of the binary tree as the concatenation of the labels of the nodes in the in- order. Formally, let f( u) be the string representation of the tree rooted at the node u . f( u) is defined as follows: f( u) = , if u = 0; f( l_ u) + c_ u + f( r_ u) otherwise, where + denotes the string concatenation operation. This way, the string representation of the tree is f( 1) . For each node, we can duplicate its label at most once, that is, assign c_ u with c_ u + c_ u , but only if u is the root of the tree, or if its parent also has its label duplicated. You are given the tree and an integer k . What is the lexicographically smallest string representation of the tree, if we can duplicate labels of at most k nodes? A string a is lexicographically smaller than a string b if and only if one of the following holds: a is a prefix of b , but a b ; in the first position where a and b differ, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b .",
    "input": "The first line contains two integers n and k ( 1 \u2264 k \u2264 n \u2264 2 \u00b7 10^ 5 ) . The second line contains a string c of n lower- case English letters, where c_ i is the initial label of the node i for 1 \u2264 i \u2264 n . Note that the given string c is not the initial string representation of the tree. The i - th of the next n lines contains two integers l_ i and r_ i ( 0 \u2264 l_ i, r_ i \u2264 n ) . If the node i does not have the left child, l_ i = 0 , and if the node i does not have the right child, r_ i = 0 . It is guaranteed that the given input forms a binary tree, rooted at 1 .",
    "output": "Print a single line, containing the lexicographically smallest string representation of the tree if at most k nodes have their labels duplicated.",
    "note": "The images below present the tree for the examples. The number in each node is the node number, while the subscripted letter is its label. To the right is the string representation of the tree, with each letter having the same color as the corresponding node. Here is the tree for the first example. Here we duplicated the labels of nodes 1 and 3 . We should not duplicate the label of node 2 because it would give us the string \" bbaaab\" , which is lexicographically greater than \" baaaab\" . In the second example, we can duplicate the labels of nodes 1 and 2 . Note that only duplicating the label of the root will produce a worse result than the initial string. In the third example, we should not duplicate any character at all. Even though we would want to duplicate the label of the node 3 , by duplicating it we must also duplicate the label of the node 2 , which produces a worse result. There is no way to produce string \" darkkcyan\" from a tree with the initial string representation \" darkcyan\" : ( .",
    "topics": [
      "data structures",
      "dfs and similar",
      "greedy",
      "strings",
      "trees"
    ]
  },
  {
    "title": "Square String?",
    "url": "https://codeforces.com/problemset/problem/1619/A",
    "history": "A string is called square if it is some string written twice in a row. For example, the strings \" aa\" , \" abcabc\" , \" abab\" and \" baabaa\" are square. But the strings \" aaa\" , \" abaaab\" and \" abcdabc\" are not square. For a given string s determine if it is square.",
    "input": "The first line of input data contains an integer t ( 1 \u2264 t \u2264 100 ) \u2014the number of test cases. This is followed by t lines, each containing a description of one test case. The given strings consist only of lowercase Latin letters and have lengths between 1 and 100 inclusive.",
    "output": "For each test case, output on a separate line: YES if the string in the corresponding test case is square, NO otherwise. You can output YES and NO in any case ( for example, strings yEs, yes, Yes and YES will be recognized as a positive response) .",
    "note": "",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Reverse",
    "url": "https://codeforces.com/problemset/problem/1618/F",
    "history": "You are given two positive integers x and y . You can perform the following operation with x : write it in its binary form without leading zeros, add 0 or 1 to the right of it, reverse the binary form and turn it into a decimal number which is assigned as the new value of x . For example: 34 can be turned into 81 via one operation: the binary form of 34 is 100010 , if you add 1 , reverse it and remove leading zeros, you will get 1010001 , which is the binary form of 81 . 34 can be turned into 17 via one operation: the binary form of 34 is 100010 , if you add 0 , reverse it and remove leading zeros, you will get 10001 , which is the binary form of 17 . 81 can be turned into 69 via one operation: the binary form of 81 is 1010001 , if you add 0 , reverse it and remove leading zeros, you will get 1000101 , which is the binary form of 69 . 34 can be turned into 69 via two operations: first you turn 34 into 81 and then 81 into 69 . Your task is to find out whether x can be turned into y after a certain number of operations ( possibly zero) .",
    "input": "The only line of the input contains two integers x and y ( 1 \u2264 x, y \u2264 10^ 18 ) .",
    "output": "Print YES if you can make x equal to y and NO if you can' t.",
    "note": "In the first example, you don' t even need to do anything. The fourth example is described in the statement.",
    "topics": [
      "bitmasks",
      "constructive algorithms",
      "dfs and similar",
      "implementation",
      "math",
      "strings"
    ]
  },
  {
    "title": "Forbidden Subsequence",
    "url": "https://codeforces.com/problemset/problem/1617/A",
    "history": "You are given strings S and T , consisting of lowercase English letters. It is guaranteed that T is a permutation of the string abc. Find string S' , the lexicographically smallest permutation of S such that T is not a subsequence of S' . String a is a permutation of string b if the number of occurrences of each distinct character is the same in both strings. A string a is a subsequence of a string b if a can be obtained from b by deletion of several ( possibly, zero or all) elements. A string a is lexicographically smaller than a string b if and only if one of the following holds: a is a prefix of b , but a b ; in the first position where a and b differ, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b .",
    "input": "Each test contains multiple test cases. The first line contains a single integer t ( 1 \u2264 t \u2264 1000 ) \u2014 the number of test cases. Description of the test cases follows. The first line of each test case contains a string S ( 1 \u2264 | S| \u2264 100 ) , consisting of lowercase English letters. The second line of each test case contains a string T that is a permutation of the string abc. ( Hence, | T| = 3 ) . Note that there is no limit on the sum of | S| across all test cases.",
    "output": "For each test case, output a single string S' , the lexicographically smallest permutation of S such that T is not a subsequence of S' .",
    "note": "In the first test case, both aaaabbc and aaaabcb are lexicographically smaller than aaaacbb, but they contain abc as a subsequence. In the second test case, abccc is the smallest permutation of cccba and does not contain acb as a subsequence. In the third test case, bcdis is the smallest permutation of dbsic and does not contain bac as a subsequence.",
    "topics": [
      "constructive algorithms",
      "greedy",
      "sortings",
      "strings"
    ]
  },
  {
    "title": "Lexicographically Small Enough",
    "url": "https://codeforces.com/problemset/problem/1616/E",
    "history": "You are given two strings s and t of equal length n . In one move, you can swap any two adjacent characters of the string s . You need to find the minimal number of operations you need to make string s lexicographically smaller than string t . A string a is lexicographically smaller than a string b if and only if one of the following holds: a is a prefix of b , but a b ; in the first position where a and b differ, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b .",
    "input": "The first line of input contains one integer q ( 1 \u2264 q \u2264 10 000 ) : the number of test cases. The first line of each test case contains a single integer n ( 1 \u2264 n \u2264 10^ 5 ) . The second line of each test case contains the string s consisting of n lowercase English letters. The third line of each test case contains the string t consisting of n lowercase English letters. It is guaranteed that the sum of n over all test cases does not exceed 2 \u00b7 10^ 5 .",
    "output": "For each test case, print in a separate line the minimal number of operations you need to make string s lexicographically smaller than string t , or - 1 , if it' s impossible.",
    "note": "",
    "topics": [
      "brute force",
      "data structures",
      "greedy",
      "strings"
    ]
  },
  {
    "title": "Mirror in the String",
    "url": "https://codeforces.com/problemset/problem/1616/B",
    "history": "You have a string s_ 1 s_ 2 . . . s_ n and you stand on the left of the string looking right. You want to choose an index k ( 1 \u2264 k \u2264 n ) and place a mirror after the k - th letter, so that what you see is s_ 1 s_ 2 . . . s_ k s_ k s_ k - 1. . . s_ 1 . What is the lexicographically smallest string you can see? A string a is lexicographically smaller than a string b if and only if one of the following holds: a is a prefix of b , but a b ; in the first position where a and b differ, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b .",
    "input": "The first line of input contains one integer t ( 1 \u2264 t \u2264 10 000 ) : the number of test cases. The next t lines contain the description of the test cases, two lines per a test case. In the first line you are given one integer n ( 1 \u2264 n \u2264 10^ 5 ) : the length of the string. The second line contains the string s consisting of n lowercase English characters. It is guaranteed that the sum of n over all test cases does not exceed 10^ 5 .",
    "output": "For each test case print the lexicographically smallest string you can see.",
    "note": "In the first test case choose k = 1 to obtain \" cc\" . In the second test case choose k = 3 to obtain \" cbaabc\" . In the third test case choose k = 1 to obtain \" aa\" . In the fourth test case choose k = 1 to obtain \" bb\" .",
    "topics": [
      "greedy",
      "strings"
    ]
  },
  {
    "title": "William the Vigilant",
    "url": "https://codeforces.com/problemset/problem/1609/B",
    "history": "Before becoming a successful trader William got a university degree. During his education an interesting situation happened, after which William started to listen to homework assignments much more attentively. What follows is the correct formal description of the homework assignment: You are given a string s of length n only consisting of characters \" a\" , \" b\" and \" c\" . There are q queries of format ( pos, c ) , meaning replacing the element of string s at position pos with character c . After each query you must output the minimal number of characters in the string, which have to be replaced, so that the string doesn' t contain string \" abc\" as a substring. A valid replacement of a character is replacing it with \" a\" , \" b\" or \" c\" . A string x is a substring of a string y if x can be obtained from y by deletion of several ( possibly, zero or all) characters from the beginning and several ( possibly, zero or all) characters from the end.",
    "input": "The first line contains two integers n and q ( 1 \u2264 n, q \u2264 10^ 5) , the length of the string and the number of queries, respectively. The second line contains the string s , consisting of characters \" a\" , \" b\" and \" c\" . Each of the next q lines contains an integer i and character c ( 1 \u2264 i \u2264 n) , index and the value of the new item in the string, respectively. It is guaranteed that character' s c value is \" a\" , \" b\" or \" c\" .",
    "output": "For each query output the minimal number of characters that would have to be replaced so that the string doesn' t contain \" abc\" as a substring.",
    "note": "Let' s consider the state of the string after each query: s = \" abcabcabc\" . In this case 3 replacements can be performed to get, for instance, string s = \" bbcaccabb\" . This string does not contain \" abc\" as a substring. s = \" bbcabcabc\" . In this case 2 replacements can be performed to get, for instance, string s = \" bbcbbcbbc\" . This string does not contain \" abc\" as a substring. s = \" bccabcabc\" . In this case 2 replacements can be performed to get, for instance, string s = \" bccbbcbbc\" . This string does not contain \" abc\" as a substring. s = \" bcaabcabc\" . In this case 2 replacements can be performed to get, for instance, string s = \" bcabbcbbc\" . This string does not contain \" abc\" as a substring. s = \" bcabbcabc\" . In this case 1 replacements can be performed to get, for instance, string s = \" bcabbcabb\" . This string does not contain \" abc\" as a substring. s = \" bcabccabc\" . In this case 2 replacements can be performed to get, for instance, string s = \" bcabbcabb\" . This string does not contain \" abc\" as a substring. s = \" bcabccaac\" . In this case 1 replacements can be performed to get, for instance, string s = \" bcabbcaac\" . This string does not contain \" abc\" as a substring. s = \" bcabccaab\" . In this case 1 replacements can be performed to get, for instance, string s = \" bcabbcaab\" . This string does not contain \" abc\" as a substring. s = \" ccabccaab\" . In this case 1 replacements can be performed to get, for instance, string s = \" ccabbcaab\" . This string does not contain \" abc\" as a substring. s = \" ccaaccaab\" . In this case the string does not contain \" abc\" as a substring and no replacements are needed.",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Alphabetic Tree",
    "url": "https://codeforces.com/problemset/problem/1608/G",
    "history": "You are given m strings and a tree on n nodes. Each edge has some letter written on it. You have to answer q queries. Each query is described by 4 integers u , v , l and r . The answer to the query is the total number of occurrences of str( u, v) in strings with indices from l to r . str( u, v) is defined as the string that is made by concatenating letters written on the edges on the shortest path from u to v ( in order that they are traversed) .",
    "input": "The first line of the input contains three integers n , m and q ( 2 \u2264 n \u2264 10^ 5 , 1 \u2264 m, q \u2264 10^ 5 ) . The i - th of the following n- 1 lines contains two integers u_ i, v_ i and a lowercase Latin letter c_ i ( 1 \u2264 u_ i, v_ i \u2264 n , u_ i = \u0338 v_ i ) , denoting the edge between nodes u_ i, v_ i with a character c_ i on it. It' s guaranteed that these edges form a tree. The following m lines contain the strings consisting of lowercase Latin letters. The total length of those strings does not exceed 10^ 5 . Then q lines follow, each containing four integers u , v , l and r ( 1 \u2264 u, v \u2264 n , u = \u0338 v , 1 \u2264 l \u2264 r \u2264 m ) , denoting the queries.",
    "output": "For each query print a single integer \u2014 the answer to the query.",
    "note": "",
    "topics": [
      "binary search",
      "data structures",
      "dfs and similar",
      "hashing",
      "string suffix structures",
      "strings",
      "trees"
    ]
  },
  {
    "title": "Linear Keyboard",
    "url": "https://codeforces.com/problemset/problem/1607/A",
    "history": "You are given a keyboard that consists of 26 keys. The keys are arranged sequentially in one row in a certain order. Each key corresponds to a unique lowercase Latin letter. You have to type the word s on this keyboard. It also consists only of lowercase Latin letters. To type a word, you need to type all its letters consecutively one by one. To type each letter you must position your hand exactly over the corresponding key and press it. Moving the hand between the keys takes time which is equal to the absolute value of the difference between positions of these keys ( the keys are numbered from left to right) . No time is spent on pressing the keys and on placing your hand over the first letter of the word. For example, consider a keyboard where the letters from ' a' to ' z' are arranged in consecutive alphabetical order. The letters ' h' , ' e' , ' l' and ' o' then are on the positions 8 , 5 , 12 and 15 , respectively. Therefore, it will take | 5 - 8| + | 12 - 5| + | 12 - 12| + | 15 - 12| = 13 units of time to type the word \" hello\" . Determine how long it will take to print the word s .",
    "input": "The first line contains an integer t ( 1 \u2264 t \u2264 1000 ) \u2014 the number of test cases. The next 2t lines contain descriptions of the test cases. The first line of a description contains a keyboard \u2014 a string of length 26 , which consists only of lowercase Latin letters. Each of the letters from ' a' to ' z' appears exactly once on the keyboard. The second line of the description contains the word s . The word has a length from 1 to 50 letters inclusive and consists of lowercase Latin letters.",
    "output": "Print t lines, each line containing the answer to the corresponding test case. The answer to the test case is the minimal time it takes to type the word s on the given keyboard.",
    "note": "",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "AB Balance",
    "url": "https://codeforces.com/problemset/problem/1606/A",
    "history": "You are given a string s of length n consisting of characters a and/ or b. Let AB( s) be the number of occurrences of string ab in s as a substring. Analogically, BA( s) is the number of occurrences of ba in s as a substring. In one step, you can choose any index i and replace s_ i with character a or b. What is the minimum number of steps you need to make to achieve AB( s) = BA( s) ? Reminder: The number of occurrences of string d in s as substring is the number of indices i ( 1 \u2264 i \u2264 | s| - | d| + 1 ) such that substring s_ i s_ i + 1. . . s_ i + | d| - 1 is equal to d . For example, AB( aabbbabaa ) = 2 since there are two indices i : i = 2 where aabbbabaa and i = 6 where aabbbabaa.",
    "input": "Each test contains multiple test cases. The first line contains the number of test cases t ( 1 \u2264 t \u2264 1000 ) . Description of the test cases follows. The first and only line of each test case contains a single string s ( 1 \u2264 | s| \u2264 100 , where | s| is the length of the string s ) , consisting only of characters a and/ or b.",
    "output": "For each test case, print the resulting string s with AB( s) = BA( s) you' ll get making the minimum number of steps. If there are multiple answers, print any of them.",
    "note": "In the first test case, both AB( s) = 0 and BA( s) = 0 ( there are no occurrences of ab ( ba) in b) , so can leave s untouched. In the second test case, AB( s) = 2 and BA( s) = 2 , so you can leave s untouched. In the third test case, AB( s) = 1 and BA( s) = 0 . For example, we can change s_ 1 to b and make both values zero. In the fourth test case, AB( s) = 2 and BA( s) = 1 . For example, we can change s_ 6 to a and make both values equal to 1 .",
    "topics": [
      "strings"
    ]
  },
  {
    "title": "Dominant Character",
    "url": "https://codeforces.com/problemset/problem/1605/C",
    "history": "Ashish has a string s of length n containing only characters ' a' , ' b' and ' c' . He wants to find the length of the smallest substring, which satisfies the following conditions: Length of the substring is at least 2 ' a' occurs strictly more times in this substring than ' b' ' a' occurs strictly more times in this substring than ' c' Ashish is busy planning his next Codeforces round. Help him solve the problem. A string a is a substring of a string b if a can be obtained from b by deletion of several ( possibly, zero or all) characters from the beginning and several ( possibly, zero or all) characters from the end.",
    "input": "The first line contains a single integer t ( 1 \u2264 t \u2264 10^ 5) \u2014 the number of test cases. The description of test cases follows. The first line of each test case contains a single integer n ( 2 \u2264 n \u2264 10^ 6) \u2014 the length of the string s . The second line of each test case contains a string s consisting only of characters ' a' , ' b' and ' c' . It is guaranteed that the sum of n over all test cases does not exceed 10^ 6 .",
    "output": "For each test case, output the length of the smallest substring which satisfies the given conditions or print - 1 if there is no such substring.",
    "note": "Consider the first test case. In the substring \" aa\" , ' a' occurs twice, while ' b' and ' c' occur zero times. Since ' a' occurs strictly more times than ' b' and ' c' , the substring \" aa\" satisfies the condition and the answer is 2 . The substring \" a\" also satisfies this condition, however its length is not at least 2 . In the second test case, it can be shown that in none of the substrings of \" cbabb\" does ' a' occur strictly more times than ' b' and ' c' each. In the third test case, \" cacabccc\" , the length of the smallest substring that satisfies the conditions is 3 .",
    "topics": [
      "brute force",
      "greedy",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "The Sum of Good Numbers",
    "url": "https://codeforces.com/problemset/problem/1598/G",
    "history": "Let' s call a positive integer good if there is no digit 0 in its decimal representation. For an array of a good numbers a , one found out that the sum of some two neighboring elements is equal to x ( i. e. x = a_ i + a_ i + 1 for some i ) . x had turned out to be a good number as well. Then the elements of the array a were written out one after another without separators into one string s . For example, if a = [ 12, 5, 6, 133] , then s = 1256133 . You are given a string s and a number x . Your task is to determine the positions in the string that correspond to the adjacent elements of the array that have sum x . If there are several possible answers, you can print any of them.",
    "input": "The first line contains the string s ( 2 \u2264 | s| \u2264 5 \u00b7 10^ 5 ) . The second line contains an integer x ( 2 \u2264 x < 10^ 200000 ) . An additional constraint on the input: the answer always exists, i. e you can always select two adjacent substrings of the string s so that if you convert these substrings to integers, their sum is equal to x .",
    "output": "In the first line, print two integers l_ 1 , r_ 1 , meaning that the first term of the sum ( a_ i ) is in the string s from position l_ 1 to position r_ 1 . In the second line, print two integers l_ 2 , r_ 2 , meaning that the second term of the sum ( a_ i + 1 ) is in the string s from position l_ 2 to position r_ 2 .",
    "note": "In the first example s[ 1; 2] = 12 and s[ 3; 3] = 5 , 12+ 5= 17 . In the second example s[ 2; 3] = 54 and s[ 4; 6] = 471 , 54+ 471= 525 . In the third example s[ 1; 1] = 2 and s[ 2; 2] = 3 , 2+ 3= 5 . In the fourth example s[ 2; 7] = 218633 and s[ 8; 13] = 757639 , 218633+ 757639= 976272 .",
    "topics": [
      "hashing",
      "math",
      "string suffix structures",
      "strings"
    ]
  },
  {
    "title": "Make Them Equal",
    "url": "https://codeforces.com/problemset/problem/1594/C",
    "history": "Theofanis has a string s_ 1 s_ 2 . . . s_ n and a character c . He wants to make all characters of the string equal to c using the minimum number of operations. In one operation he can choose a number x ( 1 \u2264 x \u2264 n ) and for every position i , where i is not divisible by x , replace s_ i with c . Find the minimum number of operations required to make all the characters equal to c and the x - s that he should use in his operations.",
    "input": "The first line contains a single integer t ( 1 \u2264 t \u2264 10^ 4 ) \u2014 the number of test cases. The first line of each test case contains the integer n ( 3 \u2264 n \u2264 3 \u00b7 10^ 5 ) and a lowercase Latin letter c \u2014 the length of the string s and the character the resulting string should consist of. The second line of each test case contains a string s of lowercase Latin letters \u2014 the initial string. It is guaranteed that the sum of n over all test cases does not exceed 3 \u00b7 10^ 5 .",
    "output": "For each test case, firstly print one integer m \u2014 the minimum number of operations required to make all the characters equal to c . Next, print m integers x_ 1, x_ 2, . . . , x_ m ( 1 \u2264 x_ j \u2264 n ) \u2014 the x - s that should be used in the order they are given. It can be proved that under given constraints, an answer always exists. If there are multiple answers, print any.",
    "note": "Let' s describe what happens in the third test case: x_ 1 = 2 : we choose all positions that are not divisible by 2 and replace them, i. e. bzyx \u2192 bzbx; x_ 2 = 3 : we choose all positions that are not divisible by 3 and replace them, i. e. bzbx \u2192 bbbb.",
    "topics": [
      "brute force",
      "greedy",
      "math",
      "strings"
    ]
  },
  {
    "title": "Strange LCS",
    "url": "https://codeforces.com/problemset/problem/1584/F",
    "history": "You are given n strings s_ 1, s_ 2, . . . , s_ n , each consisting of lowercase and uppercase English letters. In addition, it' s guaranteed that each character occurs in each string at most twice. Find the longest common subsequence of these strings. A string t is a subsequence of a string s if t can be obtained from s by deletion of several ( possibly, zero or all) symbols.",
    "input": "Each test consists of multiple test cases. The first line contains a single integer t ( 1 \u2264 t \u2264 5 ) \u2014 the number of test cases. Description of the test cases follows. The first line of each test case contains a single integer n ( 2 \u2264 n \u2264 10 ) \u2014 the number of strings. Each of the next n lines contains the corresponding string s_ i . Each s_ i is non- empty, consists only of uppercase and lowercase English letters, and no character appears more than twice in each string.",
    "output": "For each test case print the answer in two lines: In the first line print the length of the longest common subsequence. In the second line print the longest common subsequence. If there are multiple such subsequences, print any of them.",
    "note": "In the first test case, the longest common subsequence is \" A\" . There are no common subsequences of length 2 . In the second test case, sets of characters of strings don' t intersect, so any non- empty string can' t be a common subsequence.",
    "topics": [
      "bitmasks",
      "dp",
      "graphs",
      "greedy",
      "strings"
    ]
  },
  {
    "title": "Grandma Capa Knits a Scarf",
    "url": "https://codeforces.com/problemset/problem/1582/C",
    "history": "Grandma Capa has decided to knit a scarf and asked Grandpa Sher to make a pattern for it, a pattern is a string consisting of lowercase English letters. Grandpa Sher wrote a string s of length n . Grandma Capa wants to knit a beautiful scarf, and in her opinion, a beautiful scarf can only be knit from a string that is a palindrome. She wants to change the pattern written by Grandpa Sher, but to avoid offending him, she will choose one lowercase English letter and erase some ( at her choice, possibly none or all) occurrences of that letter in string s . She also wants to minimize the number of erased symbols from the pattern. Please help her and find the minimum number of symbols she can erase to make string s a palindrome, or tell her that it' s impossible. Notice that she can only erase symbols equal to the one letter she chose. A string is a palindrome if it is the same from the left to the right and from the right to the left. For example, the strings ' kek' , ' abacaba' , ' r' and ' papicipap' are palindromes, while the strings ' abb' and ' iq' are not.",
    "input": "The first line contains a single integer t ( 1 \u2264 t \u2264 100 ) \u2014 the number of test cases. The next 2 \u00b7 t lines contain the description of test cases. The description of each test case consists of two lines. The first line of each test case contains a single integer n ( 1 \u2264 n \u2264 10^ 5 ) \u2014 the length of the string. The second line of each test case contains the string s consisting of n lowercase English letters. It is guaranteed that the sum of n over all test cases does not exceed 2 \u00b7 10^ 5 .",
    "output": "For each test case print the minimum number of erased symbols required to make the string a palindrome, if it is possible, and - 1 , if it is impossible.",
    "note": "In the first test case, you can choose a letter ' a' and erase its first and last occurrences, you will get a string ' bcaacb' , which is a palindrome. You can also choose a letter ' b' and erase all its occurrences, you will get a string ' acaaca' , which is a palindrome as well. In the second test case, it can be shown that it is impossible to choose a letter and erase some of its occurrences to get a palindrome. In the third test case, you don' t have to erase any symbols because the string is already a palindrome.",
    "topics": [
      "brute force",
      "data structures",
      "greedy",
      "strings",
      "two pointers"
    ]
  },
  {
    "title": "Casimir's String Solitaire",
    "url": "https://codeforces.com/problemset/problem/1579/A",
    "history": "Casimir has a string s which consists of capital Latin letters ' A' , ' B' , and ' C' only. Each turn he can choose to do one of the two following actions: he can either erase exactly one letter ' A' and exactly one letter ' B' from arbitrary places of the string ( these letters don' t have to be adjacent) ; or he can erase exactly one letter ' B' and exactly one letter ' C' from arbitrary places in the string ( these letters don' t have to be adjacent) . Therefore, each turn the length of the string is decreased exactly by 2 . All turns are independent so for each turn, Casimir can choose any of two possible actions. For example, with s = \" ABCABC\" he can obtain a string s = \" ACBC\" in one turn ( by erasing the first occurrence of ' B' and the second occurrence of ' A' ) . There are also many other options for a turn aside from this particular example. For a given string s determine whether there is a sequence of actions leading to an empty string. In other words, Casimir' s goal is to erase all letters from the string. Is there a way to do this?",
    "input": "The first line contains an integer t ( 1 \u2264 t \u2264 1000 ) \u2014 the number of test cases. Each test case is described by one string s , for which you need to determine if it can be fully erased by some sequence of turns. The string s consists of capital letters ' A' , ' B' , ' C' and has a length from 1 to 50 letters, inclusive.",
    "output": "Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if there is a way to fully erase the corresponding string and NO otherwise. You may print every letter in any case you want ( so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers) .",
    "note": "",
    "topics": [
      "math",
      "strings"
    ]
  },
  {
    "title": "Higher Order Functions",
    "url": "https://codeforces.com/problemset/problem/1578/H",
    "history": "Helen studies functional programming and she is fascinated with a concept of higher order functions \u2014 functions that are taking other functions as parameters. She decides to generalize the concept of the function order and to test it on some examples. For her study, she defines a simple grammar of types. In her grammar, a type non- terminal T is defined as one of the following grammar productions, together with order( T) , defining an order of the corresponding type: \" ( ) \" is a unit type, order( \" \" ) = 0 . \" ( \" T \" ) \" is a parenthesized type, order( \" \" T \" \" ) = order( T) . T_ 1 \" - > \" T_ 2 is a functional type, order( T_ 1 \" \" T_ 2) = max( order( T_ 1) + 1, order( T_ 2) ) . The function constructor T_ 1 \" - > \" T_ 2 is right- to- left associative, so the type \" ( ) - > ( ) - > ( ) \" is the same as the type \" ( ) - > ( ( ) - > ( ) ) \" of a function returning a function, and it has an order of 1 . While \" ( ( ) - > ( ) ) - > ( ) \" is a function that has an order- 1 type \" ( ( ) - > ( ) ) \" as a parameter, and it has an order of 2 . Helen asks for your help in writing a program that computes an order of the given type.",
    "input": "The single line of the input contains a string consisting of characters ' ( ' , ' ) ' , ' - ' , and ' > ' that describes a type that is valid according to the grammar from the problem statement. The length of the line is at most 10^ 4 characters.",
    "output": "Print a single integer \u2014 the order of the given type.",
    "note": "",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Holiday Wall Ornaments",
    "url": "https://codeforces.com/problemset/problem/1575/H",
    "history": "The Winter holiday will be here soon. Mr. Chanek wants to decorate his house' s wall with ornaments. The wall can be represented as a binary string a of length n . His favorite nephew has another binary string b of length m ( m \u2264 n ) . Mr. Chanek' s nephew loves the non- negative integer k . His nephew wants exactly k occurrences of b as substrings in a . However, Mr. Chanek does not know the value of k . So, for each k ( 0 \u2264 k \u2264 n - m + 1 ) , find the minimum number of elements in a that have to be changed such that there are exactly k occurrences of b in a . A string s occurs exactly k times in t if there are exactly k different pairs ( p, q) such that we can obtain s by deleting p characters from the beginning and q characters from the end of t .",
    "input": "The first line contains two integers n and m ( 1 \u2264 m \u2264 n \u2264 500 ) \u2014 size of the binary string a and b respectively. The second line contains a binary string a of length n . The third line contains a binary string b of length m .",
    "output": "Output n - m + 2 integers \u2014 the ( k+ 1) - th integer denotes the minimal number of elements in a that have to be changed so there are exactly k occurrences of b as a substring in a .",
    "note": "For k = 0 , to make the string a have no occurrence of 101, you can do one character change as follows. 100101011 \u2192 100100011For k = 1 , you can also change a single character. 100101011 \u2192 100001011For k = 2 , no changes are needed.",
    "topics": [
      "dp",
      "strings"
    ]
  },
  {
    "title": "Another Sorting Problem",
    "url": "https://codeforces.com/problemset/problem/1575/A",
    "history": "Andi and Budi were given an assignment to tidy up their bookshelf of n books. Each book is represented by the book title \u2014 a string s_ i numbered from 1 to n , each with length m . Andi really wants to sort the book lexicographically ascending, while Budi wants to sort it lexicographically descending. Settling their fight, they decided to combine their idea and sort it asc- desc- endingly, where the odd- indexed characters will be compared ascendingly, and the even- indexed characters will be compared descendingly. A string a occurs before a string b in asc- desc- ending order if and only if in the first position where a and b differ, the following holds: if it is an odd position, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b ; if it is an even position, the string a has a letter that appears later in the alphabet than the corresponding letter in b .",
    "input": "The first line contains two integers n and m ( 1 \u2264 n \u00b7 m \u2264 10^ 6 ) . The i - th of the next n lines contains a string s_ i consisting of m uppercase Latin letters \u2014 the book title. The strings are pairwise distinct.",
    "output": "Output n integers \u2014 the indices of the strings after they are sorted asc- desc- endingly.",
    "note": "The following illustrates the first example.",
    "topics": [
      "data structures",
      "sortings",
      "strings"
    ]
  },
  {
    "title": "Domino Disaster",
    "url": "https://codeforces.com/problemset/problem/1567/A",
    "history": "Alice has a grid with 2 rows and n columns. She fully covers the grid using n dominoes of size 1 \u00d7 2 \u2014 Alice may place them vertically or horizontally, and each cell should be covered by exactly one domino. Now, she decided to show one row of the grid to Bob. Help Bob and figure out what the other row of the grid looks like!",
    "input": "The input consists of multiple test cases. The first line contains an integer t ( 1 \u2264 t \u2264 5000 ) \u2014 the number of test cases. The description of the test cases follows. The first line of each test case contains an integer n ( 1 \u2264 n \u2264 100 ) \u2014 the width of the grid. The second line of each test case contains a string s consisting of n characters, each of which is either L, R, U, or D, representing the left, right, top, or bottom half of a domino, respectively ( see notes for better understanding) . This string represents one of the rows of the grid. Additional constraint on the input: each input corresponds to at least one valid tiling.",
    "output": "For each test case, output one string \u2014 the other row of the grid, using the same format as the input string. If there are multiple answers, print any.",
    "note": "In the first test case, Alice shows Bob the top row, the whole grid may look like: In the second test case, Alice shows Bob the bottom row, the whole grid may look like: In the third test case, Alice shows Bob the bottom row, the whole grid may look like: In the fourth test case, Alice shows Bob the top row, the whole grid may look like:",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Rescue Niwen!",
    "url": "https://codeforces.com/problemset/problem/1562/E",
    "history": "Morning desert sun horizonRise above the sands of time. . . Fates Warning, \" Exodus\" After crossing the Windswept Wastes, Ori has finally reached the Windtorn Ruins to find the Heart of the Forest! However, the ancient repository containing this priceless Willow light did not want to open! Ori was taken aback, but the Voice of the Forest explained to him that the cunning Gorleks had decided to add protection to the repository. The Gorleks were very fond of the \" string expansion\" operation. They were also very fond of increasing subsequences. Suppose a string s_ 1s_ 2s_ 3 . . . s_ n is given. Then its \" expansion\" is defined as the sequence of strings s_ 1 , s_ 1 s_ 2 , . . . , s_ 1 s_ 2 . . . s_ n , s_ 2 , s_ 2 s_ 3 , . . . , s_ 2 s_ 3 . . . s_ n , s_ 3 , s_ 3 s_ 4 , . . . , s_ n- 1 s_ n , s_ n . For example, the \" expansion\" the string ' abcd' will be the following sequence of strings: ' a' , ' ab' , ' abc' , ' abcd' , ' b' , ' bc' , ' bcd' , ' c' , ' cd' , ' d' . To open the ancient repository, Ori must find the size of the largest increasing subsequence of the \" expansion\" of the string s . Here, strings are compared lexicographically. Help Ori with this task! A string a is lexicographically smaller than a string b if and only if one of the following holds: a is a prefix of b , but a b ; in the first position where a and b differ, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b .",
    "input": "Each test contains multiple test cases. The first line contains one positive integer t ( 1 \u2264 t \u2264 10^ 3 ) , denoting the number of test cases. Description of the test cases follows. The first line of each test case contains one positive integer n ( 1 \u2264 n \u2264 5000 ) \u2014 length of the string. The second line of each test case contains a non- empty string of length n , which consists of lowercase latin letters. It is guaranteed that the sum of n over all test cases does not exceed 10^ 4 .",
    "output": "For every test case print one non- negative integer \u2014 the answer to the problem.",
    "note": "In first test case the \" expansion\" of the string is: ' a' , ' ac' , ' acb' , ' acba' , ' acbac' , ' c' , ' cb' , ' cba' , ' cbac' , ' b' , ' ba' , ' bac' , ' a' , ' ac' , ' c' . The answer can be, for example, ' a' , ' ac' , ' acb' , ' acba' , ' acbac' , ' b' , ' ba' , ' bac' , ' c' .",
    "topics": [
      "dp",
      "greedy",
      "string suffix structures",
      "strings"
    ]
  },
  {
    "title": "Polycarp and String Transformation",
    "url": "https://codeforces.com/problemset/problem/1560/E",
    "history": "Polycarp has a string s . Polycarp performs the following actions until the string s is empty ( t is initially an empty string) : he adds to the right to the string t the string s , i. e. he does t = t + s , where t + s is a concatenation of the strings t and s ; he selects an arbitrary letter of s and removes from s all its occurrences ( the selected letter must occur in the string s at the moment of performing this action) . Polycarp performs this sequence of actions strictly in this order. Note that after Polycarp finishes the actions, the string s will be empty and the string t will be equal to some value ( that is undefined and depends on the order of removing) . E. g. consider s = \" abacaba\" so the actions may be performed as follows: t = \" abacaba\" , the letter ' b' is selected, then s = \" aacaa\" ; t = \" abacabaaacaa\" , the letter ' a' is selected, then s = \" c\" ; t = \" abacabaaacaac\" , the letter ' c' is selected, then s = \" \" ( the empty string) . You need to restore the initial value of the string s using only the final value of t and find the order of removing letters from s .",
    "input": "The first line contains one integer T ( 1 \u2264 T \u2264 10^ 4 ) \u2014 the number of test cases. Then T test cases follow. Each test case contains one string t consisting of lowercase letters of the Latin alphabet. The length of t doesn' t exceed 5 \u00b7 10^ 5 . The sum of lengths of all strings t in the test cases doesn' t exceed 5 \u00b7 10^ 5 .",
    "output": "For each test case output in a separate line: - 1 , if the answer doesn' t exist; two strings separated by spaces. The first one must contain a possible initial value of s . The second one must contain a sequence of letters \u2014 it' s in what order one needs to remove letters from s to make the string t . E. g. if the string \" bac\" is outputted, then, first, all occurrences of the letter ' b' were deleted, then all occurrences of ' a' , and then, finally, all occurrences of ' c' . If there are multiple solutions, print any one.",
    "note": "The first test case is considered in the statement.",
    "topics": [
      "binary search",
      "implementation",
      "sortings",
      "strings"
    ]
  },
  {
    "title": "Make a Power of Two",
    "url": "https://codeforces.com/problemset/problem/1560/D",
    "history": "You are given an integer n . In 1 move, you can do one of the following actions: erase any digit of the number ( it' s acceptable that the number before the operation has exactly one digit and after the operation, it is \" empty\" ) ; add one digit to the right. The actions may be performed in any order any number of times. Note that if, after deleting some digit from a number, it will contain leading zeroes, they will not be deleted. E. g. if you delete from the number 301 the digit 3 , the result is the number 01 ( not 1 ) . You need to perform the minimum number of actions to make the number any power of 2 ( i. e. there' s an integer k ( k \u2265 0 ) such that the resulting number is equal to 2^ k ) . The resulting number must not have leading zeroes. E. g. consider n= 1052 . The answer is equal to 2 . First, let' s add to the right one digit 4 ( the result will be 10524 ) . Then let' s erase the digit 5 , so the result will be 1024 which is a power of 2 . E. g. consider n= 8888 . The answer is equal to 3 . Let' s erase any of the digits 8 three times. The result will be 8 which is a power of 2 .",
    "input": "The first line contains one integer t ( 1 \u2264 t \u2264 10^ 4 ) \u2014 the number of test cases. Then t test cases follow. Each test case consists of one line containing one integer n ( 1 \u2264 n \u2264 10^ 9 ) .",
    "output": "For each test case, output in a separate line one integer m \u2014 the minimum number of moves to transform the number into any power of 2 .",
    "note": "The answer for the first test case was considered above. The answer for the second test case was considered above. In the third test case, it' s enough to add to the right the digit 4 \u2014 the number 6 will turn into 64 . In the fourth test case, let' s add to the right the digit 8 and then erase 7 and 5 \u2014 the taken number will turn into 8 . The numbers of the fifth and the sixth test cases are already powers of two so there' s no need to make any move. In the seventh test case, you can delete first of all the digit 3 ( the result is 01 ) and then the digit 0 ( the result is 1 ) .",
    "topics": [
      "greedy",
      "math",
      "strings"
    ]
  },
  {
    "title": "Say No to Palindromes",
    "url": "https://codeforces.com/problemset/problem/1555/D",
    "history": "Let' s call the string beautiful if it does not contain a substring of length at least 2 , which is a palindrome. Recall that a palindrome is a string that reads the same way from the first character to the last and from the last character to the first. For example, the strings a, bab, acca, bcabcbacb are palindromes, but the strings ab, abbbaa, cccb are not. Let' s define cost of a string as the minimum number of operations so that the string becomes beautiful, if in one operation it is allowed to change any character of the string to one of the first 3 letters of the Latin alphabet ( in lowercase) . You are given a string s of length n , each character of the string is one of the first 3 letters of the Latin alphabet ( in lowercase) . You have to answer m queries \u2014 calculate the cost of the substring of the string s from l_ i - th to r_ i - th position, inclusive.",
    "input": "The first line contains two integers n and m ( 1 \u2264 n, m \u2264 2 \u00b7 10^ 5 ) \u2014 the length of the string s and the number of queries. The second line contains the string s , it consists of n characters, each character one of the first 3 Latin letters. The following m lines contain two integers l_ i and r_ i ( 1 \u2264 l_ i \u2264 r_ i \u2264 n ) \u2014 parameters of the i - th query.",
    "output": "For each query, print a single integer \u2014 the cost of the substring of the string s from l_ i - th to r_ i - th position, inclusive.",
    "note": "Consider the queries of the example test. in the first query, the substring is baa, which can be changed to bac in one operation; in the second query, the substring is baacb, which can be changed to cbacb in two operations; in the third query, the substring is cb, which can be left unchanged; in the fourth query, the substring is aa, which can be changed to ba in one operation.",
    "topics": [
      "brute force",
      "constructive algorithms",
      "dp",
      "strings"
    ]
  },
  {
    "title": "Diane",
    "url": "https://codeforces.com/problemset/problem/1554/D",
    "history": "You are given an integer n . Find any string s of length n consisting only of English lowercase letters such that each non- empty substring of s occurs in s an odd number of times. If there are multiple such strings, output any. It can be shown that such string always exists under the given constraints. A string a is a substring of a string b if a can be obtained from b by deletion of several ( possibly, zero or all) characters from the beginning and several ( possibly, zero or all) characters from the end.",
    "input": "The first line contains a single integer t ( 1 \u2264 t \u2264 500 ) \u2014 the number of test cases. The first line of each test case contains a single integer n ( 1 \u2264 n \u2264 10^ 5 ) . It is guaranteed that the sum of n over all test cases doesn' t exceed 3 \u00b7 10^ 5 .",
    "output": "For each test case, print a single line containing the string s . If there are multiple such strings, output any. It can be shown that such string always exists under the given constraints.",
    "note": "In the first test case, each substring of \" abc\" occurs exactly once. In the third test case, each substring of \" bbcaabbba\" occurs an odd number of times. In particular, \" b\" occurs 5 times, \" a\" and \" bb\" occur 3 times each, and each of the remaining substrings occurs exactly once.",
    "topics": [
      "constructive algorithms",
      "greedy",
      "strings"
    ]
  },
  {
    "title": "Backspace",
    "url": "https://codeforces.com/problemset/problem/1553/D",
    "history": "You are given two strings s and t , both consisting of lowercase English letters. You are going to type the string s character by character, from the first character to the last one. When typing a character, instead of pressing the button corresponding to it, you can press the \" Backspace\" button. It deletes the last character you have typed among those that aren' t deleted yet ( or does nothing if there are no characters in the current string) . For example, if s is \" abcbd\" and you press Backspace instead of typing the first and the fourth characters, you will get the string \" bd\" ( the first press of Backspace deletes no character, and the second press deletes the character ' c' ) . Another example, if s is \" abcaa\" and you press Backspace instead of the last two letters, then the resulting text is \" a\" . Your task is to determine whether you can obtain the string t , if you type the string s and press \" Backspace\" instead of typing several ( maybe zero) characters of s .",
    "input": "The first line contains a single integer q ( 1 \u2264 q \u2264 10^ 5 ) \u2014 the number of test cases. The first line of each test case contains the string s ( 1 \u2264 | s| \u2264 10^ 5 ) . Each character of s is a lowercase English letter. The second line of each test case contains the string t ( 1 \u2264 | t| \u2264 10^ 5 ) . Each character of t is a lowercase English letter. It is guaranteed that the total number of characters in the strings over all test cases does not exceed 2 \u00b7 10^ 5 .",
    "output": "For each test case, print \" YES\" if you can obtain the string t by typing the string s and replacing some characters with presses of \" Backspace\" button, or \" NO\" if you cannot. You may print each letter in any case ( YES, yes, Yes will all be recognized as positive answer, NO, no and nO will all be recognized as negative answer) .",
    "note": "Consider the example test from the statement. In order to obtain \" ba\" from \" ababa\" , you may press Backspace instead of typing the first and the fourth characters. There' s no way to obtain \" bb\" while typing \" ababa\" . There' s no way to obtain \" aaaa\" while typing \" aaa\" . In order to obtain \" ababa\" while typing \" aababa\" , you have to press Backspace instead of typing the first character, then type all the remaining characters.",
    "topics": [
      "dp",
      "greedy",
      "strings",
      "two pointers"
    ]
  },
  {
    "title": "Reverse String",
    "url": "https://codeforces.com/problemset/problem/1553/B",
    "history": "You have a string s and a chip, which you can place onto any character of this string. After placing the chip, you move it to the right several ( maybe zero) times, i. e. you perform the following operation several times: if the current position of the chip is i , you move it to the position i + 1 . Of course, moving the chip to the right is impossible if it is already in the last position. After moving the chip to the right, you move it to the left several ( maybe zero) times, i. e. you perform the following operation several times: if the current position of the chip is i , you move it to the position i - 1 . Of course, moving the chip to the left is impossible if it is already in the first position. When you place a chip or move it, you write down the character where the chip ends up after your action. For example, if s is abcdef, you place the chip onto the 3 - rd character, move it to the right 2 times and then move it to the left 3 times, you write down the string cdedcb. You are given two strings s and t . Your task is to determine whether it' s possible to perform the described operations with s so that you write down the string t as a result.",
    "input": "The first line contains one integer q ( 1 \u2264 q \u2264 500 ) \u2014 the number of test cases. Each test case consists of two lines. The first line contains the string s ( 1 \u2264 | s| \u2264 500 ) , the second line contains the string t ( 1 \u2264 | t| \u2264 2 \u00b7 | s| - 1 ) . Both strings consist of lowercase English characters. It is guaranteed that the sum of | s| over all test cases does not exceed 500 .",
    "output": "For each test case, print \" YES\" if you can obtain the string t by performing the process mentioned in the statement with the string s , or \" NO\" if you cannot. You may print each letter in any case ( YES, yes, Yes will all be recognized as positive answer, NO, no and nO will all be recognized as negative answer) .",
    "note": "Consider the examples. The first test case is described in the statement. In the second test case, you can place the chip on the 1 - st position, move it twice to the right, and then move it twice to the left. In the fourth test case, you can place the chip on the 2 - nd position, and then don' t move it at all. In the fifth test case, you can place the chip on the 1 - st position, move it 5 times to the right, and then finish the process.",
    "topics": [
      "brute force",
      "dp",
      "hashing",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Subsequence Permutation",
    "url": "https://codeforces.com/problemset/problem/1552/A",
    "history": "A string s of length n , consisting of lowercase letters of the English alphabet, is given. You must choose some number k between 0 and n . Then, you select k characters of s and permute them however you want. In this process, the positions of the other n- k characters remain unchanged. You have to perform this operation exactly once. For example, if s= , you can choose the k= 4 characters and permute them into so that after the operation the string becomes . Determine the minimum k so that it is possible to sort s alphabetically ( that is, after the operation its characters appear in alphabetical order) .",
    "input": "The first line contains a single integer t ( 1 \u2264 t \u2264 1000 ) \u2014 the number of test cases. Then t test cases follow. The first line of each test case contains one integer n ( 1 \u2264 n \u2264 40 ) \u2014 the length of the string. The second line of each test case contains the string s . It is guaranteed that s contains only lowercase letters of the English alphabet.",
    "output": "For each test case, output the minimum k that allows you to obtain a string sorted alphabetically, through the operation described above.",
    "note": "In the first test case, we can choose the k= 2 characters and rearrange them as ( so the resulting string is ) . It is not possible to sort the string choosing strictly less than 2 characters. In the second test case, one possible way to sort s is to consider the k= 6 characters and rearrange them as ( so the resulting string is ) . One can show that it is not possible to sort the string choosing strictly less than 6 characters. In the third test case, string s is already sorted ( so we can choose k= 0 characters) . In the fourth test case, we can choose all k= 4 characters and reverse the whole string ( so the resulting string is ) .",
    "topics": [
      "sortings",
      "strings"
    ]
  },
  {
    "title": "Interesting Story",
    "url": "https://codeforces.com/problemset/problem/1551/C",
    "history": "Stephen Queen wants to write a story. He is a very unusual writer, he uses only letters ' a' , ' b' , ' c' , ' d' and ' e' ! To compose a story, Stephen wrote out n words consisting of the first 5 lowercase letters of the Latin alphabet. He wants to select the maximum number of words to make an interesting story. Let a story be a sequence of words that are not necessarily different. A story is called interesting if there exists a letter which occurs among all words of the story more times than all other letters together. For example, the story consisting of three words \" bac\" , \" aaada\" , \" e\" is interesting ( the letter ' a' occurs 5 times, all other letters occur 4 times in total) . But the story consisting of two words \" aba\" , \" abcde\" is not ( no such letter that it occurs more than all other letters in total) . You are given a sequence of n words consisting of letters ' a' , ' b' , ' c' , ' d' and ' e' . Your task is to choose the maximum number of them to make an interesting story. If there' s no way to make a non- empty story, output 0 .",
    "input": "The first line contains one integer t ( 1 \u2264 t \u2264 5000 ) \u2014 the number of test cases. Then t test cases follow. The first line of each test case contains one integer n ( 1 \u2264 n \u2264 2 \u00b7 10^ 5 ) \u2014 the number of the words in the sequence. Then n lines follow, each of them contains a word \u2014 a non- empty string consisting of lowercase letters of the Latin alphabet. The words in the sequence may be non- distinct ( i. e. duplicates are allowed) . Only the letters ' a' , ' b' , ' c' , ' d' and ' e' may occur in the words. It is guaranteed that the sum of n over all test cases doesn' t exceed 2 \u00b7 10^ 5 ; the sum of the lengths of all words over all test cases doesn' t exceed 4 \u00b7 10^ 5 .",
    "output": "For each test case, output the maximum number of words that compose an interesting story. Print 0 if there' s no way to make a non- empty interesting story.",
    "note": "In the first test case of the example, all 3 words can be used to make an interesting story. The interesting story is \" bac aaada e\" . In the second test case of the example, the 1 - st and the 3 - rd words can be used to make an interesting story. The interesting story is \" aba aba\" . Stephen can' t use all three words at the same time. In the third test case of the example, Stephen can' t make a non- empty interesting story. So the answer is 0 . In the fourth test case of the example, Stephen can use the 3 - rd and the 4 - th words to make an interesting story. The interesting story is \" c bc\" .",
    "topics": [
      "greedy",
      "sortings",
      "strings"
    ]
  },
  {
    "title": "Wonderful Coloring - 1",
    "url": "https://codeforces.com/problemset/problem/1551/B1",
    "history": "This is a simplified version of the problem B2. Perhaps you should read the problem B2 before you start solving B1. Paul and Mary have a favorite string s which consists of lowercase letters of the Latin alphabet. They want to paint it using pieces of chalk of two colors: red and green. Let' s call a coloring of a string wonderful if the following conditions are met: each letter of the string is either painted in exactly one color ( red or green) or isn' t painted; each two letters which are painted in the same color are different; the number of letters painted in red is equal to the number of letters painted in green; the number of painted letters of this coloring is maximum among all colorings of the string which meet the first three conditions. E. g. consider a string s equal to \" kzaaa\" . One of the wonderful colorings of the string is shown in the figure. The example of a wonderful coloring of the string \" kzaaa\" . Paul and Mary want to learn by themselves how to find a wonderful coloring of the string. But they are very young, so they need a hint. Help them find k \u2014 the number of red ( or green, these numbers are equal) letters in a wonderful coloring.",
    "input": "The first line contains one integer t ( 1 \u2264 t \u2264 1000 ) \u2014 the number of test cases. Then t test cases follow. Each test case consists of one non- empty string s which consists of lowercase letters of the Latin alphabet. The number of characters in the string doesn' t exceed 50 .",
    "output": "For each test case, output a separate line containing one non- negative integer k \u2014 the number of letters which will be painted in red in a wonderful coloring.",
    "note": "The first test case contains the string from the statement. One of the wonderful colorings is shown in the figure. There' s no wonderful coloring containing 3 or more red letters because the total number of painted symbols will exceed the string' s length. The string from the second test case can be painted as follows. Let' s paint the first occurrence of each of the letters \" c\" , \" o\" , \" e\" in red and the second ones in green. Let' s paint the letters \" d\" , \" f\" in red and \" r\" , \" s\" in green. So every letter will be painted in red or green, hence the answer better than 5 doesn' t exist. The third test case contains the string of distinct letters, so you can paint any set of characters in red, as long as the size of this set doesn' t exceed half of the size of the string and is the maximum possible. The fourth test case contains a single letter which cannot be painted in red because there will be no letter able to be painted in green. The fifth test case contains a string of identical letters, so there' s no way to paint more than one letter in red.",
    "topics": [
      "greedy",
      "strings"
    ]
  },
  {
    "title": "Stringforces",
    "url": "https://codeforces.com/problemset/problem/1550/E",
    "history": "You are given a string s of length n . Each character is either one of the first k lowercase Latin letters or a question mark. You are asked to replace every question mark with one of the first k lowercase Latin letters in such a way that the following value is maximized. Let f_ i be the maximum length substring of string s , which consists entirely of the i - th Latin letter. A substring of a string is a contiguous subsequence of that string. If the i - th letter doesn' t appear in a string, then f_ i is equal to 0 . The value of a string s is the minimum value among f_ i for all i from 1 to k . What is the maximum value the string can have?",
    "input": "The first line contains two integers n and k ( 1 \u2264 n \u2264 2 \u00b7 10^ 5 ; 1 \u2264 k \u2264 17 ) \u2014 the length of the string and the number of first Latin letters used. The second line contains a string s , consisting of n characters. Each character is either one of the first k lowercase Latin letters or a question mark.",
    "output": "Print a single integer \u2014 the maximum value of the string after every question mark is replaced with one of the first k lowercase Latin letters.",
    "note": "In the first example the question marks can be replaced in the following way: \" aaaababbbb\" . f_ 1 = 4 , f_ 2 = 4 , thus the answer is 4 . Replacing it like this is also possible: \" aaaabbbbbb\" . That way f_ 1 = 4 , f_ 2 = 6 , however, the minimum of them is still 4 . In the second example one of the possible strings is \" aabbccdda\" . In the third example at least one letter won' t appear in the string, thus, the minimum of values f_ i is always 0 .",
    "topics": [
      "binary search",
      "bitmasks",
      "brute force",
      "dp",
      "strings",
      "two pointers"
    ]
  },
  {
    "title": "Alphabetical Strings",
    "url": "https://codeforces.com/problemset/problem/1547/B",
    "history": "A string s of length n ( 1 \u2264 n \u2264 26 ) is called alphabetical if it can be obtained using the following algorithm: first, write an empty string to s ( i. e. perform the assignment s : = \" \" ) ; then perform the next step n times; at the i - th step take i - th lowercase letter of the Latin alphabet and write it either to the left of the string s or to the right of the string s ( i. e. perform the assignment s : = c+ s or s : = s+ c , where c is the i - th letter of the Latin alphabet) . In other words, iterate over the n first letters of the Latin alphabet starting from ' a' and etc. Each time we prepend a letter to the left of the string s or append a letter to the right of the string s . Strings that can be obtained in that way are alphabetical. For example, the following strings are alphabetical: \" a\" , \" ba\" , \" ab\" , \" bac\" and \" ihfcbadeg\" . The following strings are not alphabetical: \" z\" , \" aa\" , \" ca\" , \" acb\" , \" xyz\" and \" ddcba\" . From the given string, determine if it is alphabetical.",
    "input": "The first line contains one integer t ( 1 \u2264 t \u2264 10^ 4 ) \u2014 the number of test cases. Then t test cases follow. Each test case is written on a separate line that contains one string s . String s consists of lowercase letters of the Latin alphabet and has a length between 1 and 26 , inclusive.",
    "output": "Output t lines, each of them must contain the answer to the corresponding test case. Output YES if the given string s is alphabetical and NO otherwise. You can output YES and NO in any case ( for example, strings yEs, yes, Yes and YES will be recognized as a positive answer) .",
    "note": "The example contains test cases from the main part of the condition.",
    "topics": [
      "greedy",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Love Song",
    "url": "https://codeforces.com/problemset/problem/1539/B",
    "history": "Petya once wrote a sad love song and shared it to Vasya. The song is a string consisting of lowercase English letters. Vasya made up q questions about this song. Each question is about a subsegment of the song starting from the l - th letter to the r - th letter. Vasya considers a substring made up from characters on this segment and repeats each letter in the subsegment k times, where k is the index of the corresponding letter in the alphabet. For example, if the question is about the substring \" abbcb\" , then Vasya repeats letter ' a' once, each of the letters ' b' twice, letter ' c\" three times, so that the resulting string is \" abbbbcccbb\" , its length is 10 . Vasya is interested about the length of the resulting string. Help Petya find the length of each string obtained by Vasya.",
    "input": "The first line contains two integers n and q ( 1\u2264 n\u2264 100 000 , 1\u2264 q \u2264 100 000 ) \u2014 the length of the song and the number of questions. The second line contains one string s \u2014 the song, consisting of n lowercase letters of English letters. Vasya' s questions are contained in the next q lines. Each line contains two integers l and r ( 1 \u2264 l \u2264 r \u2264 n ) \u2014 the bounds of the question.",
    "output": "Print q lines: for each question print the length of the string obtained by Vasya.",
    "note": "In the first example Vasya is interested in three questions. In the first question Vasya considers the substring \" aba\" , that transforms to \" abba\" , so the answer is equal to 4 . In the second question Vasya considers \" baca\" , that transforms to \" bbaccca\" , so the answer is 7 . In the third question Vasya considers the string \" abacaba\" , that transforms to \" abbacccabba\" of length 11 .",
    "topics": [
      "dp",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Funny Substrings",
    "url": "https://codeforces.com/problemset/problem/1538/E",
    "history": "Polycarp came up with a new programming language. There are only two types of statements in it: \" x : = s\" : assign the variable named x the value s ( where s is a string) . For example, the statement var : = hello assigns the variable named var the value hello. Note that s is the value of a string, not the name of a variable. Between the variable name, the : = operator and the string contains exactly one space each. \" x = a + b\" : assign the variable named x the concatenation of values of two variables a and b. For example, if the program consists of three statements a : = hello, b : = world, c = a + b, then the variable c will contain the string helloworld. It is guaranteed that the program is correct and the variables a and b were previously defined. There is exactly one space between the variable names and the = and + operators. All variable names and strings only consist of lowercase letters of the English alphabet and do not exceed 5 characters. The result of the program is the number of occurrences of string haha in the string that was written to the variable in the last statement. Polycarp was very tired while inventing that language. He asks you to implement it. Your task is \u2014 for given program statements calculate the number of occurrences of string haha in the last assigned variable.",
    "input": "The first line contains an integer t ( 1 \u2264 t \u2264 10^ 3 ) . Then t test cases follow. The first line of each test case contains a single integer n ( 1 \u2264 n \u2264 50 ) \u2014 the number of statements in the program. All variable names and strings are guaranteed to consist only of lowercase letters of the English alphabet and do not exceed 5 characters. This is followed by n lines describing the statements in the format described above. It is guaranteed that the program is correct.",
    "output": "For each set of input data, output the number of occurrences of the haha substring in the string that was written to the variable in the last statement.",
    "note": "In the first test case the resulting value of d is hhahahaha.",
    "topics": [
      "data structures",
      "hashing",
      "implementation",
      "matrices",
      "strings"
    ]
  },
  {
    "title": "Erase and Extend (Hard Version)",
    "url": "https://codeforces.com/problemset/problem/1537/E2",
    "history": "This is the hard version of the problem. The only difference is the constraints on n and k . You can make hacks only if all versions of the problem are solved. You have a string s , and you can do two types of operations on it: Delete the last character of the string. Duplicate the string: s: = s+ s , where + denotes concatenation. You can use each operation any number of times ( possibly none) . Your task is to find the lexicographically smallest string of length exactly k that can be obtained by doing these operations on string s . A string a is lexicographically smaller than a string b if and only if one of the following holds: a is a prefix of b , but a b ; In the first position where a and b differ, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b .",
    "input": "The first line contains two integers n , k ( 1 \u2264 n, k \u2264 5\u00b7 10^ 5 ) \u2014 the length of the original string s and the length of the desired string. The second line contains the string s , consisting of n lowercase English letters.",
    "output": "Print the lexicographically smallest string of length k that can be obtained by doing the operations on string s .",
    "note": "In the first test, it is optimal to make one duplication: \" dbcadabc\" \u2192 \" dbcadabcdbcadabc\" . In the second test it is optimal to delete the last 3 characters, then duplicate the string 3 times, then delete the last 3 characters to make the string have length k . \" abcd\" \u2192 \" abc\" \u2192 \" ab\" \u2192 \" a\" \u2192 \" aa\" \u2192 \" aaaa\" \u2192 \" aaaaaaaa\" \u2192 \" aaaaaaa\" \u2192 \" aaaaaa\" \u2192 \" aaaaa\" .",
    "topics": [
      "binary search",
      "data structures",
      "greedy",
      "hashing",
      "string suffix structures",
      "strings",
      "two pointers"
    ]
  },
  {
    "title": "Erase and Extend (Easy Version)",
    "url": "https://codeforces.com/problemset/problem/1537/E1",
    "history": "This is the easy version of the problem. The only difference is the constraints on n and k . You can make hacks only if all versions of the problem are solved. You have a string s , and you can do two types of operations on it: Delete the last character of the string. Duplicate the string: s: = s+ s , where + denotes concatenation. You can use each operation any number of times ( possibly none) . Your task is to find the lexicographically smallest string of length exactly k that can be obtained by doing these operations on string s . A string a is lexicographically smaller than a string b if and only if one of the following holds: a is a prefix of b , but a b ; In the first position where a and b differ, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b .",
    "input": "The first line contains two integers n , k ( 1 \u2264 n, k \u2264 5000 ) \u2014 the length of the original string s and the length of the desired string. The second line contains the string s , consisting of n lowercase English letters.",
    "output": "Print the lexicographically smallest string of length k that can be obtained by doing the operations on string s .",
    "note": "In the first test, it is optimal to make one duplication: \" dbcadabc\" \u2192 \" dbcadabcdbcadabc\" . In the second test it is optimal to delete the last 3 characters, then duplicate the string 3 times, then delete the last 3 characters to make the string have length k . \" abcd\" \u2192 \" abc\" \u2192 \" ab\" \u2192 \" a\" \u2192 \" aa\" \u2192 \" aaaa\" \u2192 \" aaaaaaaa\" \u2192 \" aaaaaaa\" \u2192 \" aaaaaa\" \u2192 \" aaaaa\" .",
    "topics": [
      "binary search",
      "brute force",
      "dp",
      "greedy",
      "hashing",
      "implementation",
      "string suffix structures",
      "strings",
      "two pointers"
    ]
  },
  {
    "title": "Prinzessin der Verurteilung",
    "url": "https://codeforces.com/problemset/problem/1536/B",
    "history": "I, Fischl, Prinzessin der Verurteilung, descend upon this land by the call of fate an \u2014 Oh, you are also a traveler from another world? Very well, I grant you permission to travel with me. It is no surprise Fischl speaks with a strange choice of words. However, this time, not even Oz, her raven friend, can interpret her expressions! Maybe you can help us understand what this young princess is saying? You are given a string of n lowercase Latin letters, the word that Fischl just spoke. You think that the MEX of this string may help you find the meaning behind this message. The MEX of the string is defined as the shortest string that doesn' t appear as a contiguous substring in the input. If multiple strings exist, the lexicographically smallest one is considered the MEX. Note that the empty substring does NOT count as a valid MEX. A string a is lexicographically smaller than a string b if and only if one of the following holds: a is a prefix of b , but a b ; in the first position where a and b differ, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b . A string a is a substring of a string b if a can be obtained from b by deletion of several ( possibly, zero or all) characters from the beginning and several ( possibly, zero or all) characters from the end. Find out what the MEX of the string is!",
    "input": "Each test contains multiple test cases. The first line contains the number of test cases t ( 1 \u2264 t \u2264 1000 ) . Description of the test cases follows. The first line of each test case contains an integer n ( 1 \u2264 n \u2264 1000 ) \u2014 the length of the word. The second line for each test case contains a single string of n lowercase Latin letters. The sum of n over all test cases will not exceed 1000 .",
    "output": "For each test case, output the MEX of the string on a new line.",
    "note": "",
    "topics": [
      "brute force",
      "constructive algorithms",
      "strings"
    ]
  },
  {
    "title": "String Distance",
    "url": "https://codeforces.com/problemset/problem/1535/F",
    "history": "Suppose you are given two strings a and b . You can apply the following operation any number of times: choose any contiguous substring of a or b , and sort the characters in it in non- descending order. Let f( a, b) the minimum number of operations you have to apply in order to make them equal ( or f( a, b) = 1337 if it is impossible to make a and b equal using these operations) . For example: f( ab, ab) = 0 ; f( ba, ab) = 1 ( in one operation, we can sort the whole first string) ; f( ebcda, ecdba) = 1 ( in one operation, we can sort the substring of the second string starting from the 2 - nd character and ending with the 4 - th character) ; f( a, b) = 1337 . You are given n strings s_ 1, s_ 2, . . . , s_ k having equal length. Calculate \u2211_ i = 1^ n\u2211_ j = i + 1^ n f( s_ i, s_ j) .",
    "input": "The first line contains one integer n ( 1 \u2264 n \u2264 2 \u00b7 10^ 5 ) \u2014 the number of strings. Then n lines follow, each line contains one of the strings s_ i , consisting of lowercase Latin letters. | s_ 1| = | s_ 2| = . . . = | s_ n| , and n \u00b7 | s_ 1| \u2264 2 \u00b7 10^ 5 . All these strings are pairwise distinct.",
    "output": "Print one integer: \u2211_ i = 1^ n\u2211_ j = i + 1^ n f( s_ i, s_ j) .",
    "note": "",
    "topics": [
      "binary search",
      "brute force",
      "data structures",
      "hashing",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Unstable String",
    "url": "https://codeforces.com/problemset/problem/1535/C",
    "history": "You are given a string s consisting of the characters 0, 1, and ? . Let' s call a string unstable if it consists of the characters 0 and 1 and any two adjacent characters are different ( i. e. it has the form 010101. . . or 101010. . . ) . Let' s call a string beautiful if it consists of the characters 0, 1, and ? , and you can replace the characters ? to 0 or 1 ( for each character, the choice is independent) , so that the string becomes unstable. For example, the strings 0? ? 10, 0, and ? ? ? are beautiful, and the strings 00 and ? 1? ? 1 are not. Calculate the number of beautiful contiguous substrings of the string s .",
    "input": "The first line contains a single integer t ( 1 \u2264 t \u2264 10^ 4 ) \u2014 number of test cases. The first and only line of each test case contains the string s ( 1 \u2264 | s| \u2264 2 \u00b7 10^ 5 ) consisting of characters 0, 1, and ? . It is guaranteed that the sum of the string lengths over all test cases does not exceed 2 \u00b7 10^ 5 .",
    "output": "For each test case, output a single integer \u2014 the number of beautiful substrings of the string s .",
    "note": "",
    "topics": [
      "binary search",
      "dp",
      "greedy",
      "implementation",
      "strings",
      "two pointers"
    ]
  },
  {
    "title": "Prefixes and Suffixes",
    "url": "https://codeforces.com/problemset/problem/1532/F",
    "history": "Ivan wants to play a game with you. He picked some string s of length n consisting only of lowercase Latin letters. You don' t know this string. Ivan has informed you about all its improper prefixes and suffixes ( i. e. prefixes and suffixes of lengths from 1 to n- 1 ) , but he didn' t tell you which strings are prefixes and which are suffixes. Ivan wants you to guess which of the given 2n- 2 strings are prefixes of the given string and which are suffixes. It may be impossible to guess the string Ivan picked ( since multiple strings may give the same set of suffixes and prefixes) , but Ivan will accept your answer if there is at least one string that is consistent with it. Let the game begin!",
    "input": "The first line of the input contains one integer number n ( 2 \u2264 n \u2264 100 ) \u2014 the length of the guessed string s . The next 2n- 2 lines are contain prefixes and suffixes, one per line. Each of them is the string of length from 1 to n- 1 consisting only of lowercase Latin letters. They can be given in arbitrary order. It is guaranteed that there are exactly 2 strings of each length from 1 to n- 1 . It is also guaranteed that these strings are prefixes and suffixes of some existing string of length n .",
    "output": "Print one string of length 2n- 2 \u2014 the string consisting only of characters ' P' and ' S' . The number of characters ' P' should be equal to the number of characters ' S' . The i - th character of this string should be ' P' if the i - th of the input strings is the prefix and ' S' otherwise. If there are several possible answers, you can print any.",
    "note": "The only string which Ivan can guess in the first example is \" ababa\" . The only string which Ivan can guess in the second example is \" aaa\" . Answers \" SPSP\" , \" SSPP\" and \" PSPS\" are also acceptable. In the third example Ivan can guess the string \" ac\" or the string \" ca\" . The answer \" SP\" is also acceptable.",
    "topics": [
      "*special",
      "strings"
    ]
  },
  {
    "title": "Minimax",
    "url": "https://codeforces.com/problemset/problem/1530/E",
    "history": "Prefix function of string t = t_ 1 t_ 2 . . . t_ n and position i in it is defined as the length k of the longest proper ( not equal to the whole substring) prefix of substring t_ 1 t_ 2 . . . t_ i which is also a suffix of the same substring. For example, for string t = abacaba the values of the prefix function in positions 1, 2, . . . , 7 are equal to [ 0, 0, 1, 0, 1, 2, 3] . Let f( t) be equal to the maximum value of the prefix function of string t over all its positions. For example, f( abacaba ) = 3 . You are given a string s . Reorder its characters arbitrarily to get a string t ( the number of occurrences of any character in strings s and t must be equal) . The value of f( t) must be minimized. Out of all options to minimize f( t) , choose the one where string t is the lexicographically smallest.",
    "input": "Each test contains multiple test cases. The first line contains the number of test cases t ( 1 \u2264 t \u2264 10^ 5 ) . Description of the test cases follows. The only line of each test case contains string s ( 1 \u2264 | s| \u2264 10^ 5 ) consisting of lowercase English letters. It is guaranteed that the sum of lengths of s over all test cases does not exceed 10^ 5 .",
    "output": "For each test case print a single string t . The multisets of letters in strings s and t must be equal. The value of f( t) , the maximum of prefix functions in string t , must be as small as possible. String t must be the lexicographically smallest string out of all strings satisfying the previous conditions.",
    "note": "A string a is lexicographically smaller than a string b if and only if one of the following holds: a is a prefix of b , but a b ; in the first position where a and b differ, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b . In the first test case, f( t) = 0 and the values of prefix function are [ 0, 0, 0, 0, 0] for any permutation of letters. String ckpuv is the lexicographically smallest permutation of letters of string vkcup. In the second test case, f( t) = 1 and the values of prefix function are [ 0, 1, 0, 1, 0, 1, 0] . In the third test case, f( t) = 5 and the values of prefix function are [ 0, 1, 2, 3, 4, 5] .",
    "topics": [
      "constructive algorithms",
      "greedy",
      "strings"
    ]
  },
  {
    "title": "Kill Anton",
    "url": "https://codeforces.com/problemset/problem/1526/D",
    "history": "After rejecting 10^ 100 data structure problems, Errorgorn is very angry at Anton and decided to kill him. Anton' s DNA can be represented as a string a which only contains the characters \" ANTON\" ( there are only 4 distinct characters) . Errorgorn can change Anton' s DNA into string b which must be a permutation of a . However, Anton' s body can defend against this attack. In 1 second, his body can swap 2 adjacent characters of his DNA to transform it back to a . Anton' s body is smart and will use the minimum number of moves. To maximize the chance of Anton dying, Errorgorn wants to change Anton' s DNA the string that maximizes the time for Anton' s body to revert his DNA. But since Errorgorn is busy making more data structure problems, he needs your help to find the best string B . Can you help him?",
    "input": "The first line of input contains a single integer t ( 1 \u2264 t \u2264 100000) \u2014 the number of testcases. The first and only line of each testcase contains 1 string a ( 1 \u2264 | a| \u2264 100000 ) . a consists of only the characters \" A\" , \" N\" , \" O\" and \" T\" . It is guaranteed that the sum of | a| over all testcases does not exceed 100000 .",
    "output": "For each testcase, print a single string, b . If there are multiple answers, you can output any one of them. b must be a permutation of the string a .",
    "note": "For the first testcase, it takes 7 seconds for Anton' s body to transform NNOTA to ANTON: NNOTA \u2192 NNOAT \u2192 NNAOT \u2192 NANOT \u2192 NANTO \u2192 ANNTO \u2192 ANTNO \u2192 ANTON. Note that you cannot output strings such as AANTON, ANTONTRYGUB, AAAAA and anton as it is not a permutation of ANTON. For the second testcase, it takes 2 seconds for Anton' s body to transform AANN to NAAN. Note that other strings such as NNAA and ANNA will also be accepted.",
    "topics": [
      "brute force",
      "constructive algorithms",
      "data structures",
      "math",
      "strings"
    ]
  },
  {
    "title": "A-B Palindrome",
    "url": "https://codeforces.com/problemset/problem/1512/C",
    "history": "You are given a string s consisting of the characters ' 0' , ' 1' , and ' ? ' . You need to replace all the characters with ' ? ' in the string s by ' 0' or ' 1' so that the string becomes a palindrome and has exactly a characters ' 0' and exactly b characters ' 1' . Note that each of the characters ' ? ' is replaced independently from the others. A string t of length n is called a palindrome if the equality t[ i] = t[ n- i+ 1] is true for all i ( 1 \u2264 i \u2264 n ) . For example, if s= \" 01? ? ? ? ? 0\" , a= 4 and b= 4 , then you can replace the characters ' ? ' in the following ways: \" 01011010\" ; \" 01100110\" . For the given string s and the numbers a and b , replace all the characters with ' ? ' in the string s by ' 0' or ' 1' so that the string becomes a palindrome and has exactly a characters ' 0' and exactly b characters ' 1' .",
    "input": "The first line contains a single integer t ( 1 \u2264 t \u2264 10^ 4 ) . Then t test cases follow. The first line of each test case contains two integers a and b ( 0 \u2264 a, b \u2264 2 \u00b7 10^ 5 , a + b \u2265 1 ) . The second line of each test case contains the string s of length a+ b , consisting of the characters ' 0' , ' 1' , and ' ? ' . It is guaranteed that the sum of the string lengths of s over all test cases does not exceed 2 \u00b7 10^ 5 .",
    "output": "For each test case, output: \" - 1\" , if you can' t replace all the characters ' ? ' in the string s by ' 0' or ' 1' so that the string becomes a palindrome and that it contains exactly a characters ' 0' and exactly b characters ' 1' ; the string that is obtained as a result of the replacement, otherwise. If there are several suitable ways to replace characters, you can output any.",
    "note": "",
    "topics": [
      "constructive algorithms",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Chainword",
    "url": "https://codeforces.com/problemset/problem/1511/F",
    "history": "A chainword is a special type of crossword. As most of the crosswords do, it has cells that you put the letters in and some sort of hints to what these letters should be. The letter cells in a chainword are put in a single row. We will consider chainwords of length m in this task. A hint to a chainword is a sequence of segments such that the segments don' t intersect with each other and cover all m letter cells. Each segment contains a description of the word in the corresponding cells. The twist is that there are actually two hints: one sequence is the row above the letter cells and the other sequence is the row below the letter cells. When the sequences are different, they provide a way to resolve the ambiguity in the answers. You are provided with a dictionary of n words, each word consists of lowercase Latin letters. All words are pairwise distinct. An instance of a chainword is the following triple: a string of m lowercase Latin letters; the first hint: a sequence of segments such that the letters that correspond to each segment spell a word from the dictionary; the second hint: another sequence of segments such that the letters that correspond to each segment spell a word from the dictionary. Note that the sequences of segments don' t necessarily have to be distinct. Two instances of chainwords are considered different if they have different strings, different first hints or different second hints. Count the number of different instances of chainwords. Since the number might be pretty large, output it modulo 998 244 353 .",
    "input": "The first line contains two integers n and m ( 1 \u2264 n \u2264 8 , 1 \u2264 m \u2264 10^ 9 ) \u2014 the number of words in the dictionary and the number of letter cells. Each of the next n lines contains a word \u2014 a non- empty string of no more than 5 lowercase Latin letters. All words are pairwise distinct.",
    "output": "Print a single integer \u2014 the number of different instances of chainwords of length m for the given dictionary modulo 998 244 353 .",
    "note": "Here are all the instances of the valid chainwords for the first example: The red lines above the letters denote the segments of the first hint, the blue lines below the letters denote the segments of the second hint. In the second example the possible strings are: \" abab\" , \" abcd\" , \" cdab\" and \" cdcd\" . All the hints are segments that cover the first two letters and the last two letters.",
    "topics": [
      "brute force",
      "data structures",
      "dp",
      "matrices",
      "string suffix structures",
      "strings"
    ]
  },
  {
    "title": "Min Cost String",
    "url": "https://codeforces.com/problemset/problem/1511/D",
    "history": "Let' s define the cost of a string s as the number of index pairs i and j ( 1 \u2264 i < j < | s| ) such that s_ i = s_ j and s_ i+ 1 = s_ j+ 1 . You are given two positive integers n and k . Among all strings with length n that contain only the first k characters of the Latin alphabet, find a string with minimum possible cost. If there are multiple such strings with minimum cost \u2014 find any of them.",
    "input": "The only line contains two integers n and k ( 1 \u2264 n \u2264 2 \u00b7 10^ 5; 1 \u2264 k \u2264 26 ) .",
    "output": "Print the string s such that it consists of n characters, each its character is one of the k first Latin letters, and it has the minimum possible cost among all these strings. If there are multiple such strings \u2014 print any of them.",
    "note": "",
    "topics": [
      "brute force",
      "constructive algorithms",
      "graphs",
      "greedy",
      "strings"
    ]
  },
  {
    "title": "Binary Literature",
    "url": "https://codeforces.com/problemset/problem/1508/A",
    "history": "A bitstring is a string that contains only the characters 0 and 1. Koyomi Kanou is working hard towards her dream of becoming a writer. To practice, she decided to participate in the Binary Novel Writing Contest. The writing prompt for the contest consists of three bitstrings of length 2n . A valid novel for the contest is a bitstring of length at most 3n that contains at least two of the three given strings as subsequences. Koyomi has just received the three prompt strings from the contest organizers. Help her write a valid novel for the contest. A string a is a subsequence of a string b if a can be obtained from b by deletion of several ( possibly, zero) characters.",
    "input": "The first line contains a single integer t ( 1 \u2264 t \u2264 10^ 4 ) \u2014 the number of test cases. The first line of each test case contains a single integer n ( 1 \u2264 n \u2264 10^ 5 ) . Each of the following three lines contains a bitstring of length 2n . It is guaranteed that these three strings are pairwise distinct. It is guaranteed that the sum of n across all test cases does not exceed 10^ 5 .",
    "output": "For each test case, print a single line containing a bitstring of length at most 3n that has at least two of the given bitstrings as subsequences. It can be proven that under the constraints of the problem, such a bitstring always exists. If there are multiple possible answers, you may output any of them.",
    "note": "In the first test case, the bitstrings 00 and 01 are subsequences of the output string: 010 and 010. Note that 11 is not a subsequence of the output string, but this is not required. In the second test case all three input strings are subsequences of the output string: 011001010, 011001010 and 011001010.",
    "topics": [
      "constructive algorithms",
      "greedy",
      "implementation",
      "strings",
      "two pointers"
    ]
  },
  {
    "title": "Maximize the Remaining String",
    "url": "https://codeforces.com/problemset/problem/1506/G",
    "history": "You are given a string s , consisting of lowercase Latin letters. While there is at least one character in the string s that is repeated at least twice, you perform the following operation: you choose the index i ( 1 \u2264 i \u2264 | s| ) such that the character at position i occurs at least two times in the string s , and delete the character at position i , that is, replace s with s_ 1 s_ 2 . . . s_ i- 1 s_ i+ 1 s_ i+ 2. . . s_ n . For example, if s= \" codeforces\" , then you can apply the following sequence of operations: i= 6 \u21d2 s= \" codefrces\" ; i= 1 \u21d2 s= \" odefrces\" ; i= 7 \u21d2 s= \" odefrcs\" ; Given a given string s , find the lexicographically maximum string that can be obtained after applying a certain sequence of operations after which all characters in the string become unique. A string a of length n is lexicographically less than a string b of length m , if: there is an index i ( 1 \u2264 i \u2264min( n, m) ) such that the first i- 1 characters of the strings a and b are the same, and the i - th character of the string a is less than i - th character of string b ; or the first min( n, m) characters in the strings a and b are the same and n < m . For example, the string a= \" aezakmi\" is lexicographically less than the string b= \" aezus\" .",
    "input": "The first line contains one integer t ( 1 \u2264 t \u2264 10^ 4 ) . Then t test cases follow. Each test case is characterized by a string s , consisting of lowercase Latin letters ( 1 \u2264 | s| \u2264 2 \u00b7 10^ 5 ) . It is guaranteed that the sum of the lengths of the strings in all test cases does not exceed 2 \u00b7 10^ 5 .",
    "output": "For each test case, output the lexicographically maximum string that can be obtained after applying a certain sequence of operations after which all characters in the string become unique.",
    "note": "",
    "topics": [
      "brute force",
      "data structures",
      "dp",
      "greedy",
      "strings"
    ]
  },
  {
    "title": "Double-ended Strings",
    "url": "https://codeforces.com/problemset/problem/1506/C",
    "history": "You are given the strings a and b , consisting of lowercase Latin letters. You can do any number of the following operations in any order: if | a| > 0 ( the length of the string a is greater than zero) , delete the first character of the string a , that is, replace a with a_ 2 a_ 3 . . . a_ n ; if | a| > 0 , delete the last character of the string a , that is, replace a with a_ 1 a_ 2 . . . a_ n- 1 ; if | b| > 0 ( the length of the string b is greater than zero) , delete the first character of the string b , that is, replace b with b_ 2 b_ 3 . . . b_ n ; if | b| > 0 , delete the last character of the string b , that is, replace b with b_ 1 b_ 2 . . . b_ n- 1 . Note that after each of the operations, the string a or b may become empty. For example, if a= \" hello\" and b= \" icpc\" , then you can apply the following sequence of operations: delete the first character of the string a \u21d2 a= \" ello\" and b= \" icpc\" ; delete the first character of the string b \u21d2 a= \" ello\" and b= \" cpc\" ; delete the first character of the string b \u21d2 a= \" ello\" and b= \" pc\" ; delete the last character of the string a \u21d2 a= \" ell\" and b= \" pc\" ; delete the last character of the string b \u21d2 a= \" ell\" and b= \" p\" . For the given strings a and b , find the minimum number of operations for which you can make the strings a and b equal. Note that empty strings are also equal.",
    "input": "The first line contains a single integer t ( 1 \u2264 t \u2264 100 ) . Then t test cases follow. The first line of each test case contains the string a ( 1 \u2264 | a| \u2264 20 ) , consisting of lowercase Latin letters. The second line of each test case contains the string b ( 1 \u2264 | b| \u2264 20 ) , consisting of lowercase Latin letters.",
    "output": "For each test case, output the minimum number of operations that can make the strings a and b equal.",
    "note": "",
    "topics": [
      "brute force",
      "implementation",
      "strings"
    ]
  },
  {
    "title": " D\u00e9j\u00e0 Vu",
    "url": "https://codeforces.com/problemset/problem/1504/A",
    "history": "A palindrome is a string that reads the same backward as forward. For example, the strings \" z\" , \" aaa\" , \" aba\" , and \" abccba\" are palindromes, but \" codeforces\" and \" ab\" are not. You hate palindromes because they give you de\u0301ja\u0300 vu. There is a string s . You must insert exactly one character ' a' somewhere in s . If it is possible to create a string that is not a palindrome, you should find one example. Otherwise, you should report that it is impossible. For example, suppose s= \" cbabc\" . By inserting an ' a' , you can create \" acbabc\" , \" cababc\" , \" cbaabc\" , \" cbabac\" , or \" cbabca\" . However \" cbaabc\" is a palindrome, so you must output one of the other options.",
    "input": "The first line contains a single integer t ( 1\u2264 t\u2264 10^ 4 ) \u2014 the number of test cases. The only line of each test case contains a string s consisting of lowercase English letters. The total length of all strings does not exceed 3\u00b7 10^ 5 .",
    "output": "For each test case, if there is no solution, output \" NO\" . Otherwise, output \" YES\" followed by your constructed string of length | s| + 1 on the next line. If there are multiple solutions, you may print any. You can print each letter of \" YES\" and \" NO\" in any case ( upper or lower) .",
    "note": "The first test case is described in the statement. In the second test case, we can make either \" aab\" or \" aba\" . But \" aba\" is a palindrome, so \" aab\" is the only correct answer. In the third test case, \" zaza\" and \" zzaa\" are correct answers, but not \" azza\" . In the fourth test case, \" baa\" is the only correct answer. In the fifth test case, we can only make \" aa\" , which is a palindrome. So the answer is \" NO\" . In the sixth test case, \" anutforajaroftuna\" is a palindrome, but inserting ' a' elsewhere is valid.",
    "topics": [
      "constructive algorithms",
      "strings"
    ]
  },
  {
    "title": "Chaotic Merge",
    "url": "https://codeforces.com/problemset/problem/1499/E",
    "history": "You are given two strings x and y , both consist only of lowercase Latin letters. Let | s| be the length of string s . Let' s call a sequence a a merging sequence if it consists of exactly | x| zeros and exactly | y| ones in some order. A merge z is produced from a sequence a by the following rules: if a_ i= 0 , then remove a letter from the beginning of x and append it to the end of z ; if a_ i= 1 , then remove a letter from the beginning of y and append it to the end of z . Two merging sequences a and b are different if there is some position i such that a_ i = \u0338 b_ i . Let' s call a string z chaotic if for all i from 2 to | z| z_ i- 1= \u0338 z_ i . Let s[ l, r] for some 1 \u2264 l \u2264 r \u2264 | s| be a substring of consecutive letters of s , starting from position l and ending at position r inclusive. Let f( l_ 1, r_ 1, l_ 2, r_ 2) be the number of different merging sequences of x[ l_ 1, r_ 1] and y[ l_ 2, r_ 2] that produce chaotic merges. Note that only non- empty substrings of x and y are considered. Calculate \u2211_ 1 \u2264 l_ 1 \u2264 r_ 1 \u2264 | x| 1 \u2264 l_ 2 \u2264 r_ 2 \u2264 | y| f( l_ 1, r_ 1, l_ 2, r_ 2) . Output the answer modulo 998 244 353 .",
    "input": "The first line contains a string x ( 1 \u2264 | x| \u2264 1000 ) . The second line contains a string y ( 1 \u2264 | y| \u2264 1000 ) . Both strings consist only of lowercase Latin letters.",
    "output": "Print a single integer \u2014 the sum of f( l_ 1, r_ 1, l_ 2, r_ 2) over 1 \u2264 l_ 1 \u2264 r_ 1 \u2264 | x| and 1 \u2264 l_ 2 \u2264 r_ 2 \u2264 | y| modulo 998 244 353 .",
    "note": "In the first example there are: 6 pairs of substrings \" a\" and \" b\" , each with valid merging sequences \" 01\" and \" 10\" ; 3 pairs of substrings \" a\" and \" bb\" , each with a valid merging sequence \" 101\" ; 4 pairs of substrings \" aa\" and \" b\" , each with a valid merging sequence \" 010\" ; 2 pairs of substrings \" aa\" and \" bb\" , each with valid merging sequences \" 0101\" and \" 1010\" ; 2 pairs of substrings \" aaa\" and \" b\" , each with no valid merging sequences; 1 pair of substrings \" aaa\" and \" bb\" with a valid merging sequence \" 01010\" ; Thus, the answer is 6 \u00b7 2 + 3 \u00b7 1 + 4 \u00b7 1 + 2 \u00b7 2 + 2 \u00b7 0 + 1 \u00b7 1 = 24 .",
    "topics": [
      "combinatorics",
      "dp",
      "math",
      "strings"
    ]
  },
  {
    "title": "Split it!",
    "url": "https://codeforces.com/problemset/problem/1496/A",
    "history": "Kawashiro Nitori is a girl who loves competitive programming. One day she found a string and an integer. As an advanced problem setter, she quickly thought of a problem. Given a string s and a parameter k , you need to check if there exist k+ 1 non- empty strings a_ 1, a_ 2. . . , a_ k+ 1 , such that s= a_ 1+ a_ 2+ . . . + a_ k+ a_ k+ 1+ R( a_ k) + R( a_ k- 1) + . . . + R( a_ 1) . Here + represents concatenation. We define R( x) as a reversed string x . For example R( abcd) = dcba . Note that in the formula above the part R( a_ k+ 1) is intentionally skipped.",
    "input": "The input consists of multiple test cases. The first line contains a single integer t ( 1\u2264 t\u2264 100 ) \u2014 the number of test cases. The description of the test cases follows. The first line of each test case description contains two integers n , k ( 1\u2264 n\u2264 100 , 0\u2264 k\u2264\u230an/ 2\u230b ) \u2014 the length of the string s and the parameter k . The second line of each test case description contains a single string s of length n , consisting of lowercase English letters.",
    "output": "For each test case, print \" YES\" ( without quotes) , if it is possible to find a_ 1, a_ 2, . . . , a_ k+ 1 , and \" NO\" ( without quotes) otherwise. You can print letters in any case ( upper or lower) .",
    "note": "In the first test case, one possible solution is a_ 1= qw and a_ 2= q . In the third test case, one possible solution is a_ 1= i and a_ 2= o . In the fifth test case, one possible solution is a_ 1= dokidokiliteratureclub .",
    "topics": [
      "brute force",
      "constructive algorithms",
      "greedy",
      "strings"
    ]
  },
  {
    "title": "Enormous XOR",
    "url": "https://codeforces.com/problemset/problem/1493/E",
    "history": "You are given two integers l and r in binary representation. Let g( x, y) be equal to the bitwise XOR of all integers from x to y inclusive ( that is x \u2295 ( x+ 1) \u2295. . . \u2295 ( y- 1) \u2295 y ) . Let' s define f( l, r) as the maximum of all values of g( x, y) satisfying l \u2264 x \u2264 y \u2264 r . Output f( l, r) .",
    "input": "The first line contains a single integer n ( 1 \u2264 n \u2264 10^ 6 ) \u2014 the length of the binary representation of r . The second line contains the binary representation of l \u2014 a string of length n consisting of digits 0 and 1 ( 0 \u2264 l < 2^ n ) . The third line contains the binary representation of r \u2014 a string of length n consisting of digits 0 and 1 ( 0 \u2264 r < 2^ n ) . It is guaranteed that l \u2264 r . The binary representation of r does not contain any extra leading zeros ( if r= 0 , the binary representation of it consists of a single zero) . The binary representation of l is preceded with leading zeros so that its length is equal to n .",
    "output": "In a single line output the value of f( l, r) for the given pair of l and r in binary representation without extra leading zeros.",
    "note": "In sample test case l= 19 , r= 122 . f( x, y) is maximal and is equal to 127 , with x= 27 , y= 100 , for example.",
    "topics": [
      "bitmasks",
      "constructive algorithms",
      "greedy",
      "math",
      "strings",
      "two pointers"
    ]
  },
  {
    "title": "K-beautiful Strings",
    "url": "https://codeforces.com/problemset/problem/1493/C",
    "history": "You are given a string s consisting of lowercase English letters and a number k . Let' s call a string consisting of lowercase English letters beautiful if the number of occurrences of each letter in that string is divisible by k . You are asked to find the lexicographically smallest beautiful string of length n , which is lexicographically greater or equal to string s . If such a string does not exist, output - 1 . A string a is lexicographically smaller than a string b if and only if one of the following holds: a is a prefix of b , but a b ; in the first position where a and b differ, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b .",
    "input": "The first line contains a single integer T ( 1 \u2264 T \u2264 10 000 ) \u2014 the number of test cases. The next 2 \u00b7 T lines contain the description of test cases. The description of each test case consists of two lines. The first line of the description contains two integers n and k ( 1 \u2264 k \u2264 n \u2264 10^ 5 ) \u2014 the length of string s and number k respectively. The second line contains string s consisting of lowercase English letters. It is guaranteed that the sum of n over all test cases does not exceed 10^ 5 .",
    "output": "For each test case output in a separate line lexicographically smallest beautiful string of length n , which is greater or equal to string s , or - 1 if such a string does not exist.",
    "note": "In the first test case \" acac\" is greater than or equal to s , and each letter appears 2 or 0 times in it, so it is beautiful. In the second test case each letter appears 0 or 1 times in s , so s itself is the answer. We can show that there is no suitable string in the third test case. In the fourth test case each letter appears 0 , 3 , or 6 times in \" abaabaaab\" . All these integers are divisible by 3 .",
    "topics": [
      "binary search",
      "brute force",
      "constructive algorithms",
      "greedy",
      "strings"
    ]
  },
  {
    "title": "Space Navigation ",
    "url": "https://codeforces.com/problemset/problem/1481/A",
    "history": "You were dreaming that you are traveling to a planet named Planetforces on your personal spaceship. Unfortunately, its piloting system was corrupted and now you need to fix it in order to reach Planetforces. Space can be represented as the XY plane. You are starting at point ( 0, 0) , and Planetforces is located in point ( p_ x, p_ y) . The piloting system of your spaceship follows its list of orders which can be represented as a string s . The system reads s from left to right. Suppose you are at point ( x, y) and current order is s_ i : if s_ i = U , you move to ( x, y + 1) ; if s_ i = D , you move to ( x, y - 1) ; if s_ i = R , you move to ( x + 1, y) ; if s_ i = L , you move to ( x - 1, y) . Since string s could be corrupted, there is a possibility that you won' t reach Planetforces in the end. Fortunately, you can delete some orders from s but you can' t change their positions. Can you delete several orders ( possibly, zero) from s in such a way, that you' ll reach Planetforces after the system processes all orders?",
    "input": "The first line contains a single integer t ( 1 \u2264 t \u2264 1000 ) \u2014 the number of test cases. Each test case consists of two lines. The first line in each test case contains two integers p_ x and p_ y ( - 10^ 5 \u2264 p_ x, p_ y \u2264 10^ 5 ; ( p_ x, p_ y) = \u0338 ( 0, 0) ) \u2014 the coordinates of Planetforces ( p_ x, p_ y) . The second line contains the string s ( 1 \u2264 | s| \u2264 10^ 5 : | s| is the length of string s ) \u2014 the list of orders. It is guaranteed that the sum of | s| over all test cases does not exceed 10^ 5 .",
    "output": "For each test case, print \" YES\" if you can delete several orders ( possibly, zero) from s in such a way, that you' ll reach Planetforces. Otherwise, print \" NO\" . You can print each letter in any case ( upper or lower) .",
    "note": "In the first case, you don' t need to modify s , since the given s will bring you to Planetforces. In the second case, you can delete orders s_ 2 , s_ 3 , s_ 4 , s_ 6 , s_ 7 and s_ 8 , so s becomes equal to \" UR\" . In the third test case, you have to delete order s_ 9 , otherwise, you won' t finish in the position of Planetforces.",
    "topics": [
      "greedy",
      "strings"
    ]
  },
  {
    "title": "Yet Another String Game",
    "url": "https://codeforces.com/problemset/problem/1480/A",
    "history": "Homer has two friends Alice and Bob. Both of them are string fans. One day, Alice and Bob decide to play a game on a string s = s_ 1 s_ 2 . . . s_ n of length n consisting of lowercase English letters. They move in turns alternatively and Alice makes the first move. In a move, a player must choose an index i ( 1 \u2264 i \u2264 n ) that has not been chosen before, and change s_ i to any other lowercase English letter c that c = \u0338 s_ i . When all indices have been chosen, the game ends. The goal of Alice is to make the final string lexicographically as small as possible, while the goal of Bob is to make the final string lexicographically as large as possible. Both of them are game experts, so they always play games optimally. Homer is not a game expert, so he wonders what the final string will be. A string a is lexicographically smaller than a string b if and only if one of the following holds: a is a prefix of b , but a b ; in the first position where a and b differ, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b .",
    "input": "Each test contains multiple test cases. The first line contains t ( 1 \u2264 t \u2264 1000 ) \u2014 the number of test cases. Description of the test cases follows. The only line of each test case contains a single string s ( 1 \u2264 | s| \u2264 50 ) consisting of lowercase English letters.",
    "output": "For each test case, print the final string in a single line.",
    "note": "In the first test case: Alice makes the first move and must change the only letter to a different one, so she changes it to ' b' . In the second test case: Alice changes the first letter to ' a' , then Bob changes the second letter to ' z' , Alice changes the third letter to ' a' and then Bob changes the fourth letter to ' z' . In the third test case: Alice changes the first letter to ' b' , and then Bob changes the second letter to ' y' .",
    "topics": [
      "games",
      "greedy",
      "strings"
    ]
  },
  {
    "title": "Pattern Matching",
    "url": "https://codeforces.com/problemset/problem/1476/E",
    "history": "You are given n patterns p_ 1, p_ 2, . . . , p_ n and m strings s_ 1, s_ 2, . . . , s_ m . Each pattern p_ i consists of k characters that are either lowercase Latin letters or wildcard characters ( denoted by underscores) . All patterns are pairwise distinct. Each string s_ j consists of k lowercase Latin letters. A string a matches a pattern b if for each i from 1 to k either b_ i is a wildcard character or b_ i= a_ i . You are asked to rearrange the patterns in such a way that the first pattern the j - th string matches is p[ mt_ j] . You are allowed to leave the order of the patterns unchanged. Can you perform such a rearrangement? If you can, then print any valid order.",
    "input": "The first line contains three integers n , m and k ( 1 \u2264 n, m \u2264 10^ 5 , 1 \u2264 k \u2264 4 ) \u2014 the number of patterns, the number of strings and the length of each pattern and string. Each of the next n lines contains a pattern \u2014 k characters that are either lowercase Latin letters or underscores. All patterns are pairwise distinct. Each of the next m lines contains a string \u2014 k lowercase Latin letters, and an integer mt ( 1 \u2264 mt \u2264 n ) \u2014 the index of the first pattern the corresponding string should match.",
    "output": "Print \" NO\" if there is no way to rearrange the patterns in such a way that the first pattern that the j - th string matches is p[ mt_ j] . Otherwise, print \" YES\" in the first line. The second line should contain n distinct integers from 1 to n \u2014 the order of the patterns. If there are multiple answers, print any of them.",
    "note": "The order of patterns after the rearrangement in the first example is the following: aaaa _ _ b_ ab_ _ _ bcd _ b_ d Thus, the first string matches patterns ab_ _ , _ bcd, _ b_ d in that order, the first of them is ab_ _ , that is indeed p[ 4] . The second string matches _ _ b_ and ab_ _ , the first of them is _ _ b_ , that is p[ 2] . The last string matches _ bcd and _ b_ d, the first of them is _ bcd, that is p[ 5] . The answer to that test is not unique, other valid orders also exist. In the second example cba doesn' t match _ _ c, thus, no valid order exists. In the third example the order ( a_ , _ b) makes both strings match pattern 1 first and the order ( _ b, a_ ) makes both strings match pattern 2 first. Thus, there is no order that produces the result 1 and 2 .",
    "topics": [
      "bitmasks",
      "data structures",
      "dfs and similar",
      "graphs",
      "hashing",
      "sortings",
      "strings"
    ]
  },
  {
    "title": "Program",
    "url": "https://codeforces.com/problemset/problem/1473/D",
    "history": "You are given a program that consists of n instructions. Initially a single variable x is assigned to 0 . Afterwards, the instructions are of two types: increase x by 1 ; decrease x by 1 . You are given m queries of the following format: query l r \u2014 how many distinct values is x assigned to if all the instructions between the l - th one and the r - th one inclusive are ignored and the rest are executed without changing the order?",
    "input": "The first line contains a single integer t ( 1 \u2264 t \u2264 1000 ) \u2014 the number of testcases. Then the description of t testcases follows. The first line of each testcase contains two integers n and m ( 1 \u2264 n, m \u2264 2 \u00b7 10^ 5 ) \u2014 the number of instructions in the program and the number of queries. The second line of each testcase contains a program \u2014 a string of n characters: each character is either ' + ' or ' - ' \u2014 increment and decrement instruction, respectively. Each of the next m lines contains two integers l and r ( 1 \u2264 l \u2264 r \u2264 n ) \u2014 the description of the query. The sum of n over all testcases doesn' t exceed 2 \u00b7 10^ 5 . The sum of m over all testcases doesn' t exceed 2 \u00b7 10^ 5 .",
    "output": "For each testcase print m integers \u2014 for each query l , r print the number of distinct values variable x is assigned to if all the instructions between the l - th one and the r - th one inclusive are ignored and the rest are executed without changing the order.",
    "note": "The instructions that remain for each query of the first testcase are: empty program \u2014 x was only equal to 0 ; \" - \" \u2014 x had values 0 and - 1 ; \" \u2014+ \" \u2014 x had values 0 , - 1 , - 2 , - 3 , - 2 \u2014 there are 4 distinct values among them; \" + \u2013+ \u2013+ \" \u2014 the distinct values are 1 , 0 , - 1 , - 2 .",
    "topics": [
      "data structures",
      "dp",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "String LCM",
    "url": "https://codeforces.com/problemset/problem/1473/B",
    "history": "Let' s define a multiplication operation between a string a and a positive integer x : a \u00b7 x is the string that is a result of writing x copies of a one after another. For example, \" abc\" \u00b7 2 = \" abcabc\" , \" a\" \u00b7 5 = \" aaaaa\" . A string a is divisible by another string b if there exists an integer x such that b \u00b7 x = a . For example, \" abababab\" is divisible by \" ab\" , but is not divisible by \" ababab\" or \" aa\" . LCM of two strings s and t ( defined as LCM( s, t) ) is the shortest non- empty string that is divisible by both s and t . You are given two strings s and t . Find LCM( s, t) or report that it does not exist. It can be shown that if LCM( s, t) exists, it is unique.",
    "input": "The first line contains one integer q ( 1 \u2264 q \u2264 2000 ) \u2014 the number of test cases. Each test case consists of two lines, containing strings s and t ( 1 \u2264 | s| , | t| \u2264 20 ) . Each character in each of these strings is either ' a' or ' b' .",
    "output": "For each test case, print LCM( s, t) if it exists; otherwise, print - 1. It can be shown that if LCM( s, t) exists, it is unique.",
    "note": "In the first test case, \" baba\" = \" baba\" \u00b7 1 = \" ba\" \u00b7 2 . In the second test case, \" aaaaaa\" = \" aa\" \u00b7 3 = \" aaa\" \u00b7 2 .",
    "topics": [
      "brute force",
      "math",
      "number theory",
      "strings"
    ]
  },
  {
    "title": "A Bit Similar",
    "url": "https://codeforces.com/problemset/problem/1469/E",
    "history": "Let' s call two strings a and b ( both of length k ) a bit similar if they have the same character in some position, i. e. there exists at least one i \u2208 [ 1, k] such that a_ i = b_ i . You are given a binary string s of length n ( a string of n characters 0 and/ or 1) and an integer k . Let' s denote the string s[ i. . j] as the substring of s starting from the i - th character and ending with the j - th character ( that is, s[ i. . j] = s_ i s_ i + 1 s_ i + 2. . . s_ j - 1 s_ j ) . Let' s call a binary string t of length k beautiful if it is a bit similar to all substrings of s having length exactly k ; that is, it is a bit similar to s[ 1. . k] , s[ 2. . k+ 1] , . . . , s[ n- k+ 1. . n] . Your goal is to find the lexicographically smallest string t that is beautiful, or report that no such string exists. String x is lexicographically less than string y if either x is a prefix of y ( and x y ) , or there exists such i ( 1 \u2264 i \u2264min( | x| , | y| ) ) , that x_ i < y_ i , and for any j ( 1 \u2264 j < i ) x_ j = y_ j .",
    "input": "The first line contains one integer q ( 1 \u2264 q \u2264 10000 ) \u2014 the number of test cases. Each test case consists of two lines. The first line of each test case contains two integers n and k ( 1 \u2264 k \u2264 n \u2264 10^ 6 ) . The second line contains the string s , consisting of n characters ( each character is either 0 or 1) . It is guaranteed that the sum of n over all test cases does not exceed 10^ 6 .",
    "output": "For each test case, print the answer as follows: if it is impossible to construct a beautiful string, print one line containing the string NO ( note: exactly in upper case, you can' t print No, for example) ; otherwise, print two lines. The first line should contain the string YES ( exactly in upper case as well) ; the second line \u2014 the lexicographically smallest beautiful string, consisting of k characters 0 and/ or 1.",
    "note": "",
    "topics": [
      "bitmasks",
      "brute force",
      "hashing",
      "string suffix structures",
      "strings",
      "two pointers"
    ]
  },
  {
    "title": "Song of the Sirens",
    "url": "https://codeforces.com/problemset/problem/1466/G",
    "history": "Whoso in ignorance draws near to them and hears the Sirens' voice, he nevermore returns. Homer, OdysseyIn the times of Jason and the Argonauts, it was well known that sirens use the sound of their songs to lure sailors into their demise. Yet only a few knew that every time sirens call a sailor by his name, his will weakens, making him more vulnerable. For the purpose of this problem, both siren songs and names of the sailors will be represented as strings of lowercase English letters. The more times the sailor' s name occurs as a contiguous substring of the song, the greater danger he is in. Jason found out that sirens can sing one of the n+ 1 songs, which have the following structure: let s_ i ( 0 \u2264 i \u2264 n ) be the i - th song and t be a string of length n , then for every i < n : s_ i+ 1 = s_ i t_ i s_ i . In other words i+ 1 - st song is the concatenation of i - th song, i - th letter ( 0 - indexed) of t and the i - th song. Fortunately, he also knows s_ 0 and t . Jason wonders how many times a sailor' s name is mentioned in a particular song. Answer q queries: given the sailor' s name ( w ) and the index of a song ( i ) output the number of occurrences of w in s_ i as a substring. As this number can be quite large, output its remainder modulo 10^ 9+ 7 .",
    "input": "In the first line of input there are two integers n , q ( 1 \u2264 n, q \u2264 10^ 5 ) meaning that there are n+ 1 songs and q queries. In the next two lines strings s_ 0 and t follow ( 1 \u2264 | s_ 0| \u2264 100, | t| = n ) . Next q lines describe the queries; each one contains an integer k ( 0 \u2264 k \u2264 n ) , the index of the song sung by the sirens, and a non- empty string w , which is the name of a sailor. All strings in this problem consist only of lowercase English letters, and the sum of lengths of sailors' names does not exceed 10^ 6 .",
    "output": "Output q lines, i - th of them should contain the remainder modulo 10^ 9+ 7 of the number of occurrences of w in s_ k .",
    "note": "In the first example songs of the sirens are as follows: Song 0 : aa Song 1 : aabaa Song 2 : aabaacaabaa Song 3 : aabaacaabaadaabaacaabaa",
    "topics": [
      "combinatorics",
      "divide and conquer",
      "hashing",
      "math",
      "string suffix structures",
      "strings"
    ]
  },
  {
    "title": "Canine poetry",
    "url": "https://codeforces.com/problemset/problem/1466/C",
    "history": "After his wife' s tragic death, Eurydice, Orpheus descended to the realm of death to see her. Reaching its gates was uneasy, but passing through them proved to be even more challenging. Mostly because of Cerberus, the three- headed hound of Hades. Orpheus, a famous poet, and musician plans to calm Cerberus with his poetry and safely walk past him. He created a very peculiar poem for Cerberus. It consists only of lowercase English letters. We call a poem' s substring a palindrome if and only if it reads the same backwards and forwards. A string a is a substring of a string b if a can be obtained from b by deleting several ( possibly zero or all) characters from the beginning and several ( possibly zero or all) characters from the end. Unfortunately, Cerberus dislikes palindromes of length greater than 1 . For example in the poem abaa the hound of Hades wouldn' t like substrings aba and aa. Orpheus can only calm Cerberus if the hound likes his poetry. That' s why he wants to change his poem so that it does not contain any palindrome substrings of length greater than 1 . Orpheus can modify the poem by replacing a letter at any position with any lowercase English letter. He can use this operation arbitrarily many times ( possibly zero) . Since there can be many palindromes in his poem, he may have to make some corrections. But how many, exactly? Given the poem, determine the minimal number of letters that have to be changed so that the poem does not contain any palindromes of length greater than 1 .",
    "input": "The first line of the input contains a single integer t ( 1 \u2264 t \u2264 10^ 5 ) denoting the number of test cases, then t test cases follow. The first and only line of each test case contains a non- empty string of lowercase English letters, Orpheus' poem. The sum of the length of Orpheus' poems in all test cases will not exceed 10^ 5 .",
    "output": "You should output t lines, i - th line should contain a single integer, answer to the i - th test case.",
    "note": "In the first test case, we can replace the third character with c and obtain a palindrome- less poem bacba. In the second test case, we can replace the third character with d and obtain a palindrome- less poem abdac. In the third test case, the initial poem already doesn' t contain any palindromes, so Orpheus doesn' t need to change anything there.",
    "topics": [
      "dp",
      "greedy",
      "strings"
    ]
  },
  {
    "title": "Last Year's Substring",
    "url": "https://codeforces.com/problemset/problem/1462/B",
    "history": "Polycarp has a string s[ 1 . . . n] of length n consisting of decimal digits. Polycarp performs the following operation with the string s no more than once ( i. e. he can perform operation 0 or 1 time) : Polycarp selects two numbers i and j ( 1 \u2264 i \u2264 j \u2264 n ) and removes characters from the s string at the positions i, i+ 1, i+ 2, . . . , j ( i. e. removes substring s[ i . . . j] ) . More formally, Polycarp turns the string s into the string s_ 1 s_ 2 . . . s_ i- 1 s_ j+ 1 s_ j+ 2. . . s_ n . For example, the string s = \" 20192020\" Polycarp can turn into strings: \" 2020\" ( in this case ( i, j) = ( 3, 6) or ( i, j) = ( 1, 4) ) ; \" 2019220\" ( in this case ( i, j) = ( 6, 6) ) ; \" 020\" ( in this case ( i, j) = ( 1, 5) ) ; other operations are also possible, only a few of them are listed above. Polycarp likes the string \" 2020\" very much, so he is wondering if it is possible to turn the string s into a string \" 2020\" in no more than one operation? Note that you can perform zero operations.",
    "input": "The first line contains a positive integer t ( 1 \u2264 t \u2264 1000 ) \u2014 number of test cases in the test. Then t test cases follow. The first line of each test case contains an integer n ( 4 \u2264 n \u2264 200 ) \u2014 length of the string s . The next line contains a string s of length n consisting of decimal digits. It is allowed that the string s starts with digit 0.",
    "output": "For each test case, output on a separate line: \" YES\" if Polycarp can turn the string s into a string \" 2020\" in no more than one operation ( i. e. he can perform 0 or 1 operation) ; \" NO\" otherwise. You may print every letter of \" YES\" and \" NO\" in any case you want ( so, for example, the strings yEs, yes, Yes and YES will all be recognized as positive answer) .",
    "note": "In the first test case, Polycarp could choose i= 3 and j= 6 . In the second test case, Polycarp could choose i= 2 and j= 5 . In the third test case, Polycarp did not perform any operations with the string.",
    "topics": [
      "dp",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "String Equality",
    "url": "https://codeforces.com/problemset/problem/1451/C",
    "history": "Ashish has two strings a and b , each of length n , and an integer k . The strings only contain lowercase English letters. He wants to convert string a into string b by performing some ( possibly zero) operations on a . In one move, he can either choose an index i ( 1 \u2264 i\u2264 n- 1 ) and swap a_ i and a_ i+ 1 , or choose an index i ( 1 \u2264 i \u2264 n- k+ 1 ) and if a_ i, a_ i+ 1, . . . , a_ i+ k- 1 are all equal to some character c ( c = \u0338 ' z' ) , replace each one with the next character ( c+ 1) , that is, ' a' is replaced by ' b' , ' b' is replaced by ' c' and so on. Note that he can perform any number of operations, and the operations can only be performed on string a . Help Ashish determine if it is possible to convert string a into b after performing some ( possibly zero) operations on it.",
    "input": "The first line contains a single integer t ( 1 \u2264 t \u2264 10^ 5 ) \u2014 the number of test cases. The description of each test case is as follows. The first line of each test case contains two integers n ( 2 \u2264 n \u2264 10^ 6 ) and k ( 1 \u2264 k \u2264 n ) . The second line of each test case contains the string a of length n consisting of lowercase English letters. The third line of each test case contains the string b of length n consisting of lowercase English letters. It is guaranteed that the sum of values n among all test cases does not exceed 10^ 6 .",
    "output": "For each test case, print \" Yes\" if Ashish can convert a into b after some moves, else print \" No\" . You may print the letters of the answer in any case ( upper or lower) .",
    "note": "In the first test case it can be shown that it is impossible to convert a into b . In the second test case, \" abba\" \" acca\" . . . \" azza\" . Here \" swap\" denotes an operation of the first type, and \" inc\" denotes an operation of the second type. In the fourth test case, \" aaabba\" \" aaabab\" \" aaaabb\" . . . \" ddaabb\" . . . \" ddddbb\" . . . \" ddddcc\" .",
    "topics": [
      "dp",
      "greedy",
      "hashing",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Non-Substring Subsequence",
    "url": "https://codeforces.com/problemset/problem/1451/B",
    "history": "Hr0d1y has q queries on a binary string s of length n . A binary string is a string containing only characters ' 0' and ' 1' . A query is described by a pair of integers l_ i , r_ i ( 1 \u2264 l_ i r_ i \u2264 n) . For each query, he has to determine whether there exists a good subsequence in s that is equal to the substring s[ l_ i. . . r_ i] . A substring s[ i. . . j] of a string s is the string formed by characters s_ i s_ i+ 1. . . s_ j . String a is said to be a subsequence of string b if a can be obtained from b by deleting some characters without changing the order of the remaining characters. A subsequence is said to be good if it is not contiguous and has length \u2265 2 . For example, if s is \" 1100110\" , then the subsequences s_ 1s_ 2s_ 4 ( \" 1100110\" ) and s_ 1s_ 5s_ 7 ( \" 1100110\" ) are good, while s_ 1s_ 2s_ 3 ( \" 1100110\" ) is not good. Can you help Hr0d1y answer each query?",
    "input": "The first line of the input contains a single integer t ( 1\u2264 t \u2264 100 ) \u2014 the number of test cases. The description of each test case is as follows. The first line contains two integers n ( 2 \u2264 n \u2264 100 ) and q ( 1\u2264 q \u2264 100 ) \u2014 the length of the string and the number of queries. The second line contains the string s . The i - th of the next q lines contains two integers l_ i and r_ i ( 1 \u2264 l_ i r_ i \u2264 n ) .",
    "output": "For each test case, output q lines. The i - th line of the output of each test case should contain \" YES\" if there exists a good subsequence equal to the substring s[ l_ i. . . r_ i] , and \" NO\" otherwise. You may print each letter in any case ( upper or lower) .",
    "note": "In the first test case, s[ 2. . . 4] = \" 010\" . In this case s_ 1s_ 3s_ 5 ( \" 001000\" ) and s_ 2s_ 3s_ 6 ( \" 001000\" ) are good suitable subsequences, while s_ 2s_ 3s_ 4 ( \" 001000\" ) is not good. s[ 1. . . 3] = \" 001\" . No suitable good subsequence exists. s[ 3. . . 5] = \" 100\" . Here s_ 3s_ 5s_ 6 ( \" 001000\" ) is a suitable good subsequence.",
    "topics": [
      "dp",
      "greedy",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Catching Cheaters",
    "url": "https://codeforces.com/problemset/problem/1446/B",
    "history": "You are given two strings A and B representing essays of two students who are suspected cheaters. For any two strings C , D we define their similarity score S( C, D) as 4\u00b7 LCS( C, D) - | C| - | D| , where LCS( C, D) denotes the length of the Longest Common Subsequence of strings C and D . You believe that only some part of the essays could have been copied, therefore you' re interested in their substrings. Calculate the maximal similarity score over all pairs of substrings. More formally, output maximal S( C, D) over all pairs ( C, D) , where C is some substring of A , and D is some substring of B . If X is a string, | X| denotes its length. A string a is a substring of a string b if a can be obtained from b by deletion of several ( possibly, zero or all) characters from the beginning and several ( possibly, zero or all) characters from the end. A string a is a subsequence of a string b if a can be obtained from b by deletion of several ( possibly, zero or all) characters. Pay attention to the difference between the substring and subsequence, as they both appear in the problem statement. You may wish to read the Wikipedia page about the Longest Common Subsequence problem.",
    "input": "The first line contains two positive integers n and m ( 1 \u2264 n, m \u2264 5000 ) \u2014 lengths of the two strings A and B . The second line contains a string consisting of n lowercase Latin letters \u2014 string A . The third line contains a string consisting of m lowercase Latin letters \u2014 string B .",
    "output": "Output maximal S( C, D) over all pairs ( C, D) , where C is some substring of A , and D is some substring of B .",
    "note": "For the first case: abb from the first string and abab from the second string have LCS equal to abb. The result is S( abb, abab) = ( 4 \u00b7 | abb| ) - | abb| - | abab| = 4 \u00b7 3 - 3 - 4 = 5 .",
    "topics": [
      "dp",
      "strings"
    ]
  },
  {
    "title": "Death DBMS",
    "url": "https://codeforces.com/problemset/problem/1437/G",
    "history": "For the simplicity, let' s say that the \" Death Note\" is a notebook that kills a person when their name is written in it. It' s easy to kill with it, but it' s pretty hard to keep track of people you haven' t killed and still plan to. You decided to make a \" Death Database Management System\" \u2014 a computer program that provides the easy access to the database of possible victims. Let me describe its specifications to you. Let' s define a victim entity: a victim has a name ( not necessarily unique) that consists only of lowercase Latin letters and an integer suspicion value. At the start of the program the user enters a list of n victim names into a database, each suspicion value is set to 0 . Then the user makes queries of two types: 1 i x \u2014 set the suspicion value of the i - th victim to x ; 2 q \u2014 given a string q find the maximum suspicion value of a victim whose name is a contiguous substring of q . Just to remind you, this program doesn' t kill people, it only helps to search for the names to write down in an actual notebook. Thus, the list of the victims in the database doesn' t change throughout the queries. What are you waiting for? Write that program now!",
    "input": "The first line contains two integers n and m ( 1 \u2264 n, m \u2264 3 \u00b7 10^ 5 ) \u2014 the number of victims and the number of queries, respectively. Each of the next n lines contains a single string s_ i \u2014 the name of the i - th victim. Each name consists only of lowercase Latin letters. Each of the next m lines contains a query of one of two types: 1 i x ( 1 \u2264 i \u2264 n , 0 \u2264 x \u2264 10^ 9 ) \u2014 change the suspicion value of the i - th victim to x ; 2 q \u2014 given a string q consisting only of lowercase Latin letters find the maximum suspicion value of a victim whose name is a contiguous substring of q . There is at least one query of the second type. The total length of the strings s_ i doesn' t exceed 3 \u00b7 10^ 5 . The total length of the strings q doesn' t exceed 3 \u00b7 10^ 5 .",
    "output": "For each query of the second type print an integer value. If there is no victim name that is a contiguous substring of q , then print - 1 . Otherwise, print the maximum suspicion value of a victim whose name is a contiguous substring of q .",
    "note": "",
    "topics": [
      "data structures",
      "string suffix structures",
      "strings",
      "trees"
    ]
  },
  {
    "title": "Cyclic Shifts",
    "url": "https://codeforces.com/problemset/problem/1431/I",
    "history": "You are given a matrix consisting of n rows and m columns. The matrix contains lowercase letters of the Latin alphabet. You can perform the following operation any number of times you want to: choose two integers i ( 1 \u2264 i \u2264 m ) and k ( 0 < k < n ) , and shift every column j such that i \u2264 j \u2264 m cyclically by k . The shift is performed upwards. For example, if you have a matrix ( [ a b c; d e f; g h i ] ) and perform an operation with i = 2 , k = 1 , then it becomes: ( [ a e f; d h i; g b c ] ) You have to process q queries. Each of the queries is a string of length m consisting of lowercase letters of the Latin alphabet. For each query, you have to calculate the minimum number of operations described above you have to perform so that at least one row of the matrix is equal to the string from the query. Note that all queries are independent, that is, the operations you perform in a query don' t affect the initial matrix in other queries.",
    "input": "The first line contains three integers n , m , q ( 2 \u2264 n, m, q \u2264 2. 5 \u00b7 10^ 5 ; n \u00b7 m \u2264 5 \u00b7 10^ 5 ; q \u00b7 m \u2264 5 \u00b7 10^ 5 ) \u2014 the number of rows and columns in the matrix and the number of queries, respectively. The next n lines contains m lowercase Latin letters each \u2014 elements of the matrix. The following q lines contains a description of queries \u2014 strings of length m consisting of lowercase letters of the Latin alphabet.",
    "output": "Print q integers. The i - th integer should be equal to the minimum number of operations you have to perform so that the matrix contains a string from the i - th query or - 1 if the specified string cannot be obtained.",
    "note": "",
    "topics": [
      "*special",
      "strings"
    ]
  },
  {
    "title": "String Reversal",
    "url": "https://codeforces.com/problemset/problem/1430/E",
    "history": "You are given a string s . You have to reverse it \u2014 that is, the first letter should become equal to the last letter before the reversal, the second letter should become equal to the second- to- last letter before the reversal \u2014 and so on. For example, if your goal is to reverse the string \" abddea\" , you should get the string \" aeddba\" . To accomplish your goal, you can swap the neighboring elements of the string. Your task is to calculate the minimum number of swaps you have to perform to reverse the given string.",
    "input": "The first line contains one integer n ( 2 \u2264 n \u2264 200 000 ) \u2014 the length of s . The second line contains s \u2014 a string consisting of n lowercase Latin letters.",
    "output": "Print one integer \u2014 the minimum number of swaps of neighboring elements you have to perform to reverse the string.",
    "note": "In the first example, you have to swap the third and the fourth elements, so the string becomes \" aazaa\" . Then you have to swap the second and the third elements, so the string becomes \" azaaa\" . So, it is possible to reverse the string in two swaps. Since the string in the second example is a palindrome, you don' t have to do anything to reverse it.",
    "topics": [
      "data structures",
      "greedy",
      "strings"
    ]
  },
  {
    "title": "ABBB",
    "url": "https://codeforces.com/problemset/problem/1428/C",
    "history": "Zookeeper is playing a game. In this game, Zookeeper must use bombs to bomb a string that consists of letters ' A' and ' B' . He can use bombs to bomb a substring which is either \" AB\" or \" BB\" . When he bombs such a substring, the substring gets deleted from the string and the remaining parts of the string get concatenated. For example, Zookeeper can use two such operations: AABABBA \u2192 AABBA \u2192 AAA. Zookeeper wonders what the shortest string he can make is. Can you help him find the length of the shortest string?",
    "input": "Each test contains multiple test cases. The first line contains a single integer t ( 1 \u2264 t \u2264 20000) \u2014 the number of test cases. The description of the test cases follows. Each of the next t lines contains a single test case each, consisting of a non- empty string s : the string that Zookeeper needs to bomb. It is guaranteed that all symbols of s are either ' A' or ' B' . It is guaranteed that the sum of | s| ( length of s ) among all test cases does not exceed 2 \u00b7 10^ 5 .",
    "output": "For each test case, print a single integer: the length of the shortest string that Zookeeper can make.",
    "note": "For the first test case, you can' t make any moves, so the answer is 3 . For the second test case, one optimal sequence of moves is BABA \u2192 BA. So, the answer is 2 . For the third test case, one optimal sequence of moves is AABBBABBBB \u2192 AABBBABB \u2192 AABBBB \u2192 ABBB \u2192 AB \u2192 ( empty string) . So, the answer is 0 .",
    "topics": [
      "brute force",
      "data structures",
      "greedy",
      "strings"
    ]
  },
  {
    "title": "Number of Subsequences",
    "url": "https://codeforces.com/problemset/problem/1426/F",
    "history": "You are given a string s consisting of lowercase Latin letters \" a\" , \" b\" and \" c\" and question marks \" ? \" . Let the number of question marks in the string s be k . Let' s replace each question mark with one of the letters \" a\" , \" b\" and \" c\" . Here we can obtain all 3^ k possible strings consisting only of letters \" a\" , \" b\" and \" c\" . For example, if s = \" ac? b? c\" then we can obtain the following strings: [ \" acabac\" , \" acabbc\" , \" acabcc\" , \" acbbac\" , \" acbbbc\" , \" acbbcc\" , \" accbac\" , \" accbbc\" , \" accbcc\" ] . Your task is to count the total number of subsequences \" abc\" in all resulting strings. Since the answer can be very large, print it modulo 10^ 9 + 7 . A subsequence of the string t is such a sequence that can be derived from the string t after removing some ( possibly, zero) number of letters without changing the order of remaining letters. For example, the string \" baacbc\" contains two subsequences \" abc\" \u2014 a subsequence consisting of letters at positions ( 2, 5, 6) and a subsequence consisting of letters at positions ( 3, 5, 6) .",
    "input": "The first line of the input contains one integer n ( 3 \u2264 n \u2264 200 000) \u2014 the length of s . The second line of the input contains the string s of length n consisting of lowercase Latin letters \" a\" , \" b\" and \" c\" and question marks\" ? \" .",
    "output": "Print the total number of subsequences \" abc\" in all strings you can obtain if you replace all question marks with letters \" a\" , \" b\" and \" c\" , modulo 10^ 9 + 7 .",
    "note": "In the first example, we can obtain 9 strings: \" acabac\" \u2014 there are 2 subsequences \" abc\" , \" acabbc\" \u2014 there are 4 subsequences \" abc\" , \" acabcc\" \u2014 there are 4 subsequences \" abc\" , \" acbbac\" \u2014 there are 2 subsequences \" abc\" , \" acbbbc\" \u2014 there are 3 subsequences \" abc\" , \" acbbcc\" \u2014 there are 4 subsequences \" abc\" , \" accbac\" \u2014 there is 1 subsequence \" abc\" , \" accbbc\" \u2014 there are 2 subsequences \" abc\" , \" accbcc\" \u2014 there are 2 subsequences \" abc\" . So, there are 2 + 4 + 4 + 2 + 3 + 4 + 1 + 2 + 2 = 24 subsequences \" abc\" in total.",
    "topics": [
      "combinatorics",
      "dp",
      "strings"
    ]
  },
  {
    "title": "Minlexes",
    "url": "https://codeforces.com/problemset/problem/1422/E",
    "history": "Some time ago Lesha found an entertaining string s consisting of lowercase English letters. Lesha immediately developed an unique algorithm for this string and shared it with you. The algorithm is as follows. Lesha chooses an arbitrary ( possibly zero) number of pairs on positions ( i, i + 1) in such a way that the following conditions are satisfied: for each pair ( i, i + 1) the inequality 0 \u2264 i < | s| - 1 holds; for each pair ( i, i + 1) the equality s_ i = s_ i + 1 holds; there is no index that is contained in more than one pair. After that Lesha removes all characters on indexes contained in these pairs and the algorithm is over. Lesha is interested in the lexicographically smallest strings he can obtain by applying the algorithm to the suffixes of the given string.",
    "input": "The only line contains the string s ( 1 \u2264 | s| \u2264 10^ 5 ) \u2014 the initial string consisting of lowercase English letters only.",
    "output": "In | s| lines print the lengths of the answers and the answers themselves, starting with the answer for the longest suffix. The output can be large, so, when some answer is longer than 10 characters, instead print the first 5 characters, then \" . . . \" , then the last 2 characters of the answer.",
    "note": "Consider the first example. The longest suffix is the whole string \" abcdd\" . Choosing one pair ( 4, 5) , Lesha obtains \" abc\" . The next longest suffix is \" bcdd\" . Choosing one pair ( 3, 4) , we obtain \" bc\" . The next longest suffix is \" cdd\" . Choosing one pair ( 2, 3) , we obtain \" c\" . The next longest suffix is \" dd\" . Choosing one pair ( 1, 2) , we obtain \" \" ( an empty string) . The last suffix is the string \" d\" . No pair can be chosen, so the answer is \" d\" . In the second example, for the longest suffix \" abbcdddeaaffdfouurtytwoo\" choose three pairs ( 11, 12) , ( 16, 17) , ( 23, 24) and we obtain \" abbcdddeaadfortytw\"",
    "topics": [
      "dp",
      "greedy",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Palindromifier",
    "url": "https://codeforces.com/problemset/problem/1421/C",
    "history": "Ringo found a string s of length n in his yellow submarine. The string contains only lowercase letters from the English alphabet. As Ringo and his friends love palindromes, he would like to turn the string s into a palindrome by applying two types of operations to the string. The first operation allows him to choose i ( 2 \u2264 i \u2264 n- 1 ) and to append the substring s_ 2s_ 3 . . . s_ i ( i - 1 characters) reversed to the front of s . The second operation allows him to choose i ( 2 \u2264 i \u2264 n- 1 ) and to append the substring s_ i s_ i + 1. . . s_ n - 1 ( n - i characters) reversed to the end of s . Note that characters in the string in this problem are indexed from 1 . For example suppose s= abcdef. If he performs the first operation with i= 3 then he appends cb to the front of s and the result will be cbabcdef. Performing the second operation on the resulted string with i= 5 will yield cbabcdefedc. Your task is to help Ringo make the entire string a palindrome by applying any of the two operations ( in total) at most 30 times. The length of the resulting palindrome must not exceed 10^ 6 It is guaranteed that under these constraints there always is a solution. Also note you do not have to minimize neither the number of operations applied, nor the length of the resulting string, but they have to fit into the constraints.",
    "input": "The only line contains the string S ( 3 \u2264 | s| \u2264 10^ 5 ) of lowercase letters from the English alphabet.",
    "output": "The first line should contain k ( 0\u2264 k \u2264 30 ) \u2014 the number of operations performed. Each of the following k lines should describe an operation in form L i or R i. L represents the first operation, R represents the second operation, i represents the index chosen. The length of the resulting palindrome must not exceed 10^ 6 .",
    "note": "For the first example the following operations are performed: abac \u2192 abacab \u2192 abacabaThe second sample performs the following operations: acccc \u2192 cccacccc \u2192 ccccaccccThe third example is already a palindrome so no operations are required.",
    "topics": [
      "constructive algorithms",
      "strings"
    ]
  },
  {
    "title": "XOR Inverse",
    "url": "https://codeforces.com/problemset/problem/1416/C",
    "history": "You are given an array a consisting of n non- negative integers. You have to choose a non- negative integer x and form a new array b of size n according to the following rule: for all i from 1 to n , b_ i = a_ i \u2295 x ( \u2295 denotes the operation bitwise XOR) . An inversion in the b array is a pair of integers i and j such that 1 \u2264 i < j \u2264 n and b_ i > b_ j . You should choose x in such a way that the number of inversions in b is minimized. If there are several options for x \u2014 output the smallest one.",
    "input": "First line contains a single integer n ( 1 \u2264 n \u2264 3 \u00b7 10^ 5 ) \u2014 the number of elements in a . Second line contains n space- separated integers a_ 1 , a_ 2 , . . . , a_ n ( 0 \u2264 a_ i \u2264 10^ 9 ) , where a_ i is the i - th element of a .",
    "output": "Output two integers: the minimum possible number of inversions in b , and the minimum possible value of x , which achieves those number of inversions.",
    "note": "In the first sample it is optimal to leave the array as it is by choosing x = 0 . In the second sample the selection of x = 14 results in b : [ 4, 9, 7, 4, 9, 11, 11, 13, 11] . It has 4 inversions: i = 2 , j = 3 ; i = 2 , j = 4 ; i = 3 , j = 4 ; i = 8 , j = 9 . In the third sample the selection of x = 8 results in b : [ 0, 2, 11] . It has no inversions.",
    "topics": [
      "bitmasks",
      "data structures",
      "divide and conquer",
      "dp",
      "greedy",
      "math",
      "sortings",
      "strings",
      "trees"
    ]
  },
  {
    "title": "Poman Numbers",
    "url": "https://codeforces.com/problemset/problem/1411/E",
    "history": "You' ve got a string S consisting of n lowercase English letters from your friend. It turned out that this is a number written in poman numerals. The poman numeral system is long forgotten. All that' s left is the algorithm to transform number from poman numerals to the numeral system familiar to us. Characters of S are numbered from 1 to n from left to right. Let' s denote the value of S as f( S) , it is defined as follows: If | S| > 1 , an arbitrary integer m ( 1 \u2264 m < | S| ) is chosen, and it is defined that f( S) = - f( S[ 1, m] ) + f( S[ m + 1, | S| ] ) , where S[ l, r] denotes the substring of S from the l - th to the r - th position, inclusively. Otherwise S = c , where c is some English letter. Then f( S) = 2^ pos( c) , where pos( c) is the position of letter c in the alphabet ( pos( a ) = 0 , pos( z ) = 25 ) . Note that m is chosen independently on each step. Your friend thinks it is possible to get f( S) = T by choosing the right m on every step. Is he right?",
    "input": "The first line contains two integers n and T ( 2 \u2264 n \u2264 10^ 5 , - 10^ 15\u2264 T \u2264 10^ 15 ) . The second line contains a string S consisting of n lowercase English letters.",
    "output": "Print \" Yes\" if it is possible to get the desired value. Otherwise, print \" No\" . You can print each letter in any case ( upper or lower) .",
    "note": "In the second example, you cannot get - 7 . But you can get 1 , for example, as follows: First choose m = 1 , then f( abc ) = - f( a ) + f( bc ) f( a ) = 2^ 0 = 1 f( bc ) = - f( b ) + f( c ) = - 2^ 1 + 2^ 2 = 2 In the end f( abc ) = - 1 + 2 = 1",
    "topics": [
      "bitmasks",
      "greedy",
      "math",
      "strings"
    ]
  },
  {
    "title": "Grime Zoo",
    "url": "https://codeforces.com/problemset/problem/1411/D",
    "history": "Currently, XXOC' s rap is a string consisting of zeroes, ones, and question marks. Unfortunately, haters gonna hate. They will write x angry comments for every occurrence of subsequence 01 and y angry comments for every occurrence of subsequence 10. You should replace all the question marks with 0 or 1 in such a way that the number of angry comments would be as small as possible. String b is a subsequence of string a , if it can be obtained by removing some characters from a . Two occurrences of a subsequence are considered distinct if sets of positions of remaining characters are distinct.",
    "input": "The first line contains string s \u2014 XXOC' s rap ( 1 \u2264 | s| \u2264 10^ 5 ) . The second line contains two integers x and y \u2014 the number of angry comments XXOC will recieve for every occurrence of 01 and 10 accordingly ( 0 \u2264 x, y \u2264 10^ 6 ) .",
    "output": "Output a single integer \u2014 the minimum number of angry comments.",
    "note": "In the first example one of the optimum ways to replace is 001. Then there will be 2 subsequences 01 and 0 subsequences 10. Total number of angry comments will be equal to 2 \u00b7 2 + 0 \u00b7 3 = 4 . In the second example one of the optimum ways to replace is 11111. Then there will be 0 subsequences 01 and 0 subsequences 10. Total number of angry comments will be equal to 0 \u00b7 13 + 0 \u00b7 37 = 0 . In the third example one of the optimum ways to replace is 1100. Then there will be 0 subsequences 01 and 4 subsequences 10. Total number of angry comments will be equal to 0 \u00b7 239 + 4 \u00b7 7 = 28 . In the fourth example one of the optimum ways to replace is 01101001. Then there will be 8 subsequences 01 and 8 subsequences 10. Total number of angry comments will be equal to 8 \u00b7 5 + 8 \u00b7 7 = 96 .",
    "topics": [
      "brute force",
      "greedy",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Subsequences of Length Two",
    "url": "https://codeforces.com/problemset/problem/1409/F",
    "history": "You are given two strings s and t consisting of lowercase Latin letters. The length of t is 2 ( i. e. this string consists only of two characters) . In one move, you can choose any character of s and replace it with any lowercase Latin letter. More formally, you choose some i and replace s_ i ( the character at the position i ) with some character from ' a' to ' z' . You want to do no more than k replacements in such a way that maximizes the number of occurrences of t in s as a subsequence. Recall that a subsequence is a sequence that can be derived from the given sequence by deleting zero or more elements without changing the order of the remaining elements.",
    "input": "The first line of the input contains two integers n and k ( 2 \u2264 n \u2264 200 ; 0 \u2264 k \u2264 n ) \u2014 the length of s and the maximum number of moves you can make. The second line of the input contains the string s consisting of n lowercase Latin letters. The third line of the input contains the string t consisting of two lowercase Latin letters.",
    "output": "Print one integer \u2014 the maximum possible number of occurrences of t in s as a subsequence if you replace no more than k characters in s optimally.",
    "note": "In the first example, you can obtain the string \" abab\" replacing s_ 1 with ' a' and s_ 4 with ' b' . Then the answer is 3 . In the second example, you can obtain the string \" ssddsdd\" and get the answer 10 . In the fourth example, you can obtain the string \" aaacaaa\" and get the answer 15 .",
    "topics": [
      "dp",
      "strings"
    ]
  },
  {
    "title": "Balanced Bitstring",
    "url": "https://codeforces.com/problemset/problem/1404/A",
    "history": "A bitstring is a string consisting only of the characters 0 and 1. A bitstring is called k - balanced if every substring of size k of this bitstring has an equal amount of 0 and 1 characters ( k/ 2 of each) . You are given an integer k and a string s which is composed only of characters 0, 1, and ? . You need to determine whether you can make a k - balanced bitstring by replacing every ? characters in s with either 0 or 1. A string a is a substring of a string b if a can be obtained from b by deletion of several ( possibly, zero or all) characters from the beginning and several ( possibly, zero or all) characters from the end.",
    "input": "Each test contains multiple test cases. The first line contains the number of test cases t ( 1 \u2264 t \u2264 10^ 4 ) . Description of the test cases follows. The first line of each test case contains two integers n and k ( 2 \u2264 k \u2264 n \u2264 3 \u00b7 10^ 5 , k is even) \u2014 the length of the string and the parameter for a balanced bitstring. The next line contains the string s ( | s| = n ) . It is given that s consists of only 0, 1, and ? . It is guaranteed that the sum of n over all test cases does not exceed 3 \u00b7 10^ 5 .",
    "output": "For each test case, print YES if we can replace every ? in s with 0 or 1 such that the resulting bitstring is k - balanced, or NO if it is not possible.",
    "note": "For the first test case, the string is already a 4 - balanced bitstring. For the second test case, the string can be transformed into 101. For the fourth test case, the string can be transformed into 0110. For the fifth test case, the string can be transformed into 1100110.",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "x-prime Substrings",
    "url": "https://codeforces.com/problemset/problem/1400/F",
    "history": "You are given an integer value x and a string s consisting of digits from 1 to 9 inclusive. A substring of a string is a contiguous subsequence of that string. Let f( l, r) be the sum of digits of a substring s[ l. . r] . Let' s call substring s[ l_ 1. . r_ 1] x - prime if f( l_ 1, r_ 1) = x ; there are no values l_ 2, r_ 2 such that l_ 1 \u2264 l_ 2 \u2264 r_ 2 \u2264 r_ 1 ; f( l_ 2, r_ 2) = \u0338 x ; x is divisible by f( l_ 2, r_ 2) . You are allowed to erase some characters from the string. If you erase a character, the two resulting parts of the string are concatenated without changing their order. What is the minimum number of characters you should erase from the string so that there are no x - prime substrings in it? If there are no x - prime substrings in the given string s , then print 0 .",
    "input": "The first line contains a string s ( 1 \u2264 | s| \u2264 1000 ) . s contains only digits from 1 to 9 inclusive. The second line contains an integer x ( 1 \u2264 x \u2264 20 ) .",
    "output": "Print a single integer \u2014 the minimum number of characters you should erase from the string so that there are no x - prime substrings in it. If there are no x - prime substrings in the given string s , then print 0 .",
    "note": "In the first example there are two 8 - prime substrings \" 8\" and \" 53\" . You can erase these characters to get rid of both: \" 116285317\" . The resulting string \" 1162317\" contains no 8 - prime substrings. Removing these characters is also a valid answer: \" 116285317\" . In the second example you just have to erase both ones. In the third example there are no 13 - prime substrings. There are no substrings with the sum of digits equal to 13 at all. In the fourth example you can have neither \" 34\" , nor \" 43\" in a string. Thus, you have to erase either all threes or all fours. There are 5 of each of them, so it doesn' t matter which.",
    "topics": [
      "brute force",
      "dfs and similar",
      "dp",
      "string suffix structures",
      "strings"
    ]
  },
  {
    "title": "String Similarity",
    "url": "https://codeforces.com/problemset/problem/1400/A",
    "history": "A binary string is a string where each character is either 0 or 1. Two binary strings a and b of equal length are similar, if they have the same character in some position ( there exists an integer i such that a_ i = b_ i ) . For example: 10010 and 01111 are similar ( they have the same character in position 4 ) ; 10010 and 11111 are similar; 111 and 111 are similar; 0110 and 1001 are not similar. You are given an integer n and a binary string s consisting of 2n- 1 characters. Let' s denote s[ l. . r] as the contiguous substring of s starting with l - th character and ending with r - th character ( in other words, s[ l. . r] = s_ l s_ l + 1 s_ l + 2. . . s_ r ) . You have to construct a binary string w of length n which is similar to all of the following strings: s[ 1. . n] , s[ 2. . n+ 1] , s[ 3. . n+ 2] , . . . , s[ n. . 2n- 1] .",
    "input": "The first line contains a single integer t ( 1 \u2264 t \u2264 1000 ) \u2014 the number of test cases. The first line of each test case contains a single integer n ( 1 \u2264 n \u2264 50 ) . The second line of each test case contains the binary string s of length 2n - 1 . Each character s_ i is either 0 or 1.",
    "output": "For each test case, print the corresponding binary string w of length n . If there are multiple such strings \u2014 print any of them. It can be shown that at least one string w meeting the constraints always exists.",
    "note": "The explanation of the sample case ( equal characters in equal positions are bold) : The first test case: 1 is similar to s[ 1. . 1] = 1 . The second test case: 000 is similar to s[ 1. . 3] = 000 ; 000 is similar to s[ 2. . 4] = 000 ; 000 is similar to s[ 3. . 5] = 000 . The third test case: 1010 is similar to s[ 1. . 4] = 1110 ; 1010 is similar to s[ 2. . 5] = 1100 ; 1010 is similar to s[ 3. . 6] = 1000 ; 1010 is similar to s[ 4. . 7] = 0000 . The fourth test case: 00 is similar to s[ 1. . 2] = 10 ; 00 is similar to s[ 2. . 3] = 01 .",
    "topics": [
      "constructive algorithms",
      "strings"
    ]
  },
  {
    "title": "Juggling Letters",
    "url": "https://codeforces.com/problemset/problem/1397/A",
    "history": "You are given n strings s_ 1, s_ 2, . . . , s_ n consisting of lowercase Latin letters. In one operation you can remove a character from a string s_ i and insert it to an arbitrary position in a string s_ j ( j may be equal to i ) . You may perform this operation any number of times. Is it possible to make all n strings equal?",
    "input": "The first line contains t ( 1 \u2264 t \u2264 10 ) : the number of test cases. The first line of each test case contains a single integer n ( 1 \u2264 n \u2264 1000 ) : the number of strings. n lines follow, the i - th line contains s_ i ( 1 \u2264| s_ i | \u2264 1000 ) . The sum of lengths of all strings in all test cases does not exceed 1000 .",
    "output": "If it is possible to make the strings equal, print \" YES\" ( without quotes) . Otherwise, print \" NO\" ( without quotes) . You can output each character in either lowercase or uppercase.",
    "note": "In the first test case, you can do the following: Remove the third character of the first string and insert it after the second character of the second string, making the two strings \" ca\" and \" cbab\" respectively. Remove the second character of the second string and insert it after the second character of the first string, making both strings equal to \" cab\" . In the second test case, it is impossible to make all n strings equal.",
    "topics": [
      "greedy",
      "strings"
    ]
  },
  {
    "title": "Boboniu and Banknote Collection",
    "url": "https://codeforces.com/problemset/problem/1394/E",
    "history": "No matter what trouble you' re in, don' t be afraid, but face it with a smile. I' ve made another billion dollars! \u2014 BoboniuBoboniu has issued his currencies, named Bobo Yuan. Bobo Yuan ( BBY) is a series of currencies. Boboniu gives each of them a positive integer identifier, such as BBY- 1, BBY- 2, etc. Boboniu has a BBY collection. His collection looks like a sequence. For example: We can use sequence a= [ 1, 2, 3, 3, 2, 1, 4, 4, 1] of length n= 9 to denote it. Now Boboniu wants to fold his collection. You can imagine that Boboniu stick his collection to a long piece of paper and fold it between currencies: Boboniu will only fold the same identifier of currencies together. In other words, if a_ i is folded over a_ j ( 1\u2264 i, j\u2264 n ) , then a_ i= a_ j must hold. Boboniu doesn' t care if you follow this rule in the process of folding. But once it is finished, the rule should be obeyed. A formal definition of fold is described in notes. According to the picture above, you can fold a two times. In fact, you can fold a= [ 1, 2, 3, 3, 2, 1, 4, 4, 1] at most two times. So the maximum number of folds of it is 2 . As an international fan of Boboniu, you' re asked to calculate the maximum number of folds. You' re given a sequence a of length n , for each i ( 1\u2264 i\u2264 n ) , you need to calculate the maximum number of folds of [ a_ 1, a_ 2, . . . , a_ i] .",
    "input": "The first line contains an integer n ( 1\u2264 n\u2264 10^ 5 ) . The second line contains n integers a_ 1, a_ 2, . . . , a_ n ( 1\u2264 a_ i\u2264 n ) .",
    "output": "Print n integers. The i - th of them should be equal to the maximum number of folds of [ a_ 1, a_ 2, . . . , a_ i] .",
    "note": "Formally, for a sequence a of length n , let' s define the folding sequence as a sequence b of length n such that: b_ i ( 1\u2264 i\u2264 n ) is either 1 or - 1 . Let p( i) = [ b_ i= 1] + \u2211_ j= 1^ i- 1b_ j . For all 1\u2264 i< j\u2264 n , if p( i) = p( j) , then a_ i should be equal to a_ j . ( [ A] is the value of boolean expression A . i. e. [ A] = 1 if A is true, else [ A] = 0 ) . Now we define the number of folds of b as f( b) = \u2211_ i= 1^ n- 1[ b_ i b_ i+ 1] . The maximum number of folds of a is F( a) = max{ f( b) | b is a folding sequence of a } .",
    "topics": [
      "strings"
    ]
  },
  {
    "title": "Twilight and Ancient Scroll (harder version)",
    "url": "https://codeforces.com/problemset/problem/1393/E2",
    "history": "This is a harder version of the problem E with larger constraints. Twilight Sparkle has received a new task from Princess Celestia. This time she asked to decipher the ancient scroll containing important knowledge of pony origin. To hide the crucial information from evil eyes, pony elders cast a spell on the scroll. That spell adds exactly one letter in any place to each word it is cast on. To make the path to the knowledge more tangled elders chose some of words in the scroll and cast a spell on them. Twilight Sparkle knows that the elders admired the order in all things so the scroll original scroll contained words in lexicographically non- decreasing order. She is asked to delete one letter from some of the words of the scroll ( to undo the spell) to get some version of the original scroll. Unfortunately, there may be more than one way to recover the ancient scroll. To not let the important knowledge slip by Twilight has to look through all variants of the original scroll and find the required one. To estimate the maximum time Twilight may spend on the work she needs to know the number of variants she has to look through. She asks you to find that number! Since that number can be very big, Twilight asks you to find it modulo 10^ 9+ 7 . It may occur that princess Celestia has sent a wrong scroll so the answer may not exist. A string a is lexicographically smaller than a string b if and only if one of the following holds: a is a prefix of b , but a b ; in the first position where a and b differ, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b .",
    "input": "The first line contains a single integer n ( 1 \u2264 n \u2264 10^ 5 ) : the number of words in the scroll. The i - th of the next n lines contains a string consisting of lowercase English letters: the i - th word in the scroll. The length of each word is at least one. The sum of lengths of words does not exceed 10^ 6 .",
    "output": "Print one integer: the number of ways to get a version of the original from the scroll modulo 10^ 9+ 7 .",
    "note": "Notice that the elders could have written an empty word ( but they surely cast a spell on it so it holds a length 1 now) .",
    "topics": [
      "dp",
      "hashing",
      "implementation",
      "string suffix structures",
      "strings",
      "two pointers"
    ]
  },
  {
    "title": "Twilight and Ancient Scroll (easier version)",
    "url": "https://codeforces.com/problemset/problem/1393/E1",
    "history": "This is an easier version of the problem E with smaller constraints. Twilight Sparkle has received a new task from Princess Celestia. This time she asked to decipher the ancient scroll containing important knowledge of pony origin. To hide the crucial information from evil eyes, pony elders cast a spell on the scroll. That spell adds exactly one letter in any place to each word it is cast on. To make the path to the knowledge more tangled elders chose some of words in the scroll and cast a spell on them. Twilight Sparkle knows that the elders admired the order in all things so the scroll original scroll contained words in lexicographically non- decreasing order. She is asked to delete one letter from some of the words of the scroll ( to undo the spell) to get some version of the original scroll. Unfortunately, there may be more than one way to recover the ancient scroll. To not let the important knowledge slip by Twilight has to look through all variants of the original scroll and find the required one. To estimate the maximum time Twilight may spend on the work she needs to know the number of variants she has to look through. She asks you to find that number! Since that number can be very big, Twilight asks you to find it modulo 10^ 9+ 7 . It may occur that princess Celestia has sent a wrong scroll so the answer may not exist. A string a is lexicographically smaller than a string b if and only if one of the following holds: a is a prefix of b , but a b ; in the first position where a and b differ, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b .",
    "input": "The first line contains a single integer n ( 1 \u2264 n \u2264 1000 ) : the number of words in the scroll. The i - th of the next n lines contains a string consisting of lowercase English letters: the i - th word in the scroll. The length of each word is more or equal than 1 . The sum of lengths of words does not exceed 20000 .",
    "output": "Print one integer: the number of ways to get a version of the original from the scroll modulo 10^ 9+ 7 .",
    "note": "Notice that the elders could have written an empty word ( but they surely cast a spell on it so it holds a length 1 now) .",
    "topics": [
      "dp",
      "hashing",
      "implementation",
      "string suffix structures",
      "strings"
    ]
  },
  {
    "title": "Common Prefixes",
    "url": "https://codeforces.com/problemset/problem/1384/A",
    "history": "The length of the longest common prefix of two strings s = s_ 1 s_ 2 . . . s_ n and t = t_ 1 t_ 2 . . . t_ m is defined as the maximum integer k ( 0 \u2264 k \u2264 min( n, m) ) such that s_ 1 s_ 2 . . . s_ k equals t_ 1 t_ 2 . . . t_ k . Koa the Koala initially has n+ 1 strings s_ 1, s_ 2, . . . , s_ n+ 1 . For each i ( 1 \u2264 i \u2264 n ) she calculated a_ i \u2014 the length of the longest common prefix of s_ i and s_ i+ 1 . Several days later Koa found these numbers, but she couldn' t remember the strings. So Koa would like to find some strings s_ 1, s_ 2, . . . , s_ n+ 1 which would have generated numbers a_ 1, a_ 2, . . . , a_ n . Can you help her? If there are many answers print any. We can show that answer always exists for the given constraints.",
    "input": "Each test contains multiple test cases. The first line contains t ( 1 \u2264 t \u2264 100 ) \u2014 the number of test cases. Description of the test cases follows. The first line of each test case contains a single integer n ( 1 \u2264 n \u2264 100 ) \u2014 the number of elements in the list a . The second line of each test case contains n integers a_ 1, a_ 2, . . . , a_ n ( 0 \u2264 a_ i \u2264 50 ) \u2014 the elements of a . It is guaranteed that the sum of n over all test cases does not exceed 100 .",
    "output": "For each test case: Output n+ 1 lines. In the i - th line print string s_ i ( 1 \u2264 | s_ i| \u2264 200 ) , consisting of lowercase Latin letters. Length of the longest common prefix of strings s_ i and s_ i+ 1 has to be equal to a_ i . If there are many answers print any. We can show that answer always exists for the given constraints.",
    "note": "In the 1 - st test case one of the possible answers is s = [ aeren, ari, arousal, around, ari] . Lengths of longest common prefixes are: Between aeren and ari \u2192 1 Between ari and arousal \u2192 2 Between arousal and around \u2192 4 Between around and ari \u2192 2",
    "topics": [
      "constructive algorithms",
      "greedy",
      "strings"
    ]
  },
  {
    "title": "String Transformation 1",
    "url": "https://codeforces.com/problemset/problem/1383/A",
    "history": "Note that the only difference between String Transformation 1 and String Transformation 2 is in the move Koa does. In this version the letter y Koa selects must be strictly greater alphabetically than x ( read statement for better understanding) . You can make hacks in these problems independently. Koa the Koala has two strings A and B of the same length n ( | A| = | B| = n ) consisting of the first 20 lowercase English alphabet letters ( ie. from a to t) . In one move Koa: selects some subset of positions p_ 1, p_ 2, . . . , p_ k ( k \u2265 1; 1 \u2264 p_ i \u2264 n; p_ i = \u0338 p_ j if i = \u0338 j ) of A such that A_ p_ 1 = A_ p_ 2 = . . . = A_ p_ k = x ( ie. all letters on this positions are equal to some letter x ) . selects a letter y ( from the first 20 lowercase letters in English alphabet) such that y> x ( ie. letter y is strictly greater alphabetically than x ) . sets each letter in positions p_ 1, p_ 2, . . . , p_ k to letter y . More formally: for each i ( 1 \u2264 i \u2264 k ) Koa sets A_ p_ i = y . Note that you can only modify letters in string A . Koa wants to know the smallest number of moves she has to do to make strings equal to each other ( A = B ) or to determine that there is no way to make them equal. Help her!",
    "input": "Each test contains multiple test cases. The first line contains t ( 1 \u2264 t \u2264 10 ) \u2014 the number of test cases. Description of the test cases follows. The first line of each test case contains one integer n ( 1 \u2264 n \u2264 10^ 5 ) \u2014 the length of strings A and B . The second line of each test case contains string A ( | A| = n ) . The third line of each test case contains string B ( | B| = n ) . Both strings consists of the first 20 lowercase English alphabet letters ( ie. from a to t) . It is guaranteed that the sum of n over all test cases does not exceed 10^ 5 .",
    "output": "For each test case: Print on a single line the smallest number of moves she has to do to make strings equal to each other ( A = B ) or - 1 if there is no way to make them equal.",
    "note": "In the 1 - st test case Koa: selects positions 1 and 2 and sets A_ 1 = A_ 2 = b ( aab \u2192bbb ) . selects positions 2 and 3 and sets A_ 2 = A_ 3 = c ( bbb\u2192 bcc ) . In the 2 - nd test case Koa has no way to make string A equal B . In the 3 - rd test case Koa: selects position 1 and sets A_ 1 = t ( abc \u2192tbc ) . selects position 2 and sets A_ 2 = s ( tbc \u2192 tsc ) . selects position 3 and sets A_ 3 = r ( tsc\u2192 tsr ) .",
    "topics": [
      "dsu",
      "graphs",
      "greedy",
      "sortings",
      "strings",
      "trees",
      "two pointers"
    ]
  },
  {
    "title": "Prefix Flip (Hard Version)",
    "url": "https://codeforces.com/problemset/problem/1381/A2",
    "history": "This is the hard version of the problem. The difference between the versions is the constraint on n and the required number of operations. You can make hacks only if all versions of the problem are solved. There are two binary strings a and b of length n ( a binary string is a string consisting of symbols 0 and 1 ) . In an operation, you select a prefix of a , and simultaneously invert the bits in the prefix ( 0 changes to 1 and 1 changes to 0 ) and reverse the order of the bits in the prefix. For example, if a= 001011 and you select the prefix of length 3 , it becomes 011011 . Then if you select the entire string, it becomes 001001 . Your task is to transform the string a into b in at most 2n operations. It can be proved that it is always possible.",
    "input": "The first line contains a single integer t ( 1\u2264 t\u2264 1000 ) \u2014 the number of test cases. Next 3t lines contain descriptions of test cases. The first line of each test case contains a single integer n ( 1\u2264 n\u2264 10^ 5 ) \u2014 the length of the binary strings. The next two lines contain two binary strings a and b of length n . It is guaranteed that the sum of n across all test cases does not exceed 10^ 5 .",
    "output": "For each test case, output an integer k ( 0\u2264 k\u2264 2n ) , followed by k integers p_ 1, . . . , p_ k ( 1\u2264 p_ i\u2264 n ) . Here k is the number of operations you use and p_ i is the length of the prefix you flip in the i - th operation.",
    "note": "In the first test case, we have 01\u2192 11\u2192 00\u2192 10 . In the second test case, we have 01011\u2192 00101\u2192 11101\u2192 01000\u2192 10100\u2192 00100\u2192 11100 . In the third test case, the strings are already the same. Another solution is to flip the prefix of length 2 , which will leave a unchanged.",
    "topics": [
      "constructive algorithms",
      "data structures",
      "implementation",
      "strings",
      "two pointers"
    ]
  },
  {
    "title": "Prefix Flip (Easy Version)",
    "url": "https://codeforces.com/problemset/problem/1381/A1",
    "history": "This is the easy version of the problem. The difference between the versions is the constraint on n and the required number of operations. You can make hacks only if all versions of the problem are solved. There are two binary strings a and b of length n ( a binary string is a string consisting of symbols 0 and 1 ) . In an operation, you select a prefix of a , and simultaneously invert the bits in the prefix ( 0 changes to 1 and 1 changes to 0 ) and reverse the order of the bits in the prefix. For example, if a= 001011 and you select the prefix of length 3 , it becomes 011011 . Then if you select the entire string, it becomes 001001 . Your task is to transform the string a into b in at most 3n operations. It can be proved that it is always possible.",
    "input": "The first line contains a single integer t ( 1\u2264 t\u2264 1000 ) \u2014 the number of test cases. Next 3t lines contain descriptions of test cases. The first line of each test case contains a single integer n ( 1\u2264 n\u2264 1000 ) \u2014 the length of the binary strings. The next two lines contain two binary strings a and b of length n . It is guaranteed that the sum of n across all test cases does not exceed 1000 .",
    "output": "For each test case, output an integer k ( 0\u2264 k\u2264 3n ) , followed by k integers p_ 1, . . . , p_ k ( 1\u2264 p_ i\u2264 n ) . Here k is the number of operations you use and p_ i is the length of the prefix you flip in the i - th operation.",
    "note": "In the first test case, we have 01\u2192 11\u2192 00\u2192 10 . In the second test case, we have 01011\u2192 00101\u2192 11101\u2192 01000\u2192 10100\u2192 00100\u2192 11100 . In the third test case, the strings are already the same. Another solution is to flip the prefix of length 2 , which will leave a unchanged.",
    "topics": [
      "constructive algorithms",
      "data structures",
      "strings"
    ]
  },
  {
    "title": "Acacius and String",
    "url": "https://codeforces.com/problemset/problem/1379/A",
    "history": "Acacius is studying strings theory. Today he came with the following problem. You are given a string s of length n consisting of lowercase English letters and question marks. It is possible to replace question marks with lowercase English letters in such a way that a string \" abacaba\" occurs as a substring in a resulting string exactly once? Each question mark should be replaced with exactly one lowercase English letter. For example, string \" a? b? c\" can be transformed into strings \" aabbc\" and \" azbzc\" , but can' t be transformed into strings \" aabc\" , \" a? bbc\" and \" babbc\" . Occurrence of a string t of length m in the string s of length n as a substring is a index i ( 1 \u2264 i \u2264 n - m + 1 ) such that string s[ i. . i+ m- 1] consisting of m consecutive symbols of s starting from i - th equals to string t . For example string \" ababa\" has two occurrences of a string \" aba\" as a substring with i = 1 and i = 3 , but there are no occurrences of a string \" aba\" in the string \" acba\" as a substring. Please help Acacius to check if it is possible to replace all question marks with lowercase English letters in such a way that a string \" abacaba\" occurs as a substring in a resulting string exactly once.",
    "input": "First line of input contains an integer T ( 1 \u2264 T \u2264 5000 ) , number of test cases. T pairs of lines with test case descriptions follow. The first line of a test case description contains a single integer n ( 7 \u2264 n \u2264 50 ) , length of a string s . The second line of a test case description contains string s of length n consisting of lowercase English letters and question marks.",
    "output": "For each test case output an answer for it. In case if there is no way to replace question marks in string s with a lowercase English letters in such a way that there is exactly one occurrence of a string \" abacaba\" in the resulting string as a substring output \" No\" . Otherwise output \" Yes\" and in the next line output a resulting string consisting of n lowercase English letters. If there are multiple possible strings, output any. You may print every letter in \" Yes\" and \" No\" in any case you want ( so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answer) .",
    "note": "In first example there is exactly one occurrence of a string \" abacaba\" in the string \" abacaba\" as a substring. In second example seven question marks can be replaced with any seven lowercase English letters and with \" abacaba\" in particular. In sixth example there are two occurrences of a string \" abacaba\" as a substring.",
    "topics": [
      "brute force",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Move Brackets",
    "url": "https://codeforces.com/problemset/problem/1374/C",
    "history": "You are given a bracket sequence s of length n , where n is even ( divisible by two) . The string s consists of n/ 2 opening brackets ' ( ' and n/ 2 closing brackets ' ) ' . In one move, you can choose exactly one bracket and move it to the beginning of the string or to the end of the string ( i. e. you choose some index i , remove the i - th character of s and insert it before or after all remaining characters of s ) . Your task is to find the minimum number of moves required to obtain regular bracket sequence from s . It can be proved that the answer always exists under the given constraints. Recall what the regular bracket sequence is: \" ( ) \" is regular bracket sequence; if s is regular bracket sequence then \" ( \" + s + \" ) \" is regular bracket sequence; if s and t are regular bracket sequences then s + t is regular bracket sequence. For example, \" ( ) ( ) \" , \" ( ( ) ) ( ) \" , \" ( ( ) ) \" and \" ( ) \" are regular bracket sequences, but \" ) ( \" , \" ( ) ( \" and \" ) ) ) \" are not. You have to answer t independent test cases.",
    "input": "The first line of the input contains one integer t ( 1 \u2264 t \u2264 2000 ) \u2014 the number of test cases. Then t test cases follow. The first line of the test case contains one integer n ( 2 \u2264 n \u2264 50 ) \u2014 the length of s . It is guaranteed that n is even. The second line of the test case containg the string s consisting of n/ 2 opening and n/ 2 closing brackets.",
    "output": "For each test case, print the answer \u2014 the minimum number of moves required to obtain regular bracket sequence from s . It can be proved that the answer always exists under the given constraints.",
    "note": "In the first test case of the example, it is sufficient to move the first bracket to the end of the string. In the third test case of the example, it is sufficient to move the last bracket to the beginning of the string. In the fourth test case of the example, we can choose last three openning brackets, move them to the beginning of the string and obtain \" ( ( ( ) ) ) ( ( ) ) \" .",
    "topics": [
      "greedy",
      "strings"
    ]
  },
  {
    "title": "AccurateLee",
    "url": "https://codeforces.com/problemset/problem/1369/B",
    "history": "Lee was cleaning his house for the party when he found a messy string under the carpets. Now he' d like to make it clean accurately and in a stylish way. . . The string s he found is a binary string of length n ( i. e. string consists only of 0- s and 1- s) . In one move he can choose two consecutive characters s_ i and s_ i+ 1 , and if s_ i is 1 and s_ i + 1 is 0, he can erase exactly one of them ( he can choose which one to erase but he can' t erase both characters simultaneously) . The string shrinks after erasing. Lee can make an arbitrary number of moves ( possibly zero) and he' d like to make the string s as clean as possible. He thinks for two different strings x and y , the shorter string is cleaner, and if they are the same length, then the lexicographically smaller string is cleaner. Now you should answer t test cases: for the i - th test case, print the cleanest possible string that Lee can get by doing some number of moves. Small reminder: if we have two strings x and y of the same length then x is lexicographically smaller than y if there is a position i such that x_ 1 = y_ 1 , x_ 2 = y_ 2 , . . . , x_ i - 1 = y_ i - 1 and x_ i < y_ i .",
    "input": "The first line contains the integer t ( 1 \u2264 t \u2264 10^ 4 ) \u2014 the number of test cases. Next 2t lines contain test cases \u2014 one per two lines. The first line of each test case contains the integer n ( 1 \u2264 n \u2264 10^ 5 ) \u2014 the length of the string s . The second line contains the binary string s . The string s is a string of length n which consists only of zeroes and ones. It' s guaranteed that sum of n over test cases doesn' t exceed 10^ 5 .",
    "output": "Print t answers \u2014 one per test case. The answer to the i - th test case is the cleanest string Lee can get after doing some number of moves ( possibly zero) .",
    "note": "In the first test case, Lee can' t perform any moves. In the second test case, Lee should erase s_ 2 . In the third test case, Lee can make moves, for example, in the following order: 11001101 \u2192 1100101 \u2192 110101 \u2192 10101 \u2192 1101 \u2192 101 \u2192 01.",
    "topics": [
      "greedy",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Codeforces Subsequences",
    "url": "https://codeforces.com/problemset/problem/1368/B",
    "history": "Karl likes Codeforces and subsequences. He wants to find a string of lowercase English letters that contains at least k subsequences codeforces. Out of all possible strings, Karl wants to find a shortest one. Formally, a codeforces subsequence of a string s is a subset of ten characters of s that read codeforces from left to right. For example, codeforces contains codeforces a single time, while codeforcesisawesome contains codeforces four times: codeforcesisawesome, codeforcesisawesome, codeforcesisawesome, codeforcesisawesome. Help Karl find any shortest string that contains at least k codeforces subsequences.",
    "input": "The only line contains a single integer k ( 1 \u2264 k \u2264 10^ 16) .",
    "output": "Print a shortest string of lowercase English letters that contains at least k codeforces subsequences. If there are several such strings, print any of them.",
    "note": "",
    "topics": [
      "brute force",
      "constructive algorithms",
      "greedy",
      "math",
      "strings"
    ]
  },
  {
    "title": "Short Substrings",
    "url": "https://codeforces.com/problemset/problem/1367/A",
    "history": "Alice guesses the strings that Bob made for her. At first, Bob came up with the secret string a consisting of lowercase English letters. The string a has a length of 2 or more characters. Then, from string a he builds a new string b and offers Alice the string b so that she can guess the string a . Bob builds b from a as follows: he writes all the substrings of length 2 of the string a in the order from left to right, and then joins them in the same order into the string b . For example, if Bob came up with the string a = \" abac\" , then all the substrings of length 2 of the string a are: \" ab\" , \" ba\" , \" ac\" . Therefore, the string b = \" abbaac\" . You are given the string b . Help Alice to guess the string a that Bob came up with. It is guaranteed that b was built according to the algorithm given above. It can be proved that the answer to the problem is unique.",
    "input": "The first line contains a single positive integer t ( 1 \u2264 t \u2264 1000 ) \u2014 the number of test cases in the test. Then t test cases follow. Each test case consists of one line in which the string b is written, consisting of lowercase English letters ( 2 \u2264 | b| \u2264 100 ) \u2014 the string Bob came up with, where | b| is the length of the string b . It is guaranteed that b was built according to the algorithm given above.",
    "output": "Output t answers to test cases. Each answer is the secret string a , consisting of lowercase English letters, that Bob came up with.",
    "note": "The first test case is explained in the statement. In the second test case, Bob came up with the string a = \" ac\" , the string a has a length 2 , so the string b is equal to the string a . In the third test case, Bob came up with the string a = \" bcdaf\" , substrings of length 2 of string a are: \" bc\" , \" cd\" , \" da\" , \" af\" , so the string b = \" bccddaaf\" .",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Construct the String",
    "url": "https://codeforces.com/problemset/problem/1366/G",
    "history": "Let' s denote the function f( s) that takes a string s consisting of lowercase Latin letters and dots, and returns a string consisting of lowercase Latin letters as follows: let r be an empty string; process the characters of s from left to right. For each character c , do the following: if c is a lowercase Latin letter, append c at the end of the string r ; otherwise, delete the last character from r ( if r is empty before deleting the last character \u2014 the function crashes) ; return r as the result of the function. You are given two strings s and t . You have to delete the minimum possible number of characters from s so that f( s) = t ( and the function does not crash) . Note that you aren' t allowed to insert new characters into s or reorder the existing ones.",
    "input": "The input consists of two lines: the first one contains s \u2014 a string consisting of lowercase Latin letters and dots, the second one contains t \u2014 a string consisting of lowercase Latin letters ( 1 \u2264 | t| \u2264 | s| \u2264 10000 ) . Additional constraint on the input: it is possible to remove some number of characters from s so that f( s) = t .",
    "output": "Print one integer \u2014 the minimum possible number of characters you have to delete from s so f( s) does not crash and returns t as the result of the function.",
    "note": "",
    "topics": [
      "data structures",
      "dp",
      "strings"
    ]
  },
  {
    "title": "Rotating Substrings",
    "url": "https://codeforces.com/problemset/problem/1363/F",
    "history": "You are given two strings s and t , each of length n and consisting of lowercase Latin alphabets. You want to make s equal to t . You can perform the following operation on s any number of times to achieve it \u2014 Choose any substring of s and rotate it clockwise once, that is, if the selected substring is s[ l, l+ 1. . . r] , then it becomes s[ r, l, l + 1 . . . r - 1] . All the remaining characters of s stay in their position. For example, on rotating the substring [ 2, 4] , string \" abcde\" becomes \" adbce\" . A string a is a substring of a string b if a can be obtained from b by deletion of several ( possibly, zero or all) characters from the beginning and several ( possibly, zero or all) characters from the end. Find the minimum number of operations required to convert s to t , or determine that it' s impossible.",
    "input": "The first line of the input contains a single integer t ( 1\u2264 t \u2264 2000) \u2014 the number of test cases. The description of the test cases follows. The first line of each test case contains a single integer n ( 1\u2264 n \u2264 2000) \u2014 the length of the strings. The second and the third lines contain strings s and t respectively. The sum of n over all the test cases does not exceed 2000 .",
    "output": "For each test case, output the minimum number of operations to convert s to t . If it is not possible to convert s to t , output - 1 instead.",
    "note": "For the 1 - st test case, since s and t are equal, you don' t need to apply any operation. For the 2 - nd test case, you only need to apply one operation on the entire string ab to convert it to ba. For the 3 - rd test case, you only need to apply one operation on the entire string abc to convert it to cab. For the 4 - th test case, you need to apply the operation twice: first on the entire string abc to convert it to cab and then on the substring of length 2 beginning at the second character to convert it to cba. For the 5 - th test case, you only need to apply one operation on the entire string abab to convert it to baba. For the 6 - th test case, it is not possible to convert string s to t .",
    "topics": [
      "dp",
      "strings"
    ]
  },
  {
    "title": "Subsequence Hate",
    "url": "https://codeforces.com/problemset/problem/1363/B",
    "history": "Shubham has a binary string s . A binary string is a string containing only characters \" 0\" and \" 1\" . He can perform the following operation on the string any amount of times: Select an index of the string, and flip the character at that index. This means, if the character was \" 0\" , it becomes \" 1\" , and vice versa. A string is called good if it does not contain \" 010\" or \" 101\" as a subsequence \u2014 for instance, \" 1001\" contains \" 101\" as a subsequence, hence it is not a good string, while \" 1000\" doesn' t contain neither \" 010\" nor \" 101\" as subsequences, so it is a good string. What is the minimum number of operations he will have to perform, so that the string becomes good? It can be shown that with these operations we can make any string good. A string a is a subsequence of a string b if a can be obtained from b by deletion of several ( possibly, zero or all) characters.",
    "input": "The first line of the input contains a single integer t ( 1\u2264 t \u2264 100) \u2014 the number of test cases. Each of the next t lines contains a binary string s ( 1 \u2264 | s| \u2264 1000) .",
    "output": "For every string, output the minimum number of operations required to make it good.",
    "note": "In test cases 1 , 2 , 5 , 6 no operations are required since they are already good strings. For the 3 rd test case: \" 001\" can be achieved by flipping the first character \u2014 and is one of the possible ways to get a good string. For the 4 th test case: \" 000\" can be achieved by flipping the second character \u2014 and is one of the possible ways to get a good string. For the 7 th test case: \" 000000\" can be achieved by flipping the third and fourth characters \u2014 and is one of the possible ways to get a good string.",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Spy-string",
    "url": "https://codeforces.com/problemset/problem/1360/F",
    "history": "You are given n strings a_ 1, a_ 2, . . . , a_ n : all of them have the same length m . The strings consist of lowercase English letters. Find any string s of length m such that each of the given n strings differs from s in at most one position. Formally, for each given string a_ i , there is no more than one position j such that a_ i[ j] s[ j] . Note that the desired string s may be equal to one of the given strings a_ i , or it may differ from all the given strings. For example, if you have the strings abac and zbab, then the answer to the problem might be the string abab, which differs from the first only by the last character, and from the second only by the first.",
    "input": "The first line contains an integer t ( 1 \u2264 t \u2264 100 ) \u2014 the number of test cases. Then t test cases follow. Each test case starts with a line containing two positive integers n ( 1 \u2264 n \u2264 10 ) and m ( 1 \u2264 m \u2264 10 ) \u2014 the number of strings and their length. Then follow n strings a_ i , one per line. Each of them has length m and consists of lowercase English letters.",
    "output": "Print t answers to the test cases. Each answer ( if it exists) is a string of length m consisting of lowercase English letters. If there are several answers, print any of them. If the answer does not exist, print \" - 1\" ( \" minus one\" , without quotes) .",
    "note": "The first test case was explained in the statement. In the second test case, the answer does not exist.",
    "topics": [
      "bitmasks",
      "brute force",
      "constructive algorithms",
      "dp",
      "hashing",
      "strings"
    ]
  },
  {
    "title": "Phoenix and Distribution",
    "url": "https://codeforces.com/problemset/problem/1348/C",
    "history": "Phoenix has a string s consisting of lowercase Latin letters. He wants to distribute all the letters of his string into k non- empty strings a_ 1, a_ 2, . . . , a_ k such that every letter of s goes to exactly one of the strings a_ i . The strings a_ i do not need to be substrings of s . Phoenix can distribute letters of s and rearrange the letters within each string a_ i however he wants. For example, if s = baba and k= 2 , Phoenix may distribute the letters of his string in many ways, such as: ba and ba a and abb ab and ab aa and bb But these ways are invalid: baa and ba b and ba baba and empty string ( a_ i should be non- empty) Phoenix wants to distribute the letters of his string s into k strings a_ 1, a_ 2, . . . , a_ k to minimize the lexicographically maximum string among them, i. e. minimize max( a_ 1, a_ 2, . . . , a_ k) . Help him find the optimal distribution and print the minimal possible value of max( a_ 1, a_ 2, . . . , a_ k) . String x is lexicographically less than string y if either x is a prefix of y and x y , or there exists an index i ( 1 \u2264 i \u2264 min( | x| , | y| ) ) such that x_ i < y_ i and for every j ( 1 \u2264 j < i) x_ j = y_ j . Here | x| denotes the length of the string x .",
    "input": "The input consists of multiple test cases. The first line contains an integer t ( 1 \u2264 t \u2264 1000 ) \u2014 the number of test cases. Each test case consists of two lines. The first line of each test case consists of two integers n and k ( 1 \u2264 k \u2264 n \u2264 10^ 5 ) \u2014 the length of string s and the number of non- empty strings, into which Phoenix wants to distribute letters of s , respectively. The second line of each test case contains a string s of length n consisting only of lowercase Latin letters. It is guaranteed that the sum of n over all test cases is \u2264 10^ 5 .",
    "output": "Print t answers \u2014 one per test case. The i - th answer should be the minimal possible value of max( a_ 1, a_ 2, . . . , a_ k) in the i - th test case.",
    "note": "In the first test case, one optimal solution is to distribute baba into ab and ab. In the second test case, one optimal solution is to distribute baacb into abbc and a. In the third test case, one optimal solution is to distribute baacb into ac, ab, and b. In the fourth test case, one optimal solution is to distribute aaaaa into aa, aa, and a. In the fifth test case, one optimal solution is to distribute aaxxzz into az, az, x, and x. In the sixth test case, one optimal solution is to distribute phoenix into ehinopx.",
    "topics": [
      "constructive algorithms",
      "greedy",
      "sortings",
      "strings"
    ]
  },
  {
    "title": "Binary Period",
    "url": "https://codeforces.com/problemset/problem/1342/B",
    "history": "Let' s say string s has period k if s_ i = s_ i + k for all i from 1 to | s| - k ( | s| means length of string s ) and k is the minimum positive integer with this property. Some examples of a period: for s = \" 0101\" the period is k= 2 , for s = \" 0000\" the period is k= 1 , for s = \" 010\" the period is k= 2 , for s = \" 0011\" the period is k= 4 . You are given string t consisting only of 0' s and 1' s and you need to find such string s that: String s consists only of 0' s and 1' s; The length of s doesn' t exceed 2 \u00b7 | t| ; String t is a subsequence of string s ; String s has smallest possible period among all strings that meet conditions 1\u20143. Let us recall that t is a subsequence of s if t can be derived from s by deleting zero or more elements ( any) without changing the order of the remaining elements. For example, t = \" 011\" is a subsequence of s = \" 10101\" .",
    "input": "The first line contains single integer T ( 1 \u2264 T \u2264 100 ) \u2014 the number of test cases. Next T lines contain test cases \u2014 one per line. Each line contains string t ( 1 \u2264 | t| \u2264 100 ) consisting only of 0' s and 1' s.",
    "output": "Print one string for each test case \u2014 string s you needed to find. If there are multiple solutions print any one of them.",
    "note": "In the first and second test cases, s = t since it' s already one of the optimal solutions. Answers have periods equal to 1 and 2 , respectively. In the third test case, there are shorter optimal solutions, but it' s okay since we don' t need to minimize the string s . String s has period equal to 1 .",
    "topics": [
      "constructive algorithms",
      "strings"
    ]
  },
  {
    "title": "Kaavi and Magic Spell",
    "url": "https://codeforces.com/problemset/problem/1336/C",
    "history": "Kaavi, the mysterious fortune teller, deeply believes that one' s fate is inevitable and unavoidable. Of course, she makes her living by predicting others' future. While doing divination, Kaavi believes that magic spells can provide great power for her to see the future. Kaavi has a string T of length m and all the strings with the prefix T are magic spells. Kaavi also has a string S of length n and an empty string A . During the divination, Kaavi needs to perform a sequence of operations. There are two different operations: Delete the first character of S and add it at the front of A . Delete the first character of S and add it at the back of A . Kaavi can perform no more than n operations. To finish the divination, she wants to know the number of different operation sequences to make A a magic spell ( i. e. with the prefix T ) . As her assistant, can you help her? The answer might be huge, so Kaavi only needs to know the answer modulo 998 244 353 . Two operation sequences are considered different if they are different in length or there exists an i that their i - th operation is different. A substring is a contiguous sequence of characters within a string. A prefix of a string S is a substring of S that occurs at the beginning of S .",
    "input": "The first line contains a string S of length n ( 1 \u2264 n \u2264 3000 ) . The second line contains a string T of length m ( 1 \u2264 m \u2264 n ) . Both strings contain only lowercase Latin letters.",
    "output": "The output contains only one integer \u2014 the answer modulo 998 244 353 .",
    "note": "The first test: The red ones are the magic spells. In the first operation, Kaavi can either add the first character \" a\" at the front or the back of A , although the results are the same, they are considered as different operations. So the answer is 6\u00d72= 12 .",
    "topics": [
      "dp",
      "strings"
    ]
  },
  {
    "title": "K-Complete Word",
    "url": "https://codeforces.com/problemset/problem/1332/C",
    "history": "Word s of length n is called k - complete if s is a palindrome, i. e. s_ i= s_ n+ 1- i for all 1 \u2264 i \u2264 n ; s has a period of k , i. e. s_ i= s_ k+ i for all 1 \u2264 i \u2264 n- k . For example, \" abaaba\" is a 3 - complete word, while \" abccba\" is not. Bob is given a word s of length n consisting of only lowercase Latin letters and an integer k , such that n is divisible by k . He wants to convert s to any k - complete word. To do this Bob can choose some i ( 1 \u2264 i \u2264 n ) and replace the letter at position i with some other lowercase Latin letter. So now Bob wants to know the minimum number of letters he has to replace to convert s to any k - complete word. Note that Bob can do zero changes if the word s is already k - complete. You are required to answer t test cases independently.",
    "input": "The first line contains a single integer t ( 1 \u2264 t\u2264 10^ 5 ) \u2014 the number of test cases. The first line of each test case contains two integers n and k ( 1 \u2264 k < n \u2264 2 \u00b7 10^ 5 , n is divisible by k ) . The second line of each test case contains a word s of length n . It is guaranteed that word s only contains lowercase Latin letters. And it is guaranteed that the sum of n over all test cases will not exceed 2 \u00b7 10^ 5 .",
    "output": "For each test case, output one integer, representing the minimum number of characters he has to replace to convert s to any k - complete word.",
    "note": "In the first test case, one optimal solution is aaaaaa. In the second test case, the given word itself is k - complete.",
    "topics": [
      "dfs and similar",
      "dsu",
      "greedy",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Elementary!",
    "url": "https://codeforces.com/problemset/problem/1331/F",
    "history": "",
    "input": "The input consists of a single string of uppercase letters A- Z. The length of the string is between 1 and 10 characters, inclusive.",
    "output": "Output \" YES\" or \" NO\" .",
    "note": "",
    "topics": [
      "*special",
      "brute force",
      "dp",
      "strings"
    ]
  },
  {
    "title": "Prefix-Suffix Palindrome (Hard version)",
    "url": "https://codeforces.com/problemset/problem/1326/D2",
    "history": "This is the hard version of the problem. The difference is the constraint on the sum of lengths of strings and the number of test cases. You can make hacks only if you solve all versions of this task. You are given a string s , consisting of lowercase English letters. Find the longest string, t , which satisfies the following conditions: The length of t does not exceed the length of s . t is a palindrome. There exists two strings a and b ( possibly empty) , such that t = a + b ( \" + \" represents concatenation) , and a is prefix of s while b is suffix of s .",
    "input": "The input consists of multiple test cases. The first line contains a single integer t ( 1 \u2264 t \u2264 10^ 5 ) , the number of test cases. The next t lines each describe a test case. Each test case is a non- empty string s , consisting of lowercase English letters. It is guaranteed that the sum of lengths of strings over all test cases does not exceed 10^ 6 .",
    "output": "For each test case, print the longest string which satisfies the conditions described above. If there exists multiple possible solutions, print any of them.",
    "note": "In the first test, the string s = \" a\" satisfies all conditions. In the second test, the string \" abcdfdcba\" satisfies all conditions, because: Its length is 9 , which does not exceed the length of the string s , which equals 11 . It is a palindrome. \" abcdfdcba\" = \" abcdfdc\" + \" ba\" , and \" abcdfdc\" is a prefix of s while \" ba\" is a suffix of s . It can be proven that there does not exist a longer string which satisfies the conditions. In the fourth test, the string \" c\" is correct, because \" c\" = \" c\" + \" \" and a or b can be empty. The other possible solution for this test is \" s\" .",
    "topics": [
      "binary search",
      "greedy",
      "hashing",
      "string suffix structures",
      "strings"
    ]
  },
  {
    "title": "Prefix-Suffix Palindrome (Easy version)",
    "url": "https://codeforces.com/problemset/problem/1326/D1",
    "history": "This is the easy version of the problem. The difference is the constraint on the sum of lengths of strings and the number of test cases. You can make hacks only if you solve all versions of this task. You are given a string s , consisting of lowercase English letters. Find the longest string, t , which satisfies the following conditions: The length of t does not exceed the length of s . t is a palindrome. There exists two strings a and b ( possibly empty) , such that t = a + b ( \" + \" represents concatenation) , and a is prefix of s while b is suffix of s .",
    "input": "The input consists of multiple test cases. The first line contains a single integer t ( 1 \u2264 t \u2264 1000 ) , the number of test cases. The next t lines each describe a test case. Each test case is a non- empty string s , consisting of lowercase English letters. It is guaranteed that the sum of lengths of strings over all test cases does not exceed 5000 .",
    "output": "For each test case, print the longest string which satisfies the conditions described above. If there exists multiple possible solutions, print any of them.",
    "note": "In the first test, the string s = \" a\" satisfies all conditions. In the second test, the string \" abcdfdcba\" satisfies all conditions, because: Its length is 9 , which does not exceed the length of the string s , which equals 11 . It is a palindrome. \" abcdfdcba\" = \" abcdfdc\" + \" ba\" , and \" abcdfdc\" is a prefix of s while \" ba\" is a suffix of s . It can be proven that there does not exist a longer string which satisfies the conditions. In the fourth test, the string \" c\" is correct, because \" c\" = \" c\" + \" \" and a or b can be empty. The other possible solution for this test is \" s\" .",
    "topics": [
      "hashing",
      "string suffix structures",
      "strings"
    ]
  },
  {
    "title": "Yet Another Palindrome Problem",
    "url": "https://codeforces.com/problemset/problem/1324/B",
    "history": "You are given an array a consisting of n integers. Your task is to determine if a has some subsequence of length at least 3 that is a palindrome. Recall that an array b is called a subsequence of the array a if b can be obtained by removing some ( possibly, zero) elements from a ( not necessarily consecutive) without changing the order of remaining elements. For example, [ 2] , [ 1, 2, 1, 3] and [ 2, 3] are subsequences of [ 1, 2, 1, 3] , but [ 1, 1, 2] and [ 4] are not. Also, recall that a palindrome is an array that reads the same backward as forward. In other words, the array a of length n is the palindrome if a_ i = a_ n - i - 1 for all i from 1 to n . For example, arrays [ 1234] , [ 1, 2, 1] , [ 1, 3, 2, 2, 3, 1] and [ 10, 100, 10] are palindromes, but arrays [ 1, 2] and [ 1, 2, 3, 1] are not. You have to answer t independent test cases.",
    "input": "The first line of the input contains one integer t ( 1 \u2264 t \u2264 100 ) \u2014 the number of test cases. Next 2t lines describe test cases. The first line of the test case contains one integer n ( 3 \u2264 n \u2264 5000 ) \u2014 the length of a . The second line of the test case contains n integers a_ 1, a_ 2, . . . , a_ n ( 1 \u2264 a_ i \u2264 n ) , where a_ i is the i - th element of a . It is guaranteed that the sum of n over all test cases does not exceed 5000 ( \u2211 n \u2264 5000 ) .",
    "output": "For each test case, print the answer \u2014 \" YES\" ( without quotes) if a has some subsequence of length at least 3 that is a palindrome and \" NO\" otherwise.",
    "note": "In the first test case of the example, the array a has a subsequence [ 1, 2, 1] which is a palindrome. In the second test case of the example, the array a has two subsequences of length 3 which are palindromes: [ 2, 3, 2] and [ 2, 2, 2] . In the third test case of the example, the array a has no subsequences of length at least 3 which are palindromes. In the fourth test case of the example, the array a has one subsequence of length 4 which is a palindrome: [ 1, 2, 2, 1] ( and has two subsequences of length 3 which are palindromes: both are [ 1, 2, 1] ) . In the fifth test case of the example, the array a has no subsequences of length at least 3 which are palindromes.",
    "topics": [
      "brute force",
      "strings"
    ]
  },
  {
    "title": "Remove Adjacent",
    "url": "https://codeforces.com/problemset/problem/1321/C",
    "history": "You are given a string s consisting of lowercase Latin letters. Let the length of s be | s| . You may perform several operations on this string. In one operation, you can choose some index i and remove the i - th character of s ( s_ i ) if at least one of its adjacent characters is the previous letter in the Latin alphabet for s_ i . For example, the previous letter for b is a, the previous letter for s is r, the letter a has no previous letters. Note that after each removal the length of the string decreases by one. So, the index i should satisfy the condition 1 \u2264 i \u2264 | s| during each operation. For the character s_ i adjacent characters are s_ i- 1 and s_ i+ 1 . The first and the last characters of s both have only one adjacent character ( unless | s| = 1 ) . Consider the following example. Let s= bacabcab. During the first move, you can remove the first character s_ 1= b because s_ 2= a. Then the string becomes s= acabcab. During the second move, you can remove the fifth character s_ 5= c because s_ 4= b. Then the string becomes s= acabab. During the third move, you can remove the sixth character s_ 6= ' b' because s_ 5= a. Then the string becomes s= acaba. During the fourth move, the only character you can remove is s_ 4= b, because s_ 3= a ( or s_ 5= a) . The string becomes s= acaa and you cannot do anything with it. Your task is to find the maximum possible number of characters you can remove if you choose the sequence of operations optimally.",
    "input": "The first line of the input contains one integer | s| ( 1 \u2264 | s| \u2264 100 ) \u2014 the length of s . The second line of the input contains one string s consisting of | s| lowercase Latin letters.",
    "output": "Print one integer \u2014 the maximum possible number of characters you can remove if you choose the sequence of moves optimally.",
    "note": "The first example is described in the problem statement. Note that the sequence of moves provided in the statement is not the only, but it can be shown that the maximum possible answer to this test is 4 . In the second example, you can remove all but one character of s . The only possible answer follows. During the first move, remove the third character s_ 3= d, s becomes bca. During the second move, remove the second character s_ 2= c, s becomes ba. And during the third move, remove the first character s_ 1= b, s becomes a.",
    "topics": [
      "brute force",
      "constructive algorithms",
      "greedy",
      "strings"
    ]
  },
  {
    "title": "Reachable Strings",
    "url": "https://codeforces.com/problemset/problem/1320/D",
    "history": "In this problem, we will deal with binary strings. Each character of a binary string is either a 0 or a 1. We will also deal with substrings; recall that a substring is a contiguous subsequence of a string. We denote the substring of string s starting from the l - th character and ending with the r - th character as s[ l . . . r] . The characters of each string are numbered from 1 . We can perform several operations on the strings we consider. Each operation is to choose a substring of our string and replace it with another string. There are two possible types of operations: replace 011 with 110, or replace 110 with 011. For example, if we apply exactly one operation to the string 110011110, it can be transformed into 011011110, 110110110, or 110011011. Binary string a is considered reachable from binary string b if there exists a sequence s_ 1 , s_ 2 , . . . , s_ k such that s_ 1 = a , s_ k = b , and for every i \u2208 [ 1, k - 1] , s_ i can be transformed into s_ i + 1 using exactly one operation. Note that k can be equal to 1 , i. e. , every string is reachable from itself. You are given a string t and q queries to it. Each query consists of three integers l_ 1 , l_ 2 and len . To answer each query, you have to determine whether t[ l_ 1 . . . l_ 1 + len - 1] is reachable from t[ l_ 2 . . . l_ 2 + len - 1] .",
    "input": "The first line contains one integer n ( 1 \u2264 n \u2264 2 \u00b7 10^ 5 ) \u2014 the length of string t . The second line contains one string t ( | t| = n ) . Each character of t is either 0 or 1. The third line contains one integer q ( 1 \u2264 q \u2264 2 \u00b7 10^ 5 ) \u2014 the number of queries. Then q lines follow, each line represents a query. The i - th line contains three integers l_ 1 , l_ 2 and len ( 1 \u2264 l_ 1, l_ 2 \u2264 | t| , 1 \u2264 len \u2264 | t| - max( l_ 1, l_ 2) + 1 ) for the i - th query.",
    "output": "For each query, print either YES if t[ l_ 1 . . . l_ 1 + len - 1] is reachable from t[ l_ 2 . . . l_ 2 + len - 1] , or NO otherwise. You may print each letter in any register.",
    "note": "",
    "topics": [
      "data structures",
      "hashing",
      "strings"
    ]
  },
  {
    "title": "String Modification",
    "url": "https://codeforces.com/problemset/problem/1316/B",
    "history": "Vasya has a string s of length n . He decides to make the following modification to the string: Pick an integer k , ( 1 \u2264 k \u2264 n ) . For i from 1 to n- k+ 1 , reverse the substring s[ i: i+ k- 1] of s . For example, if string s is qwer and k = 2 , below is the series of transformations the string goes through: qwer ( original string) wqer ( after reversing the first substring of length 2 ) weqr ( after reversing the second substring of length 2 ) werq ( after reversing the last substring of length 2 ) Hence, the resulting string after modifying s with k = 2 is werq. Vasya wants to choose a k such that the string obtained after the above- mentioned modification is lexicographically smallest possible among all choices of k . Among all such k , he wants to choose the smallest one. Since he is busy attending Felicity 2020, he asks for your help. A string a is lexicographically smaller than a string b if and only if one of the following holds: a is a prefix of b , but a b ; in the first position where a and b differ, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b .",
    "input": "Each test contains multiple test cases. The first line contains the number of test cases t ( 1 \u2264 t \u2264 5000 ) . The description of the test cases follows. The first line of each test case contains a single integer n ( 1 \u2264 n \u2264 5000 ) \u2014 the length of the string s . The second line of each test case contains the string s of n lowercase latin letters. It is guaranteed that the sum of n over all test cases does not exceed 5000 .",
    "output": "For each testcase output two lines: In the first line output the lexicographically smallest string s' achievable after the above- mentioned modification. In the second line output the appropriate value of k ( 1 \u2264 k \u2264 n ) that you chose for performing the modification. If there are multiple values of k that give the lexicographically smallest string, output the smallest value of k among them.",
    "note": "In the first testcase of the first sample, the string modification results for the sample abab are as follows : for k = 1 : abab for k = 2 : baba for k = 3 : abab for k = 4 : babaThe lexicographically smallest string achievable through modification is abab for k = 1 and 3 . Smallest value of k needed to achieve is hence 1 .",
    "topics": [
      "brute force",
      "constructive algorithms",
      "implementation",
      "sortings",
      "strings"
    ]
  },
  {
    "title": "Homecoming",
    "url": "https://codeforces.com/problemset/problem/1315/B",
    "history": "After a long party Petya decided to return home, but he turned out to be at the opposite end of the town from his home. There are n crossroads in the line in the town, and there is either the bus or the tram station at each crossroad. The crossroads are represented as a string s of length n , where s_ i = , if there is a bus station at i - th crossroad, and s_ i = , if there is a tram station at i - th crossroad. Currently Petya is at the first crossroad ( which corresponds to s_ 1 ) and his goal is to get to the last crossroad ( which corresponds to s_ n ) . If for two crossroads i and j for all crossroads i, i+ 1, . . . , j- 1 there is a bus station, one can pay a roubles for the bus ticket, and go from i - th crossroad to the j - th crossroad by the bus ( it is not necessary to have a bus station at the j - th crossroad) . Formally, paying a roubles Petya can go from i to j if s_ t = for all i \u2264 t < j . If for two crossroads i and j for all crossroads i, i+ 1, . . . , j- 1 there is a tram station, one can pay b roubles for the tram ticket, and go from i - th crossroad to the j - th crossroad by the tram ( it is not necessary to have a tram station at the j - th crossroad) . Formally, paying b roubles Petya can go from i to j if s_ t = for all i \u2264 t < j . For example, if s = \" AABBBAB\" , a= 4 and b= 3 then Petya needs: buy one bus ticket to get from 1 to 3 , buy one tram ticket to get from 3 to 6 , buy one bus ticket to get from 6 to 7 . Thus, in total he needs to spend 4+ 3+ 4= 11 roubles. Please note that the type of the stop at the last crossroad ( i. e. the character s_ n ) does not affect the final expense. Now Petya is at the first crossroad, and he wants to get to the n - th crossroad. After the party he has left with p roubles. He' s decided to go to some station on foot, and then go to home using only public transport. Help him to choose the closest crossroad i to go on foot the first, so he has enough money to get from the i - th crossroad to the n - th, using only tram and bus tickets.",
    "input": "Each test contains one or more test cases. The first line contains the number of test cases t ( 1 \u2264 t \u2264 10^ 4 ) . The first line of each test case consists of three integers a, b, p ( 1 \u2264 a, b, p \u2264 10^ 5 ) \u2014 the cost of bus ticket, the cost of tram ticket and the amount of money Petya has. The second line of each test case consists of one string s , where s_ i = , if there is a bus station at i - th crossroad, and s_ i = , if there is a tram station at i - th crossroad ( 2 \u2264 | s| \u2264 10^ 5 ) . It is guaranteed, that the sum of the length of strings s by all test cases in one test doesn' t exceed 10^ 5 .",
    "output": "For each test case print one number \u2014 the minimal index i of a crossroad Petya should go on foot. The rest of the path ( i. e. from i to n he should use public transport) .",
    "note": "",
    "topics": [
      "binary search",
      "dp",
      "greedy",
      "strings"
    ]
  },
  {
    "title": "Concatenation with intersection",
    "url": "https://codeforces.com/problemset/problem/1313/E",
    "history": "Vasya had three strings a , b and s , which consist of lowercase English letters. The lengths of strings a and b are equal to n , the length of the string s is equal to m . Vasya decided to choose a substring of the string a , then choose a substring of the string b and concatenate them. Formally, he chooses a segment [ l_ 1, r_ 1] ( 1 \u2264 l_ 1 \u2264 r_ 1 \u2264 n ) and a segment [ l_ 2, r_ 2] ( 1 \u2264 l_ 2 \u2264 r_ 2 \u2264 n ) , and after concatenation he obtains a string a[ l_ 1, r_ 1] + b[ l_ 2, r_ 2] = a_ l_ 1 a_ l_ 1 + 1. . . a_ r_ 1 b_ l_ 2 b_ l_ 2 + 1. . . b_ r_ 2 . Now, Vasya is interested in counting number of ways to choose those segments adhering to the following conditions: segments [ l_ 1, r_ 1] and [ l_ 2, r_ 2] have non- empty intersection, i. e. there exists at least one integer x , such that l_ 1 \u2264 x \u2264 r_ 1 and l_ 2 \u2264 x \u2264 r_ 2 ; the string a[ l_ 1, r_ 1] + b[ l_ 2, r_ 2] is equal to the string s .",
    "input": "The first line contains integers n and m ( 1 \u2264 n \u2264 500 000, 2 \u2264 m \u2264 2 \u00b7 n ) \u2014 the length of strings a and b and the length of the string s . The next three lines contain strings a , b and s , respectively. The length of the strings a and b is n , while the length of the string s is m . All strings consist of lowercase English letters.",
    "output": "Print one integer \u2014 the number of ways to choose a pair of segments, which satisfy Vasya' s conditions.",
    "note": "Let' s list all the pairs of segments that Vasya could choose in the first example: [ 2, 2] and [ 2, 5] ; [ 1, 2] and [ 2, 4] ; [ 5, 5] and [ 2, 5] ; [ 5, 6] and [ 3, 5] ;",
    "topics": [
      "data structures",
      "hashing",
      "strings",
      "two pointers"
    ]
  },
  {
    "title": "Au Pont Rouge",
    "url": "https://codeforces.com/problemset/problem/1310/C",
    "history": "VK just opened its second HQ in St. Petersburg! Side of its office building has a huge string s written on its side. This part of the office is supposed to be split into m meeting rooms in such way that meeting room walls are strictly between letters on the building. Obviously, meeting rooms should not be of size 0, but can be as small as one letter wide. Each meeting room will be named after the substring of s written on its side. For each possible arrangement of m meeting rooms we ordered a test meeting room label for the meeting room with lexicographically minimal name. When delivered, those labels got sorted backward lexicographically. What is printed on k th label of the delivery?",
    "input": "In the first line, you are given three integer numbers n, m, k \u2014 length of string s , number of planned meeting rooms to split s into and number of the interesting label ( 2 \u2264 n \u2264 1 000; 1 \u2264 m \u2264 1 000; 1 \u2264 k \u2264 10^ 18 ) . Second input line has string s , consisting of n lowercase english letters. For given n, m, k there are at least k ways to split s into m substrings.",
    "output": "Output single string \u2013 name of meeting room printed on k - th label of the delivery.",
    "note": "In the first example, delivery consists of the labels \" aba\" , \" ab\" , \" a\" . In the second example, delivery consists of 3060 labels. The first label is \" aupontrougevkof\" and the last one is \" a\" .",
    "topics": [
      "binary search",
      "dp",
      "strings"
    ]
  },
  {
    "title": "Cow and Message",
    "url": "https://codeforces.com/problemset/problem/1307/C",
    "history": "Bessie the cow has just intercepted a text that Farmer John sent to Burger Queen! However, Bessie is sure that there is a secret message hidden inside. The text is a string s of lowercase Latin letters. She considers a string t as hidden in string s if t exists as a subsequence of s whose indices form an arithmetic progression. For example, the string aab is hidden in string aaabb because it occurs at indices 1 , 3 , and 5 , which form an arithmetic progression with a common difference of 2 . Bessie thinks that any hidden string that occurs the most times is the secret message. Two occurrences of a subsequence of S are distinct if the sets of indices are different. Help her find the number of occurrences of the secret message! For example, in the string aaabb, a is hidden 3 times, b is hidden 2 times, ab is hidden 6 times, aa is hidden 3 times, bb is hidden 1 time, aab is hidden 2 times, aaa is hidden 1 time, abb is hidden 1 time, aaab is hidden 1 time, aabb is hidden 1 time, and aaabb is hidden 1 time. The number of occurrences of the secret message is 6 .",
    "input": "The first line contains a string s of lowercase Latin letters ( 1 \u2264 | s| \u2264 10^ 5 ) \u2014 the text that Bessie intercepted.",
    "output": "Output a single integer \u2014 the number of occurrences of the secret message.",
    "note": "In the first example, these are all the hidden strings and their indice sets: a occurs at ( 1) , ( 2) , ( 3) b occurs at ( 4) , ( 5) ab occurs at ( 1, 4) , ( 1, 5) , ( 2, 4) , ( 2, 5) , ( 3, 4) , ( 3, 5) aa occurs at ( 1, 2) , ( 1, 3) , ( 2, 3) bb occurs at ( 4, 5) aab occurs at ( 1, 3, 5) , ( 2, 3, 4) aaa occurs at ( 1, 2, 3) abb occurs at ( 3, 4, 5) aaab occurs at ( 1, 2, 3, 4) aabb occurs at ( 2, 3, 4, 5) aaabb occurs at ( 1, 2, 3, 4, 5) Note that all the sets of indices are arithmetic progressions. In the second example, no hidden string occurs more than once. In the third example, the hidden string is the letter l.",
    "topics": [
      "brute force",
      "dp",
      "math",
      "strings"
    ]
  },
  {
    "title": "Kuroni and Simple Strings",
    "url": "https://codeforces.com/problemset/problem/1305/B",
    "history": "Now that Kuroni has reached 10 years old, he is a big boy and doesn' t like arrays of integers as presents anymore. This year he wants a Bracket sequence as a Birthday present. More specifically, he wants a bracket sequence so complex that no matter how hard he tries, he will not be able to remove a simple subsequence! We say that a string formed by n characters ' ( ' or ' ) ' is simple if its length n is even and positive, its first n/ 2 characters are ' ( ' , and its last n/ 2 characters are ' ) ' . For example, the strings ( ) and ( ( ) ) are simple, while the strings ) ( and ( ) ( ) are not simple. Kuroni will be given a string formed by characters ' ( ' and ' ) ' ( the given string is not necessarily simple) . An operation consists of choosing a subsequence of the characters of the string that forms a simple string and removing all the characters of this subsequence from the string. Note that this subsequence doesn' t have to be continuous. For example, he can apply the operation to the string ' ) ( ) ( ( ) ) ) ' , to choose a subsequence of bold characters, as it forms a simple string ' ( ( ) ) ' , delete these bold characters from the string and to get ' ) ) ( ) ' . Kuroni has to perform the minimum possible number of operations on the string, in such a way that no more operations can be performed on the remaining string. The resulting string does not have to be empty. Since the given string is too large, Kuroni is unable to figure out how to minimize the number of operations. Can you help him do it instead? A sequence of characters a is a subsequence of a string b if a can be obtained from b by deletion of several ( possibly, zero or all) characters.",
    "input": "The only line of input contains a string s ( 1 \u2264 | s| \u2264 1000 ) formed by characters ' ( ' and ' ) ' , where | s| is the length of s .",
    "output": "In the first line, print an integer k \u2014 the minimum number of operations you have to apply. Then, print 2k lines describing the operations in the following format: For each operation, print a line containing an integer m \u2014 the number of characters in the subsequence you will remove. Then, print a line containing m integers 1 \u2264 a_ 1 < a_ 2 < . . . < a_ m \u2014 the indices of the characters you will remove. All integers must be less than or equal to the length of the current string, and the corresponding subsequence must form a simple string. If there are multiple valid sequences of operations with the smallest k , you may print any of them.",
    "note": "In the first sample, the string is ' ( ( ) ( ( ' . The operation described corresponds to deleting the bolded subsequence. The resulting string is ' ( ( ( ' , and no more operations can be performed on it. Another valid answer is choosing indices 2 and 3 , which results in the same final string. In the second sample, it is already impossible to perform any operations.",
    "topics": [
      "constructive algorithms",
      "greedy",
      "strings",
      "two pointers"
    ]
  },
  {
    "title": "Longest Palindrome",
    "url": "https://codeforces.com/problemset/problem/1304/B",
    "history": "Returning back to problem solving, Gildong is now studying about palindromes. He learned that a palindrome is a string that is the same as its reverse. For example, strings \" pop\" , \" noon\" , \" x\" , and \" kkkkkk\" are palindromes, while strings \" moon\" , \" tv\" , and \" abab\" are not. An empty string is also a palindrome. Gildong loves this concept so much, so he wants to play with it. He has n distinct strings of equal length m . He wants to discard some of the strings ( possibly none or all) and reorder the remaining strings so that the concatenation becomes a palindrome. He also wants the palindrome to be as long as possible. Please help him find one.",
    "input": "The first line contains two integers n and m ( 1 \u2264 n \u2264 100 , 1 \u2264 m \u2264 50 ) \u2014 the number of strings and the length of each string. Next n lines contain a string of length m each, consisting of lowercase Latin letters only. All strings are distinct.",
    "output": "In the first line, print the length of the longest palindrome string you made. In the second line, print that palindrome. If there are multiple answers, print any one of them. If the palindrome is empty, print an empty line or don' t print this line at all.",
    "note": "In the first example, \" battab\" is also a valid answer. In the second example, there can be 4 different valid answers including the sample output. We are not going to provide any hints for what the others are. In the third example, the empty string is the only valid palindrome string.",
    "topics": [
      "brute force",
      "constructive algorithms",
      "greedy",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Erase Subsequences",
    "url": "https://codeforces.com/problemset/problem/1303/E",
    "history": "You are given a string s . You can build new string p from s using the following operation no more than two times: choose any subsequence s_ i_ 1, s_ i_ 2, . . . , s_ i_ k where 1 \u2264 i_ 1 < i_ 2 < . . . < i_ k \u2264 | s| ; erase the chosen subsequence from s ( s can become empty) ; concatenate chosen subsequence to the right of the string p ( in other words, p = p + s_ i_ 1s_ i_ 2. . . s_ i_ k ) . Of course, initially the string p is empty. For example, let s = ababcd . At first, let' s choose subsequence s_ 1 s_ 4 s_ 5 = abc \u2014 we will get s = bad and p = abc . At second, let' s choose s_ 1 s_ 2 = ba \u2014 we will get s = d and p = abcba . So we can build abcba from ababcd . Can you build a given string t using the algorithm above?",
    "input": "The first line contains the single integer T ( 1 \u2264 T \u2264 100 ) \u2014 the number of test cases. Next 2T lines contain test cases \u2014 two per test case. The first line contains string s consisting of lowercase Latin letters ( 1 \u2264 | s| \u2264 400 ) \u2014 the initial string. The second line contains string t consisting of lowercase Latin letters ( 1 \u2264 | t| \u2264 | s| ) \u2014 the string you' d like to build. It' s guaranteed that the total length of strings s doesn' t exceed 400 .",
    "output": "Print T answers \u2014 one per test case. Print YES ( case insensitive) if it' s possible to build t and NO ( case insensitive) otherwise.",
    "note": "",
    "topics": [
      "dp",
      "strings"
    ]
  },
  {
    "title": "Erasing Zeroes",
    "url": "https://codeforces.com/problemset/problem/1303/A",
    "history": "You are given a string s . Each character is either 0 or 1. You want all 1' s in the string to form a contiguous subsegment. For example, if the string is 0, 1, 00111 or 01111100, then all 1' s form a contiguous subsegment, and if the string is 0101, 100001 or 11111111111101, then this condition is not met. You may erase some ( possibly none) 0' s from the string. What is the minimum number of 0' s that you have to erase?",
    "input": "The first line contains one integer t ( 1 \u2264 t \u2264 100 ) \u2014 the number of test cases. Then t lines follow, each representing a test case. Each line contains one string s ( 1 \u2264 | s| \u2264 100 ) ; each character of s is either 0 or 1.",
    "output": "Print t integers, where the i - th integer is the answer to the i - th testcase ( the minimum number of 0' s that you have to erase from s ) .",
    "note": "In the first test case you have to delete the third and forth symbols from string 010011 ( it turns into 0111) .",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Ayoub's function",
    "url": "https://codeforces.com/problemset/problem/1301/C",
    "history": "Ayoub thinks that he is a very smart person, so he created a function f( s) , where s is a binary string ( a string which contains only symbols \" 0\" and \" 1\" ) . The function f( s) is equal to the number of substrings in the string s that contains at least one symbol, that is equal to \" 1\" . More formally, f( s) is equal to the number of pairs of integers ( l, r) , such that 1 \u2264 l \u2264 r \u2264 | s| ( where | s| is equal to the length of string s ) , such that at least one of the symbols s_ l, s_ l+ 1, . . . , s_ r is equal to \" 1\" . For example, if s = \" 01010\" then f( s) = 12 , because there are 12 such pairs ( l, r) : ( 1, 2) , ( 1, 3) , ( 1, 4) , ( 1, 5) , ( 2, 2) , ( 2, 3) , ( 2, 4) , ( 2, 5) , ( 3, 4) , ( 3, 5) , ( 4, 4) , ( 4, 5) . Ayoub also thinks that he is smarter than Mahmoud so he gave him two integers n and m and asked him this problem. For all binary strings s of length n which contains exactly m symbols equal to \" 1\" , find the maximum value of f( s) . Mahmoud couldn' t solve the problem so he asked you for help. Can you help him?",
    "input": "The input consists of multiple test cases. The first line contains a single integer t ( 1 \u2264 t \u2264 10^ 5 ) \u2014 the number of test cases. The description of the test cases follows. The only line for each test case contains two integers n , m ( 1 \u2264 n \u2264 10^ 9 , 0 \u2264 m \u2264 n ) \u2014 the length of the string and the number of symbols equal to \" 1\" in it.",
    "output": "For every test case print one integer number \u2014 the maximum value of f( s) over all strings s of length n , which has exactly m symbols, equal to \" 1\" .",
    "note": "In the first test case, there exists only 3 strings of length 3 , which has exactly 1 symbol, equal to \" 1\" . These strings are: s_ 1 = \" 100\" , s_ 2 = \" 010\" , s_ 3 = \" 001\" . The values of f for them are: f( s_ 1) = 3, f( s_ 2) = 4, f( s_ 3) = 3 , so the maximum value is 4 and the answer is 4 . In the second test case, the string s with the maximum value is \" 101\" . In the third test case, the string s with the maximum value is \" 111\" . In the fourth test case, the only string s of length 4 , which has exactly 0 symbols, equal to \" 1\" is \" 0000\" and the value of f for that string is 0 , so the answer is 0 . In the fifth test case, the string s with the maximum value is \" 01010\" and it is described as an example in the problem statement.",
    "topics": [
      "binary search",
      "combinatorics",
      "greedy",
      "math",
      "strings"
    ]
  },
  {
    "title": "Three Strings",
    "url": "https://codeforces.com/problemset/problem/1301/A",
    "history": "You are given three strings a , b and c of the same length n . The strings consist of lowercase English letters only. The i - th letter of a is a_ i , the i - th letter of b is b_ i , the i - th letter of c is c_ i . For every i ( 1 \u2264 i \u2264 n ) you must swap ( i. e. exchange) c_ i with either a_ i or b_ i . So in total you' ll perform exactly n swap operations, each of them either c_ i \u2194 a_ i or c_ i \u2194 b_ i ( i iterates over all integers between 1 and n , inclusive) . For example, if a is \" code\" , b is \" true\" , and c is \" help\" , you can make c equal to \" crue\" taking the 1 - st and the 4 - th letters from a and the others from b . In this way a becomes \" hodp\" and b becomes \" tele\" . Is it possible that after these swaps the string a becomes exactly the same as the string b ?",
    "input": "The input consists of multiple test cases. The first line contains a single integer t ( 1 \u2264 t \u2264 100 ) \u2014 the number of test cases. The description of the test cases follows. The first line of each test case contains a string of lowercase English letters a . The second line of each test case contains a string of lowercase English letters b . The third line of each test case contains a string of lowercase English letters c . It is guaranteed that in each test case these three strings are non- empty and have the same length, which is not exceeding 100 .",
    "output": "Print t lines with answers for all test cases. For each test case: If it is possible to make string a equal to string b print \" YES\" ( without quotes) , otherwise print \" NO\" ( without quotes) . You can print either lowercase or uppercase letters in the answers.",
    "note": "In the first test case, it is impossible to do the swaps so that string a becomes exactly the same as string b . In the second test case, you should swap c_ i with a_ i for all possible i . After the swaps a becomes \" bca\" , b becomes \" bca\" and c becomes \" abc\" . Here the strings a and b are equal. In the third test case, you should swap c_ 1 with a_ 1 , c_ 2 with b_ 2 , c_ 3 with b_ 3 and c_ 4 with a_ 4 . Then string a becomes \" baba\" , string b becomes \" baba\" and string c becomes \" abab\" . Here the strings a and b are equal. In the fourth test case, it is impossible to do the swaps so that string a becomes exactly the same as string b .",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Paint the String",
    "url": "https://codeforces.com/problemset/problem/1297/H",
    "history": "You are given a string s of lowercase Latin letters. It is required to paint each letter of the string in one of two colors ( red or blue) so that if you write all the red letters from left to right and write all the blue letters from left to right, then the lexicographically maximum of the two written strings is lexicographically minimal. For each index, in the string s you can choose either of two colors. Formally, we write out: the string r ( can be empty) \u2014 all red letters in the order from left to right ( red subsequence) , the string b ( can be empty) \u2014 all blue letters in the order from left to right ( blue subsequence) . Your task is to paint the string such that max( r, b) is minimal. Small reminder: the empty string is the lexicographically smallest string.",
    "input": "The first line contains an integer t ( 1 \u2264 t \u2264 100 ) \u2014 the number of test cases in the test. Next, the test cases are given, one per line. Each test case is a non- empty string s of length between 2 to 100 characters, inclusive, which consists of lowercase Latin letters.",
    "output": "Print t lines, the i - th of them should contain the answer to the i - th test case of the input. Print a string of length n , where n is the length of the given string s : the j - th character of the string should be either ' R' or ' B' depending on the color of the j - th character in the answer ( painted in red or blue) . If there are several possible answers, print any of them.",
    "note": "",
    "topics": [
      "*special",
      "dp",
      "strings"
    ]
  },
  {
    "title": "Obtain The String",
    "url": "https://codeforces.com/problemset/problem/1295/C",
    "history": "You are given two strings s and t consisting of lowercase Latin letters. Also you have a string z which is initially empty. You want string z to be equal to string t . You can perform the following operation to achieve this: append any subsequence of s at the end of string z . A subsequence is a sequence that can be derived from the given sequence by deleting zero or more elements without changing the order of the remaining elements. For example, if z = ac , s = abcde , you may turn z into following strings in one operation: z = acace ( if we choose subsequence ace ) ; z = acbcd ( if we choose subsequence bcd ) ; z = acbce ( if we choose subsequence bce ) . Note that after this operation string s doesn' t change. Calculate the minimum number of such operations to turn string z into string t .",
    "input": "The first line contains the integer T ( 1 \u2264 T \u2264 100 ) \u2014 the number of test cases. The first line of each testcase contains one string s ( 1 \u2264 | s| \u2264 10^ 5 ) consisting of lowercase Latin letters. The second line of each testcase contains one string t ( 1 \u2264 | t| \u2264 10^ 5 ) consisting of lowercase Latin letters. It is guaranteed that the total length of all strings s and t in the input does not exceed 2 \u00b7 10^ 5 .",
    "output": "For each testcase, print one integer \u2014 the minimum number of operations to turn string z into string t . If it' s impossible print - 1 .",
    "note": "",
    "topics": [
      "dp",
      "greedy",
      "strings"
    ]
  },
  {
    "title": "Infinite Prefixes",
    "url": "https://codeforces.com/problemset/problem/1295/B",
    "history": "You are given string s of length n consisting of 0- s and 1- s. You build an infinite string t as a concatenation of an infinite number of strings s , or t = ssss . . . For example, if s = 10010, then t = 100101001010010. . . Calculate the number of prefixes of t with balance equal to x . The balance of some string q is equal to cnt_ 0, q - cnt_ 1, q , where cnt_ 0, q is the number of occurrences of 0 in q , and cnt_ 1, q is the number of occurrences of 1 in q . The number of such prefixes can be infinite; if it is so, you must say that. A prefix is a string consisting of several first letters of a given string, without any reorders. An empty prefix is also a valid prefix. For example, the string \" abcd\" has 5 prefixes: empty string, \" a\" , \" ab\" , \" abc\" and \" abcd\" .",
    "input": "The first line contains the single integer T ( 1 \u2264 T \u2264 100 ) \u2014 the number of test cases. Next 2T lines contain descriptions of test cases \u2014 two lines per test case. The first line contains two integers n and x ( 1 \u2264 n \u2264 10^ 5 , - 10^ 9 \u2264 x \u2264 10^ 9 ) \u2014 the length of string s and the desired balance, respectively. The second line contains the binary string s ( | s| = n , s_ i \u2208{ 0, 1} ) . It' s guaranteed that the total sum of n doesn' t exceed 10^ 5 .",
    "output": "Print T integers \u2014 one per test case. For each test case print the number of prefixes or - 1 if there is an infinite number of such prefixes.",
    "note": "In the first test case, there are 3 good prefixes of t : with length 28 , 30 and 32 .",
    "topics": [
      "math",
      "strings"
    ]
  },
  {
    "title": "Even But Not Even",
    "url": "https://codeforces.com/problemset/problem/1291/A",
    "history": "Let' s define a number ebne ( even but not even) if and only if its sum of digits is divisible by 2 but the number itself is not divisible by 2 . For example, 13 , 1227 , 185217 are ebne numbers, while 12 , 2 , 177013 , 265918 are not. If you' re still unsure what ebne numbers are, you can look at the sample notes for more clarification. You are given a non- negative integer s , consisting of n digits. You can delete some digits ( they are not necessary consecutive/ successive) to make the given number ebne. You cannot change the order of the digits, that is, after deleting the digits the remaining digits collapse. The resulting number shouldn' t contain leading zeros. You can delete any number of digits between 0 ( do not delete any digits at all) and n- 1 . For example, if you are given s= 222373204424185217171912 then one of possible ways to make it ebne is: 222373204424185217171912 \u2192 2237344218521717191. The sum of digits of 2237344218521717191 is equal to 70 and is divisible by 2 , but number itself is not divisible by 2 : it means that the resulting number is ebne. Find any resulting number that is ebne. If it' s impossible to create an ebne number from the given number report about it.",
    "input": "The input consists of multiple test cases. The first line contains a single integer t ( 1 \u2264 t \u2264 1000 ) \u2014 the number of test cases. The description of the test cases follows. The first line of each test case contains a single integer n ( 1 \u2264 n \u2264 3000 ) \u2014 the number of digits in the original number. The second line of each test case contains a non- negative integer number s , consisting of n digits. It is guaranteed that s does not contain leading zeros and the sum of n over all test cases does not exceed 3000 .",
    "output": "For each test case given in the input print the answer in the following format: If it is impossible to create an ebne number, print \" - 1\" ( without quotes) ; Otherwise, print the resulting number after deleting some, possibly zero, but not all digits. This number should be ebne. If there are multiple answers, you can print any of them. Note that answers with leading zeros or empty strings are not accepted. It' s not necessary to minimize or maximize the number of deleted digits.",
    "note": "In the first test case of the example, 1227 is already an ebne number ( as 1 + 2 + 2 + 7 = 12 , 12 is divisible by 2 , while in the same time, 1227 is not divisible by 2 ) so we don' t need to delete any digits. Answers such as 127 and 17 will also be accepted. In the second test case of the example, it is clearly impossible to create an ebne number from the given number. In the third test case of the example, there are many ebne numbers we can obtain by deleting, for example, 1 digit such as 17703 , 77013 or 17013 . Answers such as 1701 or 770 will not be accepted as they are not ebne numbers. Answer 013 will not be accepted as it contains leading zeroes. Explanation: 1 + 7 + 7 + 0 + 3 = 18 . As 18 is divisible by 2 while 17703 is not divisible by 2 , we can see that 17703 is an ebne number. Same with 77013 and 17013 ; 1 + 7 + 0 + 1 = 9 . Because 9 is not divisible by 2 , 1701 is not an ebne number; 7 + 7 + 0 = 14 . This time, 14 is divisible by 2 but 770 is also divisible by 2 , therefore, 770 is not an ebne number. In the last test case of the example, one of many other possible answers is given. Another possible answer is: 222373204424185217171912 \u2192 22237320442418521717191 ( delete the last digit) .",
    "topics": [
      "greedy",
      "math",
      "strings"
    ]
  },
  {
    "title": "Irreducible Anagrams",
    "url": "https://codeforces.com/problemset/problem/1290/B",
    "history": "Let' s call two strings s and t anagrams of each other if it is possible to rearrange symbols in the string s to get a string, equal to t . Let' s consider two strings s and t which are anagrams of each other. We say that t is a reducible anagram of s if there exists an integer k \u2265 2 and 2k non- empty strings s_ 1, t_ 1, s_ 2, t_ 2, . . . , s_ k, t_ k that satisfy the following conditions: If we write the strings s_ 1, s_ 2, . . . , s_ k in order, the resulting string will be equal to s ; If we write the strings t_ 1, t_ 2, . . . , t_ k in order, the resulting string will be equal to t ; For all integers i between 1 and k inclusive, s_ i and t_ i are anagrams of each other. If such strings don' t exist, then t is said to be an irreducible anagram of s . Note that these notions are only defined when s and t are anagrams of each other. For example, consider the string s = \" gamegame\" . Then the string t = \" megamage\" is a reducible anagram of s , we may choose for example s_ 1 = \" game\" , s_ 2 = \" gam\" , s_ 3 = \" e\" and t_ 1 = \" mega\" , t_ 2 = \" mag\" , t_ 3 = \" e\" : On the other hand, we can prove that t = \" memegaga\" is an irreducible anagram of s . You will be given a string s and q queries, represented by two integers 1 \u2264 l \u2264 r \u2264 | s| ( where | s| is equal to the length of the string s ) . For each query, you should find if the substring of s formed by characters from the l - th to the r - th has at least one irreducible anagram.",
    "input": "The first line contains a string s , consisting of lowercase English characters ( 1 \u2264 | s| \u2264 2 \u00b7 10^ 5 ) . The second line contains a single integer q ( 1 \u2264 q \u2264 10^ 5 ) \u2014 the number of queries. Each of the following q lines contain two integers l and r ( 1 \u2264 l \u2264 r \u2264 | s| ) , representing a query for the substring of s formed by characters from the l - th to the r - th.",
    "output": "For each query, print a single line containing \" Yes\" ( without quotes) if the corresponding substring has at least one irreducible anagram, and a single line containing \" No\" ( without quotes) otherwise.",
    "note": "In the first sample, in the first and third queries, the substring is \" a\" , which has itself as an irreducible anagram since two or more non- empty strings cannot be put together to obtain \" a\" . On the other hand, in the second query, the substring is \" aaa\" , which has no irreducible anagrams: its only anagram is itself, and we may choose s_ 1 = \" a\" , s_ 2 = \" aa\" , t_ 1 = \" a\" , t_ 2 = \" aa\" to show that it is a reducible anagram. In the second query of the second sample, the substring is \" abb\" , which has, for example, \" bba\" as an irreducible anagram.",
    "topics": [
      "binary search",
      "constructive algorithms",
      "data structures",
      "strings",
      "two pointers"
    ]
  },
  {
    "title": "Fedya the Potter Strikes Back",
    "url": "https://codeforces.com/problemset/problem/1286/E",
    "history": "Fedya has a string S , initially empty, and an array W , also initially empty. There are n queries to process, one at a time. Query i consists of a lowercase English letter c_ i and a nonnegative integer w_ i . First, c_ i must be appended to S , and w_ i must be appended to W . The answer to the query is the sum of suspiciousnesses for all subsegments of W [ L, R] , ( 1 \u2264 L \u2264 R \u2264 i) . We define the suspiciousness of a subsegment as follows: if the substring of S corresponding to this subsegment ( that is, a string of consecutive characters from L - th to R - th, inclusive) matches the prefix of S of the same length ( that is, a substring corresponding to the subsegment [ 1, R - L + 1] ) , then its suspiciousness is equal to the minimum in the array W on the [ L, R] subsegment. Otherwise, in case the substring does not match the corresponding prefix, the suspiciousness is 0 . Help Fedya answer all the queries before the orderlies come for him!",
    "input": "The first line contains an integer n ( 1 \u2264 n \u2264 600 000) \u2014 the number of queries. The i - th of the following n lines contains the query i : a lowercase letter of the Latin alphabet c_ i and an integer w_ i ( 0 \u2264 w_ i \u2264 2^ 30 - 1) . All queries are given in an encrypted form. Let ans be the answer to the previous query ( for the first query we set this value equal to 0 ) . Then, in order to get the real query, you need to do the following: perform a cyclic shift of c_ i in the alphabet forward by ans , and set w_ i equal to w_ i \u2295 ( ans & MASK) , where \u2295 is the bitwise exclusive \" or\" , & is the bitwise \" and\" , and MASK = 2^ 30 - 1 .",
    "output": "Print n lines, i - th line should contain a single integer \u2014 the answer to the i - th query.",
    "note": "For convenience, we will call \" suspicious\" those subsegments for which the corresponding lines are prefixes of S , that is, those whose suspiciousness may not be zero. As a result of decryption in the first example, after all requests, the string S is equal to \" abacaba\" , and all w_ i = 1 , that is, the suspiciousness of all suspicious sub- segments is simply equal to 1 . Let' s see how the answer is obtained after each request: 1. S = \" a\" , the array W has a single subsegment \u2014 [ 1, 1] , and the corresponding substring is \" a\" , that is, the entire string S , thus it is a prefix of S , and the suspiciousness of the subsegment is 1 . 2. S = \" ab\" , suspicious subsegments: [ 1, 1] and [ 1, 2] , total 2 . 3. S = \" aba\" , suspicious subsegments: [ 1, 1] , [ 1, 2] , [ 1, 3] and [ 3, 3] , total 4 . 4. S = \" abac\" , suspicious subsegments: [ 1, 1] , [ 1, 2] , [ 1, 3] , [ 1, 4] and [ 3, 3] , total 5 . 5. S = \" abaca\" , suspicious subsegments: [ 1, 1] , [ 1, 2] , [ 1, 3] , [ 1, 4] , [ 1, 5] , [ 3, 3] and [ 5, 5] , total 7 . 6. S = \" abacab\" , suspicious subsegments: [ 1, 1] , [ 1, 2] , [ 1, 3] , [ 1, 4] , [ 1, 5] , [ 1, 6] , [ 3, 3] , [ 5, 5] and [ 5, 6] , total 9 . 7. S = \" abacaba\" , suspicious subsegments: [ 1, 1] , [ 1, 2] , [ 1, 3] , [ 1, 4] , [ 1, 5] , [ 1, 6] , [ 1, 7] , [ 3, 3] , [ 5, 5] , [ 5, 6] , [ 5, 7] and [ 7, 7] , total 12 . In the second example, after all requests S = \" aaba\" , W = [ 2, 0, 2, 0] . 1. S = \" a\" , suspicious subsegments: [ 1, 1] ( suspiciousness 2 ) , totaling 2 . 2. S = \" aa\" , suspicious subsegments: [ 1, 1] ( 2 ) , [ 1, 2] ( 0 ) , [ 2, 2] ( 0 ) , totaling 2 . 3. S = \" aab\" , suspicious subsegments: [ 1, 1] ( 2 ) , [ 1, 2] ( 0 ) , [ 1, 3] ( 0 ) , [ 2, 2] ( 0 ) , totaling 2 . 4. S = \" aaba\" , suspicious subsegments: [ 1, 1] ( 2 ) , [ 1, 2] ( 0 ) , [ 1, 3] ( 0 ) , [ 1, 4] ( 0 ) , [ 2, 2] ( 0 ) , [ 4, 4] ( 0 ) , totaling 2 . In the third example, from the condition after all requests S = \" abcde\" , W = [ 7, 2, 10, 1, 7] . 1. S = \" a\" , suspicious subsegments: [ 1, 1] ( 7 ) , totaling 7 . 2. S = \" ab\" , suspicious subsegments: [ 1, 1] ( 7 ) , [ 1, 2] ( 2 ) , totaling 9 . 3. S = \" abc\" , suspicious subsegments: [ 1, 1] ( 7 ) , [ 1, 2] ( 2 ) , [ 1, 3] ( 2 ) , totaling 11 . 4. S = \" abcd\" , suspicious subsegments: [ 1, 1] ( 7 ) , [ 1, 2] ( 2 ) , [ 1, 3] ( 2 ) , [ 1, 4] ( 1 ) , totaling 12 . 5. S = \" abcde\" , suspicious subsegments: [ 1, 1] ( 7 ) , [ 1, 2] ( 2 ) , [ 1, 3] ( 2 ) , [ 1, 4] ( 1 ) , [ 1, 5] ( 1 ) , totaling 13 .",
    "topics": [
      "data structures",
      "strings"
    ]
  },
  {
    "title": "Dr. Evil Underscores",
    "url": "https://codeforces.com/problemset/problem/1285/D",
    "history": "Today, as a friendship gift, Bakry gave Badawy n integers a_ 1, a_ 2, . . . , a_ n and challenged him to choose an integer X such that the value 1 \u2264 i \u2264 nmax ( a_ i \u2295 X) is minimum possible, where \u2295 denotes the bitwise XOR operation. As always, Badawy is too lazy, so you decided to help him and find the minimum possible value of 1 \u2264 i \u2264 nmax ( a_ i \u2295 X) .",
    "input": "The first line contains integer n ( 1\u2264 n \u2264 10^ 5 ) . The second line contains n integers a_ 1, a_ 2, . . . , a_ n ( 0 \u2264 a_ i \u2264 2^ 30- 1 ) .",
    "output": "Print one integer \u2014 the minimum possible value of 1 \u2264 i \u2264 nmax ( a_ i \u2295 X) .",
    "note": "In the first sample, we can choose X = 3 . In the second sample, we can choose X = 5 .",
    "topics": [
      "bitmasks",
      "brute force",
      "dfs and similar",
      "divide and conquer",
      "dp",
      "greedy",
      "strings",
      "trees"
    ]
  },
  {
    "title": "New Year and Naming",
    "url": "https://codeforces.com/problemset/problem/1284/A",
    "history": "Happy new year! The year 2020 is also known as Year Gyeongja ( \u1100\u1167\u11bc\u110c\u1161\u1102\u1167\u11ab, gyeongja- nyeon) in Korea. Where did the name come from? Let' s briefly look at the Gapja system, which is traditionally used in Korea to name the years. There are two sequences of n strings s_ 1, s_ 2, s_ 3, . . . , s_ n and m strings t_ 1, t_ 2, t_ 3, . . . , t_ m . These strings contain only lowercase letters. There might be duplicates among these strings. Let' s call a concatenation of strings x and y as the string that is obtained by writing down strings x and y one right after another without changing the order. For example, the concatenation of the strings \" code\" and \" forces\" is the string \" codeforces\" . The year 1 has a name which is the concatenation of the two strings s_ 1 and t_ 1 . When the year increases by one, we concatenate the next two strings in order from each of the respective sequences. If the string that is currently being used is at the end of its sequence, we go back to the first string in that sequence. For example, if n = 3, m = 4, s = \" a\" , \" b\" , \" c\" , t = \" d\" , \" e\" , \" f\" , \" g\" , the following table denotes the resulting year names. Note that the names of the years may repeat. You are given two sequences of strings of size n and m and also q queries. For each query, you will be given the current year. Could you find the name corresponding to the given year, according to the Gapja system?",
    "input": "The first line contains two integers n, m ( 1 \u2264 n, m \u2264 20 ) . The next line contains n strings s_ 1, s_ 2, . . . , s_ n . Each string contains only lowercase letters, and they are separated by spaces. The length of each string is at least 1 and at most 10 . The next line contains m strings t_ 1, t_ 2, . . . , t_ m . Each string contains only lowercase letters, and they are separated by spaces. The length of each string is at least 1 and at most 10 . Among the given n + m strings may be duplicates ( that is, they are not necessarily all different) . The next line contains a single integer q ( 1 \u2264 q \u2264 2 020 ) . In the next q lines, an integer y ( 1 \u2264 y \u2264 10^ 9 ) is given, denoting the year we want to know the name for.",
    "output": "Print q lines. For each line, print the name of the year as per the rule described above.",
    "note": "The first example denotes the actual names used in the Gapja system. These strings usually are either a number or the name of some animal.",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Enchanted Artifact",
    "url": "https://codeforces.com/problemset/problem/1282/D",
    "history": "This is an interactive problem. After completing the last level of the enchanted temple, you received a powerful artifact of the 255th level. Do not rush to celebrate, because this artifact has a powerful rune that can be destroyed with a single spell s , which you are going to find. We define the spell as some non- empty string consisting only of the letters a and b. At any time, you can cast an arbitrary non- empty spell t , and the rune on the artifact will begin to resist. Resistance of the rune is the edit distance between the strings that specify the casted spell t and the rune- destroying spell s . Edit distance of two strings s and t is a value equal to the minimum number of one- character operations of replacing, inserting and deleting characters in s to get t . For example, the distance between ababa and aaa is 2 , the distance between aaa and aba is 1 , the distance between bbaba and abb is 3 . The edit distance is 0 if and only if the strings are equal. It is also worth considering that the artifact has a resistance limit \u2014 if you cast more than n + 2 spells, where n is the length of spell s , the rune will be blocked. Thus, it takes n + 2 or fewer spells to destroy the rune that is on your artifact. Keep in mind that the required destructive spell s must also be counted among these n + 2 spells. Note that the length n of the rune- destroying spell s is not known to you in advance. It is only known that its length n does not exceed 300 . InteractionInteraction is happening through queries. Each request consists of a single non- empty string t \u2014 the spell you want to cast. The length of string t should not exceed 300 . Each string should consist only of the letters a and b. In response to the query, you will get resistance runes \u2014 the edit distance between the strings that specify the casted spell t and the secret rune- destroying spell s . Remember that s contains only the letters a and b. After breaking the rune, your program should end immediately. A rune is destroyed when you get a response with resistance 0 . After receiving the value 0 , your program should terminate normally. In this problem interactor is not adaptive. This means that during any test the rune- destroying spell s does not change. If your query is invalid, - 1 will be returned. After receiving this your program should immediately terminate normally ( for example, by calling exit( 0) ) , otherwise, the testing system may issue an arbitrary verdict. If the number of spells exceeds limit ( n + 2 , where n is the length of the spell s , which is unknown to you) , you will get the Wrong Answer verdict. Your solution may receive the verdict Idleness Limit Exceeded if you don' t output anything or forget to flush the output buffer. To flush the output buffer, you need to do the following immediately after printing the query and the line end: fflush( stdout) or cout. flush( ) in C+ + ; System. out. flush( ) in Java; flush( output) in Pascal; stdout. flush( ) in Python; for other languages see documentation. HacksFor hacks, use the following format: In a single line print the string s ( 1 \u2264 | s| \u2264 300 ) of letters a and b, which defines the rune- destroying spell. The hacked solution will not have direct access to the unknown spell.",
    "input": "",
    "output": "",
    "note": "",
    "topics": [
      "constructive algorithms",
      "interactive",
      "strings"
    ]
  },
  {
    "title": "Shuffle Hashing",
    "url": "https://codeforces.com/problemset/problem/1278/A",
    "history": "Polycarp has built his own web service. Being a modern web service it includes login feature. And that always implies password security problems. Polycarp decided to store the hash of the password, generated by the following algorithm: take the password p , consisting of lowercase Latin letters, and shuffle the letters randomly in it to obtain p' ( p' can still be equal to p ) ; generate two random strings, consisting of lowercase Latin letters, s_ 1 and s_ 2 ( any of these strings can be empty) ; the resulting hash h = s_ 1 + p' + s_ 2 , where addition is string concatenation. For example, let the password p = \" abacaba\" . Then p' can be equal to \" aabcaab\" . Random strings s1 = \" zyx\" and s2 = \" kjh\" . Then h = \" zyxaabcaabkjh\" . Note that no letters could be deleted or added to p to obtain p' , only the order could be changed. Now Polycarp asks you to help him to implement the password check module. Given the password p and the hash h , check that h can be the hash for the password p . Your program should answer t independent test cases.",
    "input": "The first line contains one integer t ( 1 \u2264 t \u2264 100 ) \u2014 the number of test cases. The first line of each test case contains a non- empty string p , consisting of lowercase Latin letters. The length of p does not exceed 100 . The second line of each test case contains a non- empty string h , consisting of lowercase Latin letters. The length of h does not exceed 100 .",
    "output": "For each test case print the answer to it \u2014 \" YES\" if the given hash h could be obtained from the given password p or \" NO\" otherwise.",
    "note": "The first test case is explained in the statement. In the second test case both s_ 1 and s_ 2 are empty and p' = \" threetwoone\" is p shuffled. In the third test case the hash could not be obtained from the password. In the fourth test case s_ 1= \" n\" , s_ 2 is empty and p' = \" one\" is p shuffled ( even thought it stayed the same) . In the fifth test case the hash could not be obtained from the password.",
    "topics": [
      "brute force",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Two Bracket Sequences",
    "url": "https://codeforces.com/problemset/problem/1272/F",
    "history": "You are given two bracket sequences ( not necessarily regular) s and t consisting only of characters ' ( ' and ' ) ' . You want to construct the shortest regular bracket sequence that contains both given bracket sequences as subsequences ( not necessarily contiguous) . Recall what is the regular bracket sequence: ( ) is the regular bracket sequence; if S is the regular bracket sequence, then ( S ) is a regular bracket sequence; if S and T regular bracket sequences, then ST ( concatenation of S and T ) is a regular bracket sequence. Recall that the subsequence of the string s is such string t that can be obtained from s by removing some ( possibly, zero) amount of characters. For example, \" coder\" , \" force\" , \" cf\" and \" cores\" are subsequences of \" codeforces\" , but \" fed\" and \" z\" are not.",
    "input": "The first line of the input contains one bracket sequence s consisting of no more than 200 characters ' ( ' and ' ) ' . The second line of the input contains one bracket sequence t consisting of no more than 200 characters ' ( ' and ' ) ' .",
    "output": "Print one line \u2014 the shortest regular bracket sequence that contains both given bracket sequences as subsequences ( not necessarily contiguous) . If there are several answers, you can print any.",
    "note": "",
    "topics": [
      "dp",
      "strings",
      "two pointers"
    ]
  },
  {
    "title": "Awesome Substrings",
    "url": "https://codeforces.com/problemset/problem/1270/F",
    "history": "Let' s call a binary string s awesome, if it has at least 1 symbol 1 and length of the string is divisible by the number of 1 in it. In particular, 1, 1010, 111 are awesome, but 0, 110, 01010 aren' t. You are given a binary string s . Count the number of its awesome substrings. A string a is a substring of a string b if a can be obtained from b by deletion of several ( possibly, zero or all) characters from the beginning and several ( possibly, zero or all) characters from the end.",
    "input": "The first line contains the string s ( 1 \u2264 | s| \u2264 200 000 ) consisting only of zeros and ones.",
    "output": "Output a single number \u2014 the number of awesome substrings of s .",
    "note": "In the first sample, all substrings of s are awesome. In the second sample, we have the following awesome substrings of s : 1 ( 2 times) , 01 ( 2 times) , 10 ( 2 times) , 010 ( 2 times) , 1010, 0101In the third sample, no substring is awesome.",
    "topics": [
      "math",
      "strings"
    ]
  },
  {
    "title": "Long Beautiful Integer",
    "url": "https://codeforces.com/problemset/problem/1268/A",
    "history": "You are given an integer x of n digits a_ 1, a_ 2, . . . , a_ n , which make up its decimal notation in order from left to right. Also, you are given a positive integer k < n . Let' s call integer b_ 1, b_ 2, . . . , b_ m beautiful if b_ i = b_ i+ k for each i , such that 1 \u2264 i \u2264 m - k . You need to find the smallest beautiful integer y , such that y \u2265 x .",
    "input": "The first line of input contains two integers n, k ( 2 \u2264 n \u2264 200 000, 1 \u2264 k < n ) : the number of digits in x and k . The next line of input contains n digits a_ 1, a_ 2, . . . , a_ n ( a_ 1 = \u0338 0 , 0 \u2264 a_ i \u2264 9 ) : digits of x .",
    "output": "In the first line print one integer m : the number of digits in y . In the next line print m digits b_ 1, b_ 2, . . . , b_ m ( b_ 1 = \u0338 0 , 0 \u2264 b_ i \u2264 9 ) : digits of y .",
    "note": "",
    "topics": [
      "constructive algorithms",
      "greedy",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Lexicography",
    "url": "https://codeforces.com/problemset/problem/1267/L",
    "history": "Lucy likes letters. She studied the definition of the lexicographical order at school and plays with it. At first, she tried to construct the lexicographically smallest word out of given letters. It was so easy! Then she tried to build multiple words and minimize one of them. This was much harder! Formally, Lucy wants to make n words of length l each out of the given n \u00b7 l letters, so that the k - th of them in the lexicographic order is lexicographically as small as possible.",
    "input": "The first line contains three integers n , l , and k ( 1\u2264 k \u2264 n \u2264 1 000 ; 1 \u2264 l \u2264 1 000 ) \u2014 the total number of words, the length of each word, and the index of the word Lucy wants to minimize. The next line contains a string of n \u00b7 l lowercase letters of the English alphabet.",
    "output": "Output n words of l letters each, one per line, using the letters from the input. Words must be sorted in the lexicographic order, and the k - th of them must be lexicographically as small as possible. If there are multiple answers with the smallest k - th word, output any of them.",
    "note": "",
    "topics": [
      "constructive algorithms",
      "strings"
    ]
  },
  {
    "title": "Dominated Subarray",
    "url": "https://codeforces.com/problemset/problem/1257/C",
    "history": "Let' s call an array t dominated by value v in the next situation. At first, array t should have at least 2 elements. Now, let' s calculate number of occurrences of each number num in t and define it as occ( num) . Then t is dominated ( by v ) if ( and only if) occ( v) > occ( v' ) for any other number v' . For example, arrays [ 1, 2, 3, 4, 5, 2] , [ 11, 11] and [ 3, 2, 3, 2, 3] are dominated ( by 2 , 11 and 3 respectevitely) but arrays [ 3] , [ 1, 2] and [ 3, 3, 2, 2, 1] are not. Small remark: since any array can be dominated only by one number, we can not specify this number and just say that array is either dominated or not. You are given array a_ 1, a_ 2, . . . , a_ n . Calculate its shortest dominated subarray or say that there are no such subarrays. The subarray of a is a contiguous part of the array a , i. e. the array a_ i, a_ i + 1, . . . , a_ j for some 1 \u2264 i \u2264 j \u2264 n .",
    "input": "The first line contains single integer T ( 1 \u2264 T \u2264 1000 ) \u2014 the number of test cases. Each test case consists of two lines. The first line contains single integer n ( 1 \u2264 n \u2264 2 \u00b7 10^ 5 ) \u2014 the length of the array a . The second line contains n integers a_ 1, a_ 2, . . . , a_ n ( 1 \u2264 a_ i \u2264 n ) \u2014 the corresponding values of the array a . It' s guaranteed that the total length of all arrays in one test doesn' t exceed 2 \u00b7 10^ 5 .",
    "output": "Print T integers \u2014 one per test case. For each test case print the only integer \u2014 the length of the shortest dominated subarray, or - 1 if there are no such subarrays.",
    "note": "In the first test case, there are no subarrays of length at least 2 , so the answer is - 1 . In the second test case, the whole array is dominated ( by 1 ) and it' s the only dominated subarray. In the third test case, the subarray a_ 4, a_ 5, a_ 6 is the shortest dominated subarray. In the fourth test case, all subarrays of length more than one are dominated.",
    "topics": [
      "greedy",
      "implementation",
      "sortings",
      "strings",
      "two pointers"
    ]
  },
  {
    "title": "Equalizing Two Strings",
    "url": "https://codeforces.com/problemset/problem/1256/F",
    "history": "You are given two strings s and t both of length n and both consisting of lowercase Latin letters. In one move, you can choose any length len from 1 to n and perform the following operation: Choose any contiguous substring of the string s of length len and reverse it; at the same time choose any contiguous substring of the string t of length len and reverse it as well. Note that during one move you reverse exactly one substring of the string s and exactly one substring of the string t . Also note that borders of substrings you reverse in s and in t can be different, the only restriction is that you reverse the substrings of equal length. For example, if len= 3 and n= 5 , you can reverse s[ 1 . . . 3] and t[ 3 . . . 5] , s[ 2 . . . 4] and t[ 2 . . . 4] , but not s[ 1 . . . 3] and t[ 1 . . . 2] . Your task is to say if it is possible to make strings s and t equal after some ( possibly, empty) sequence of moves. You have to answer q independent test cases.",
    "input": "The first line of the input contains one integer q ( 1 \u2264 q \u2264 10^ 4 ) \u2014 the number of test cases. Then q test cases follow. The first line of the test case contains one integer n ( 1 \u2264 n \u2264 2 \u00b7 10^ 5 ) \u2014 the length of s and t . The second line of the test case contains one string s consisting of n lowercase Latin letters. The third line of the test case contains one string t consisting of n lowercase Latin letters. It is guaranteed that the sum of n over all test cases does not exceed 2 \u00b7 10^ 5 ( \u2211 n \u2264 2 \u00b7 10^ 5 ) .",
    "output": "For each test case, print the answer on it \u2014 \" YES\" ( without quotes) if it is possible to make strings s and t equal after some ( possibly, empty) sequence of moves and \" NO\" otherwise.",
    "note": "",
    "topics": [
      "constructive algorithms",
      "sortings",
      "strings"
    ]
  },
  {
    "title": "Find String in a Grid",
    "url": "https://codeforces.com/problemset/problem/1252/D",
    "history": "You have a grid G containing R rows ( numbered from 1 to R , top to bottom) and C columns ( numbered from 1 to C , left to right) of uppercase characters. The character in the r^ th row and the c^ th column is denoted by G_ r, c . You also have Q strings containing uppercase characters. For each of the string, you want to find the number of occurrences of the string in the grid. An occurrence of string S in the grid is counted if S can be constructed by starting at one of the cells in the grid, going right 0 or more times, and then going down 0 or more times. Two occurrences are different if the set of cells used to construct the string is different. Formally, for each string S , you would like to count the number of tuples \u27e8 r, c, \u0394 r, \u0394 c \u27e9 such that: 1 \u2264 r \u2264 R and r \u2264 r + \u0394 r \u2264 R 1 \u2264 c \u2264 C and c \u2264 c + \u0394 c \u2264 C S = G_ r, c G_ r, c + 1. . . G_ r, c + \u0394 c G_ r + 1, c + \u0394 c. . . G_ r + \u0394 r, c + \u0394 c",
    "input": "Input begins with a line containing three integers: R C Q ( 1 \u2264 R, C \u2264 500 ; 1 \u2264 Q \u2264 200 000 ) representing the size of the grid and the number of strings, respectively. The next R lines each contains C uppercase characters representing the grid. The c^ th character on the r^ th line is G_ r, c . The next Q lines each contains a string S containing uppercase characters. The length of this string is a positive integer not more than 200 000 . The sum of the length of all Q strings combined is not more than 200 000 .",
    "output": "For each query in the same order as input, output in a line an integer representing the number of occurrences of the string in the grid.",
    "note": "Explanation for the sample input/ output # 1 There are 2 occurrences of \" ABC\" , represented by the tuples \u27e8 1, 1, 1, 1 \u27e9 and \u27e8 1, 1, 0, 2 \u27e9 . There are 3 occurrences of \" BC\" , represented by the tuples \u27e8 1, 2, 0, 1 \u27e9 , \u27e8 1, 2, 1, 0 \u27e9 , and \u27e8 2, 1, 0, 1 \u27e9 . There is 1 occurrence of \" BD\" , represented by the tuple \u27e8 2, 1, 1, 0 \u27e9 . There is no occurrence of \" AC\" . There are 2 occurrences of \" A\" , represented by the tuples \u27e8 1, 1, 0, 0 \u27e9 and \u27e8 3, 2, 0, 0 \u27e9 .",
    "topics": [
      "data structures",
      "dp",
      "strings",
      "trees"
    ]
  },
  {
    "title": "Binary Palindromes",
    "url": "https://codeforces.com/problemset/problem/1251/B",
    "history": "A palindrome is a string t which reads the same backward as forward ( formally, t[ i] = t[ | t| + 1 - i] for all i \u2208 [ 1, | t| ] ) . Here | t| denotes the length of a string t . For example, the strings 010, 1001 and 0 are palindromes. You have n binary strings s_ 1, s_ 2, . . . , s_ n ( each s_ i consists of zeroes and/ or ones) . You can swap any pair of characters any number of times ( possibly, zero) . Characters can be either from the same string or from different strings \u2014 there are no restrictions. Formally, in one move you: choose four integer numbers x, a, y, b such that 1 \u2264 x, y \u2264 n and 1 \u2264 a \u2264 | s_ x| and 1 \u2264 b \u2264 | s_ y| ( where x and y are string indices and a and b are positions in strings s_ x and s_ y respectively) , swap ( exchange) the characters s_ x[ a] and s_ y[ b] . What is the maximum number of strings you can make palindromic simultaneously?",
    "input": "The first line contains single integer Q ( 1 \u2264 Q \u2264 50 ) \u2014 the number of test cases. The first line on each test case contains single integer n ( 1 \u2264 n \u2264 50 ) \u2014 the number of binary strings you have. Next n lines contains binary strings s_ 1, s_ 2, . . . , s_ n \u2014 one per line. It' s guaranteed that 1 \u2264 | s_ i| \u2264 50 and all strings constist of zeroes and/ or ones.",
    "output": "Print Q integers \u2014 one per test case. The i - th integer should be the maximum number of palindromic strings you can achieve simultaneously performing zero or more swaps on strings from the i - th test case.",
    "note": "In the first test case, s_ 1 is palindrome, so the answer is 1 . In the second test case you can' t make all three strings palindromic at the same time, but you can make any pair of strings palindromic. For example, let' s make s_ 1 = 0110 , s_ 2 = 111111 and s_ 3 = 010000 . In the third test case we can make both strings palindromic. For example, s_ 1 = 11011 and s_ 2 = 100001 . In the last test case s_ 2 is palindrome and you can make s_ 1 palindrome, for example, by swapping s_ 1[ 2] and s_ 1[ 3] .",
    "topics": [
      "greedy",
      "strings"
    ]
  },
  {
    "title": "Broken Keyboard",
    "url": "https://codeforces.com/problemset/problem/1251/A",
    "history": "Recently Polycarp noticed that some of the buttons of his keyboard are malfunctioning. For simplicity, we assume that Polycarp' s keyboard contains 26 buttons ( one for each letter of the Latin alphabet) . Each button is either working fine or malfunctioning. To check which buttons need replacement, Polycarp pressed some buttons in sequence, and a string s appeared on the screen. When Polycarp presses a button with character c , one of the following events happened: if the button was working correctly, a character c appeared at the end of the string Polycarp was typing; if the button was malfunctioning, two characters c appeared at the end of the string. For example, suppose the buttons corresponding to characters a and c are working correctly, and the button corresponding to b is malfunctioning. If Polycarp presses the buttons in the order a, b, a, c, a, b, a, then the string he is typing changes as follows: a \u2192 abb \u2192 abba \u2192 abbac \u2192 abbaca \u2192 abbacabb \u2192 abbacabba. You are given a string s which appeared on the screen after Polycarp pressed some buttons. Help Polycarp to determine which buttons are working correctly for sure ( that is, this string could not appear on the screen if any of these buttons was malfunctioning) . You may assume that the buttons don' t start malfunctioning when Polycarp types the string: each button either works correctly throughout the whole process, or malfunctions throughout the whole process.",
    "input": "The first line contains one integer t ( 1 \u2264 t \u2264 100 ) \u2014 the number of test cases in the input. Then the test cases follow. Each test case is represented by one line containing a string s consisting of no less than 1 and no more than 500 lowercase Latin letters.",
    "output": "For each test case, print one line containing a string res . The string res should contain all characters which correspond to buttons that work correctly in alphabetical order, without any separators or repetitions. If all buttons may malfunction, res should be empty.",
    "note": "",
    "topics": [
      "brute force",
      "strings",
      "two pointers"
    ]
  },
  {
    "title": "Character Swap (Hard Version)",
    "url": "https://codeforces.com/problemset/problem/1243/B2",
    "history": "This problem is different from the easy version. In this version Ujan makes at most 2n swaps. In addition, k \u2264 1000, n \u2264 50 and it is necessary to print swaps themselves. You can hack this problem if you solve it. But you can hack the previous problem only if you solve both problems. After struggling and failing many times, Ujan decided to try to clean up his house again. He decided to get his strings in order first. Ujan has two distinct strings s and t of length n consisting of only of lowercase English characters. He wants to make them equal. Since Ujan is lazy, he will perform the following operation at most 2n times: he takes two positions i and j ( 1 \u2264 i, j \u2264 n , the values i and j can be equal or different) , and swaps the characters s_ i and t_ j . Ujan' s goal is to make the strings s and t equal. He does not need to minimize the number of performed operations: any sequence of operations of length 2n or shorter is suitable.",
    "input": "The first line contains a single integer k ( 1 \u2264 k \u2264 1000 ) , the number of test cases. For each of the test cases, the first line contains a single integer n ( 2 \u2264 n \u2264 50 ) , the length of the strings s and t . Each of the next two lines contains the strings s and t , each having length exactly n . The strings consist only of lowercase English letters. It is guaranteed that strings are different.",
    "output": "For each test case, output \" Yes\" if Ujan can make the two strings equal with at most 2n operations and \" No\" otherwise. You can print each letter in any case ( upper or lower) . In the case of \" Yes\" print m ( 1 \u2264 m \u2264 2n ) on the next line, where m is the number of swap operations to make the strings equal. Then print m lines, each line should contain two integers i, j ( 1 \u2264 i, j \u2264 n ) meaning that Ujan swaps s_ i and t_ j during the corresponding operation. You do not need to minimize the number of operations. Any sequence of length not more than 2n is suitable.",
    "note": "",
    "topics": [
      "strings"
    ]
  },
  {
    "title": "Character Swap (Easy Version)",
    "url": "https://codeforces.com/problemset/problem/1243/B1",
    "history": "This problem is different from the hard version. In this version Ujan makes exactly one exchange. You can hack this problem only if you solve both problems. After struggling and failing many times, Ujan decided to try to clean up his house again. He decided to get his strings in order first. Ujan has two distinct strings s and t of length n consisting of only of lowercase English characters. He wants to make them equal. Since Ujan is lazy, he will perform the following operation exactly once: he takes two positions i and j ( 1 \u2264 i, j \u2264 n , the values i and j can be equal or different) , and swaps the characters s_ i and t_ j . Can he succeed? Note that he has to perform this operation exactly once. He has to perform this operation.",
    "input": "The first line contains a single integer k ( 1 \u2264 k \u2264 10 ) , the number of test cases. For each of the test cases, the first line contains a single integer n ( 2 \u2264 n \u2264 10^ 4 ) , the length of the strings s and t . Each of the next two lines contains the strings s and t , each having length exactly n . The strings consist only of lowercase English letters. It is guaranteed that strings are different.",
    "output": "For each test case, output \" Yes\" if Ujan can make the two strings equal and \" No\" otherwise. You can print each letter in any case ( upper or lower) .",
    "note": "In the first test case, Ujan can swap characters s_ 1 and t_ 4 , obtaining the word \" house\" . In the second test case, it is not possible to make the strings equal using exactly one swap of s_ i and t_ j .",
    "topics": [
      "strings"
    ]
  },
  {
    "title": "AB-string",
    "url": "https://codeforces.com/problemset/problem/1238/D",
    "history": "The string t_ 1t_ 2 . . . t_ k is good if each letter of this string belongs to at least one palindrome of length greater than 1. A palindrome is a string that reads the same backward as forward. For example, the strings A, BAB, ABBA, BAABBBAAB are palindromes, but the strings AB, ABBBAA, BBBA are not. Here are some examples of good strings: t = AABBB ( letters t_ 1 , t_ 2 belong to palindrome t_ 1 . . . t_ 2 and letters t_ 3 , t_ 4 , t_ 5 belong to palindrome t_ 3 . . . t_ 5 ) ; t = ABAA ( letters t_ 1 , t_ 2 , t_ 3 belong to palindrome t_ 1 . . . t_ 3 and letter t_ 4 belongs to palindrome t_ 3 . . . t_ 4 ) ; t = AAAAA ( all letters belong to palindrome t_ 1 . . . t_ 5 ) ; You are given a string s of length n , consisting of only letters A and B. You have to calculate the number of good substrings of string s .",
    "input": "The first line contains one integer n ( 1 \u2264 n \u2264 3 \u00b7 10^ 5 ) \u2014 the length of the string s . The second line contains the string s , consisting of letters A and B.",
    "output": "Print one integer \u2014 the number of good substrings of string s .",
    "note": "In the first test case there are six good substrings: s_ 1 . . . s_ 2 , s_ 1 . . . s_ 4 , s_ 1 . . . s_ 5 , s_ 3 . . . s_ 4 , s_ 3 . . . s_ 5 and s_ 4 . . . s_ 5 . In the second test case there are three good substrings: s_ 1 . . . s_ 2 , s_ 1 . . . s_ 3 and s_ 2 . . . s_ 3 .",
    "topics": [
      "binary search",
      "combinatorics",
      "dp",
      "strings"
    ]
  },
  {
    "title": "Middle-Out",
    "url": "https://codeforces.com/problemset/problem/1231/E",
    "history": "The problem was inspired by Pied Piper story. After a challenge from Hooli' s compression competitor Nucleus, Richard pulled an all- nighter to invent a new approach to compression: middle- out. You are given two strings s and t of the same length n . Their characters are numbered from 1 to n from left to right ( i. e. from the beginning to the end) . In a single move you can do the following sequence of actions: choose any valid index i ( 1 \u2264 i \u2264 n ) , move the i - th character of s from its position to the beginning of the string or move the i - th character of s from its position to the end of the string. Note, that the moves don' t change the length of the string s . You can apply a move only to the string s . For example, if s= \" test\" in one move you can obtain: if i= 1 and you move to the beginning, then the result is \" test\" ( the string doesn' t change) , if i= 2 and you move to the beginning, then the result is \" etst\" , if i= 3 and you move to the beginning, then the result is \" stet\" , if i= 4 and you move to the beginning, then the result is \" ttes\" , if i= 1 and you move to the end, then the result is \" estt\" , if i= 2 and you move to the end, then the result is \" tste\" , if i= 3 and you move to the end, then the result is \" tets\" , if i= 4 and you move to the end, then the result is \" test\" ( the string doesn' t change) . You want to make the string s equal to the string t . What is the minimum number of moves you need? If it is impossible to transform s to t , print - 1.",
    "input": "The first line contains integer q ( 1 \u2264 q \u2264 100 ) \u2014 the number of independent test cases in the input. Each test case is given in three lines. The first line of a test case contains n ( 1 \u2264 n \u2264 100 ) \u2014 the length of the strings s and t . The second line contains s , the third line contains t . Both strings s and t have length n and contain only lowercase Latin letters. There are no constraints on the sum of n in the test ( i. e. the input with q= 100 and all n= 100 is allowed) .",
    "output": "For every test print minimum possible number of moves, which are needed to transform s into t , or - 1, if it is impossible to do.",
    "note": "In the first example, the moves in one of the optimal answers are: for the first test case s= \" iredppipe\" , t= \" piedpiper\" : \" iredppipe\" \u2192 \" iedppiper\" \u2192 \" piedpiper\" ; for the second test case s= \" estt\" , t= \" test\" : \" estt\" \u2192 \" test\" ; for the third test case s= \" tste\" , t= \" test\" : \" tste\" \u2192 \" etst\" \u2192 \" test\" .",
    "topics": [
      "constructive algorithms",
      "greedy",
      "strings"
    ]
  },
  {
    "title": "Strings Equalization",
    "url": "https://codeforces.com/problemset/problem/1223/B",
    "history": "You are given two strings of equal length s and t consisting of lowercase Latin letters. You may perform any number ( possibly, zero) operations on these strings. During each operation you choose two adjacent characters in any string and assign the value of the first character to the value of the second or vice versa. For example, if s is \" acbc\" you can get the following strings in one operation: \" aabc\" ( if you perform s_ 2 = s_ 1 ) ; \" ccbc\" ( if you perform s_ 1 = s_ 2 ) ; \" accc\" ( if you perform s_ 3 = s_ 2 or s_ 3 = s_ 4 ) ; \" abbc\" ( if you perform s_ 2 = s_ 3 ) ; \" acbb\" ( if you perform s_ 4 = s_ 3 ) ; Note that you can also apply this operation to the string t . Please determine whether it is possible to transform s into t , applying the operation above any number of times. Note that you have to answer q independent queries.",
    "input": "The first line contains one integer q ( 1 \u2264 q \u2264 100 ) \u2014 the number of queries. Each query is represented by two consecutive lines. The first line of each query contains the string s ( 1 \u2264 | s| \u2264 100 ) consisting of lowercase Latin letters. The second line of each query contains the string t ( 1 \u2264 | t| \u2264 100 , | t| = | s| ) consisting of lowercase Latin letters.",
    "output": "For each query, print \" YES\" if it is possible to make s equal to t , and \" NO\" otherwise. You may print every letter in any case you want ( so, for example, the strings \" yEs\" , \" yes\" , \" Yes\" , and \" YES\" will all be recognized as positive answer) .",
    "note": "In the first query, you can perform two operations s_ 1 = s_ 2 ( after it s turns into \" aabb\" ) and t_ 4 = t_ 3 ( after it t turns into \" aabb\" ) . In the second query, the strings are equal initially, so the answer is \" YES\" . In the third query, you can not make strings s and t equal. Therefore, the answer is \" NO\" .",
    "topics": [
      "strings"
    ]
  },
  {
    "title": "Substring Game in the Lesson",
    "url": "https://codeforces.com/problemset/problem/1220/C",
    "history": "Mike and Ann are sitting in the classroom. The lesson is boring, so they decided to play an interesting game. Fortunately, all they need to play this game is a string s and a number k ( 0 \u2264 k < | s| ) . At the beginning of the game, players are given a substring of s with left border l and right border r , both equal to k ( i. e. initially l= r= k ) . Then players start to make moves one by one, according to the following rules: A player chooses l^ ' and r^ ' so that l^ ' \u2264 l , r^ ' \u2265 r and s[ l^ ' , r^ ' ] is lexicographically less than s[ l, r] . Then the player changes l and r in this way: l : = l^ ' , r : = r^ ' . Ann moves first. The player, that can' t make a move loses. Recall that a substring s[ l, r] ( l \u2264 r ) of a string s is a continuous segment of letters from s that starts at position l and ends at position r . For example, \" ehn\" is a substring ( s[ 3, 5] ) of \" aaaehnsvz\" and \" ahz\" is not. Mike and Ann were playing so enthusiastically that they did not notice the teacher approached them. Surprisingly, the teacher didn' t scold them, instead of that he said, that he can figure out the winner of the game before it starts, even if he knows only s and k . Unfortunately, Mike and Ann are not so keen in the game theory, so they ask you to write a program, that takes s and determines the winner for all possible k .",
    "input": "The first line of the input contains a single string s ( 1 \u2264 | s| \u2264 5 \u00b7 10^ 5 ) consisting of lowercase English letters.",
    "output": "Print | s| lines. In the line i write the name of the winner ( print Mike or Ann) in the game with string s and k = i , if both play optimally",
    "note": "",
    "topics": [
      "games",
      "greedy",
      "strings"
    ]
  },
  {
    "title": "Cards",
    "url": "https://codeforces.com/problemset/problem/1220/A",
    "history": "When Serezha was three years old, he was given a set of cards with letters for his birthday. They were arranged into words in the way which formed the boy' s mother favorite number in binary notation. Serezha started playing with them immediately and shuffled them because he wasn' t yet able to read. His father decided to rearrange them. Help him restore the original number, on condition that it was the maximum possible one.",
    "input": "The first line contains a single integer n ( 1 \u2a7d n \u2a7d 10^ 5 ) \u2014 the length of the string. The second line contains a string consisting of English lowercase letters: ' z' , ' e' , ' r' , ' o' and ' n' . It is guaranteed that it is possible to rearrange the letters in such a way that they form a sequence of words, each being either \" zero\" which corresponds to the digit 0 or \" one\" which corresponds to the digit 1 .",
    "output": "Print the maximum possible number in binary notation. Print binary digits separated by a space. The leading zeroes are allowed.",
    "note": "In the first example, the correct initial ordering is \" zero\" . In the second example, the correct initial ordering is \" oneonezero\" .",
    "topics": [
      "implementation",
      "sortings",
      "strings"
    ]
  },
  {
    "title": "Periodic integer number",
    "url": "https://codeforces.com/problemset/problem/1219/C",
    "history": "Alice became interested in periods of integer numbers. We say positive X integer number is periodic with length L if there exists positive integer number P with L digits such that X can be written as PPPP. . . P . For example: X = 123123123 is periodic number with length L = 3 and L = 9 X = 42424242 is periodic number with length L = 2, L = 4 and L = 8 X = 12345 is periodic number with length L = 5 For given positive period length L and positive integer number A , Alice wants to find smallest integer number X strictly greater than A that is periodic with length L.",
    "input": "First line contains one positive integer number L ( 1 \u2264 L \u2264 10^ 5) representing length of the period. Second line contains one positive integer number A ( 1 \u2264 A \u2264 10^ 100 000) .",
    "output": "One positive integer number representing smallest positive number that is periodic with length L and is greater than A .",
    "note": "In first example 124124 is the smallest number greater than 123456 that can be written with period L = 3 ( P = 124) . In the second example 100100 is the smallest number greater than 12345 with period L = 3 ( P= 100)",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Prefixes",
    "url": "https://codeforces.com/problemset/problem/1216/A",
    "history": "Nikolay got a string s of even length n , which consists only of lowercase Latin letters ' a' and ' b' . Its positions are numbered from 1 to n . He wants to modify his string so that every its prefix of even length has an equal amount of letters ' a' and ' b' . To achieve that, Nikolay can perform the following operation arbitrary number of times ( possibly, zero) : choose some position in his string and replace the letter on this position with the other letter ( i. e. replace ' a' with ' b' or replace ' b' with ' a' ) . Nikolay can use no letters except ' a' and ' b' . The prefix of string s of length l ( 1 \u2264 l \u2264 n ) is a string s[ 1. . l] . For example, for the string s= \" abba\" there are two prefixes of the even length. The first is s[ 1. . . 2] = \" ab\" and the second s[ 1. . . 4] = \" abba\" . Both of them have the same number of ' a' and ' b' . Your task is to calculate the minimum number of operations Nikolay has to perform with the string s to modify it so that every its prefix of even length has an equal amount of letters ' a' and ' b' .",
    "input": "The first line of the input contains one even integer n ( 2 \u2264 n \u2264 2\u00b710^ 5) \u2014 the length of string s . The second line of the input contains the string s of length n , which consists only of lowercase Latin letters ' a' and ' b' .",
    "output": "In the first line print the minimum number of operations Nikolay has to perform with the string s to modify it so that every its prefix of even length has an equal amount of letters ' a' and ' b' . In the second line print the string Nikolay obtains after applying all the operations. If there are multiple answers, you can print any of them.",
    "note": "In the first example Nikolay has to perform two operations. For example, he can replace the first ' b' with ' a' and the last ' b' with ' a' . In the second example Nikolay doesn' t need to do anything because each prefix of an even length of the initial string already contains an equal amount of letters ' a' and ' b' .",
    "topics": [
      "strings"
    ]
  },
  {
    "title": "Unstable String Sort",
    "url": "https://codeforces.com/problemset/problem/1213/F",
    "history": "Authors have come up with the string s consisting of n lowercase Latin letters. You are given two permutations of its indices ( not necessary equal) p and q ( both of length n ) . Recall that the permutation is the array of length n which contains each integer from 1 to n exactly once. For all i from 1 to n- 1 the following properties hold: s[ p_ i] \u2264 s[ p_ i + 1] and s[ q_ i] \u2264 s[ q_ i + 1] . It means that if you will write down all characters of s in order of permutation indices, the resulting string will be sorted in the non- decreasing order. Your task is to restore any such string s of length n consisting of at least k distinct lowercase Latin letters which suits the given permutations. If there are multiple answers, you can print any of them.",
    "input": "The first line of the input contains two integers n and k ( 1 \u2264 n \u2264 2 \u00b7 10^ 5, 1 \u2264 k \u2264 26 ) \u2014 the length of the string and the number of distinct characters required. The second line of the input contains n integers p_ 1, p_ 2, . . . , p_ n ( 1 \u2264 p_ i \u2264 n , all p_ i are distinct integers from 1 to n ) \u2014 the permutation p . The third line of the input contains n integers q_ 1, q_ 2, . . . , q_ n ( 1 \u2264 q_ i \u2264 n , all q_ i are distinct integers from 1 to n ) \u2014 the permutation q .",
    "output": "If it is impossible to find the suitable string, print \" NO\" on the first line. Otherwise print \" YES\" on the first line and string s on the second line. It should consist of n lowercase Latin letters, contain at least k distinct characters and suit the given permutations. If there are multiple answers, you can print any of them.",
    "note": "",
    "topics": [
      "data structures",
      "dfs and similar",
      "dsu",
      "graphs",
      "greedy",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "kotlinkotlinkotlinkotlin...",
    "url": "https://codeforces.com/problemset/problem/1211/F",
    "history": "Polycarp really likes writing the word \" kotlin\" . He wrote this word several times in a row without spaces. For example, he could write the string like \" kotlinkotlinkotlinkotlin\" . Polycarp sliced ( cut) the written string into n pieces and mixed them. As a result, he has n strings s_ 1, s_ 2, . . . , s_ n and he can arrange them in the right order, concatenate ( join) all of them and get a string like \" kotlinkotlin. . . kotlin\" . Help Polycarp to find the right order of strings s_ 1, s_ 2, . . . , s_ n , so that if he writes the strings in this order, he will get the word \" kotlin\" or the sequence of this word. Pay attention that you must use all given strings and you must use each string only once.",
    "input": "The first line of the input contains one integer n ( 1 \u2264 n \u2264 10^ 5 ) \u2014 the number of Polycarp' s strings. Next lines of the input contain n Polycarp' s strings. Total sum of their lengths doesn' t exceed 3\u00b710^ 5 . It' s guaranteed that there is the right order of arrangement the strings that if you concatenate them into one string, you will get some non- empty sequence of the word \" kotlin\" .",
    "output": "Print n different integers p_ 1, p_ 2, . . . , p_ n ( 1 \u2264 p_ i \u2264 n ) , where p_ i is an index of the string that should be the i - th in a required concatenation. In other words, the result of concatenation s_ p_ 1+ s_ p_ 2+ . . . + s_ p_ n must be in the form \" kotlinkotlin. . . kotlin\" . If there are many solutions, print any of them.",
    "note": "",
    "topics": [
      "*special",
      "graphs",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Koala and Notebook",
    "url": "https://codeforces.com/problemset/problem/1209/F",
    "history": "Koala Land consists of m bidirectional roads connecting n cities. The roads are numbered from 1 to m by order in input. It is guaranteed, that one can reach any city from every other city. Koala starts traveling from city 1 . Whenever he travels on a road, he writes its number down in his notebook. He doesn' t put spaces between the numbers, so they all get concatenated into a single number. Before embarking on his trip, Koala is curious about the resulting number for all possible destinations. For each possible destination, what is the smallest number he could have written for it? Since these numbers may be quite large, print their remainders modulo 10^ 9+ 7 . Please note, that you need to compute the remainder of the minimum possible number, not the minimum possible remainder.",
    "input": "The first line contains two integers n and m ( 2 \u2264 n \u2264 10^ 5, n - 1 \u2264 m \u2264 10^ 5 ) , the number of cities and the number of roads, respectively. The i - th of the following m lines contains integers x_ i and y_ i ( 1 \u2264 x_ i, y_ i \u2264 n , x_ i y_ i ) , representing a bidirectional road between cities x_ i and y_ i . It is guaranteed, that for any pair of cities there is at most one road connecting them, and that one can reach any city from every other city.",
    "output": "Print n - 1 integers, the answer for every city except for the first city. The i - th integer should be equal to the smallest number he could have written for destination i+ 1 . Since this number may be large, output its remainder modulo 10^ 9+ 7 .",
    "note": "",
    "topics": [
      "data structures",
      "dfs and similar",
      "graphs",
      "shortest paths",
      "strings",
      "trees"
    ]
  },
  {
    "title": "Indie Album",
    "url": "https://codeforces.com/problemset/problem/1207/G",
    "history": "Mishka' s favourite experimental indie band has recently dropped a new album! Songs of that album share one gimmick. Each name s_ i is one of the following types: 1 c \u2014 a single lowercase Latin letter; 2 j c \u2014 name s_ j ( 1 \u2264 j < i ) with a single lowercase Latin letter appended to its end. Songs are numbered from 1 to n . It' s guaranteed that the first song is always of type 1 . Vova is rather interested in the new album but he really doesn' t have the time to listen to it entirely. Thus he asks Mishka some questions about it to determine if some song is worth listening to. Questions have the following format: i t \u2014 count the number of occurrences of string t in s_ i ( the name of the i - th song of the album) as a continuous substring, t consists only of lowercase Latin letters. Mishka doesn' t question the purpose of that information, yet he struggles to provide it. Can you please help Mishka answer all Vova' s questions?",
    "input": "The first line contains a single integer n ( 1 \u2264 n \u2264 4 \u00b7 10^ 5 ) \u2014 the number of songs in the album. Each of the next n lines contains the desciption of the i - th song of the album in the following format: 1 c \u2014 s_ i is a single lowercase Latin letter; 2 j c \u2014 s_ i is the name s_ j ( 1 \u2264 j < i ) with a single lowercase Latin letter appended to its end. The next line contains a single integer m ( 1 \u2264 m \u2264 4 \u00b7 10^ 5 ) \u2014 the number of Vova' s questions. Each of the next m lines contains the desciption of the j - th Vova' s question in the following format: i t ( 1 \u2264 i \u2264 n , 1 \u2264 | t| \u2264 4 \u00b7 10^ 5 ) \u2014 count the number of occurrences of string t in s_ i ( the name of the i - th song of the album) as a continuous substring, t consists only of lowercase Latin letters. It' s guaranteed that the total length of question strings t doesn' t exceed 4 \u00b7 10^ 5 .",
    "output": "For each question print a single integer \u2014 the number of occurrences of the question string t in the name of the i - th song of the album as a continuous substring.",
    "note": "Song names of the first example: d da dad dada dadad dadada dadadad dadadada d do dok doki dokid dokido dokidok dokidoki do dok doki dokidoki Thus the occurrences for each question string are: string \" da\" starts in positions [ 1, 3, 5, 7] in the name \" dadadada\" ; string \" dada\" starts in positions [ 1, 3, 5] in the name \" dadadada\" ; string \" ada\" starts in positions [ 2, 4, 6] in the name \" dadadada\" ; string \" dada\" starts in positions [ 1, 3] in the name \" dadada\" ; no occurrences of string \" dada\" in the name \" dad\" ; string \" doki\" starts in position [ 1] in the name \" doki\" ; string \" ok\" starts in position [ 2] in the name \" doki\" ; string \" doki\" starts in positions [ 1, 5] in the name \" dokidoki\" ; string \" doki\" starts in position [ 1] in the name \" dokidok\" ; string \" d\" starts in position [ 1] in the name \" d\" ; no occurrences of string \" a\" in the name \" d\" ; string \" doki\" starts in positions [ 1, 5] in the name \" dokidoki\" .",
    "topics": [
      "data structures",
      "dfs and similar",
      "hashing",
      "string suffix structures",
      "strings",
      "trees"
    ]
  },
  {
    "title": "Expected Value Again",
    "url": "https://codeforces.com/problemset/problem/1205/E",
    "history": "You are given integers n , k . Let' s consider the alphabet consisting of k different elements. Let beauty f( s) of the string s be the number of indexes i , 1\u2264 i< | s| , for which prefix of s of length i equals to suffix of s of length i . For example, beauty of the string abacaba equals 2 , as for i = 1, 3 prefix and suffix of length i are equal. Consider all words of length n in the given alphabet. Find the expected value of f( s) ^ 2 of a uniformly chosen at random word. We can show that it can be expressed as P/ Q , where P and Q are coprime and Q isn' t divided by 10^ 9 + 7 . Output P\u00b7 Q^ - 1 10^ 9 + 7 .",
    "input": "The first and the only line contains two integers n , k ( 1\u2264 n \u2264 10^ 5 , 1\u2264 k\u2264 10^ 9 ) \u2014 the length of a string and the size of alphabet respectively.",
    "output": "Output a single integer \u2014 P\u00d7 Q^ - 1 10^ 9 + 7 .",
    "note": "In the first example, there are 9 words of length 2 in alphabet of size 3 \u2014 aa , ab , ac , ba , bb , bc , ca , cb , cc . 3 of them have beauty 1 and 6 of them have beauty 0 , so the average value is 1/ 3 . In the third example, there is only one such word, and it has beauty 99 , so the average value is 99^ 2 .",
    "topics": [
      "combinatorics",
      "strings"
    ]
  },
  {
    "title": "Kirk and a Binary String (hard version)",
    "url": "https://codeforces.com/problemset/problem/1204/D2",
    "history": "The only difference between easy and hard versions is the length of the string. You can hack this problem if you solve it. But you can hack the previous problem only if you solve both problems. Kirk has a binary string s ( a string which consists of zeroes and ones) of length n and he is asking you to find a binary string t of the same length which satisfies the following conditions: For any l and r ( 1 \u2264 l \u2264 r \u2264 n ) the length of the longest non- decreasing subsequence of the substring s_ ls_ l+ 1. . . s_ r is equal to the length of the longest non- decreasing subsequence of the substring t_ lt_ l+ 1. . . t_ r ; The number of zeroes in t is the maximum possible. A non- decreasing subsequence of a string p is a sequence of indices i_ 1, i_ 2, . . . , i_ k such that i_ 1 < i_ 2 < . . . < i_ k and p_ i_ 1\u2264 p_ i_ 2\u2264. . . \u2264 p_ i_ k . The length of the subsequence is k . If there are multiple substrings which satisfy the conditions, output any.",
    "input": "The first line contains a binary string of length not more than 10^ 5 .",
    "output": "Output a binary string which satisfied the above conditions. If there are many such strings, output any of them.",
    "note": "In the first example: For the substrings of the length 1 the length of the longest non- decreasing subsequnce is 1 ; For l = 1, r = 2 the longest non- decreasing subsequnce of the substring s_ 1s_ 2 is 11 and the longest non- decreasing subsequnce of the substring t_ 1t_ 2 is 01 ; For l = 1, r = 3 the longest non- decreasing subsequnce of the substring s_ 1s_ 3 is 11 and the longest non- decreasing subsequnce of the substring t_ 1t_ 3 is 00 ; For l = 2, r = 3 the longest non- decreasing subsequnce of the substring s_ 2s_ 3 is 1 and the longest non- decreasing subsequnce of the substring t_ 2t_ 3 is 1 ; The second example is similar to the first one.",
    "topics": [
      "data structures",
      "greedy",
      "math",
      "strings"
    ]
  },
  {
    "title": "Kirk and a Binary String (easy version)",
    "url": "https://codeforces.com/problemset/problem/1204/D1",
    "history": "The only difference between easy and hard versions is the length of the string. You can hack this problem only if you solve both problems. Kirk has a binary string s ( a string which consists of zeroes and ones) of length n and he is asking you to find a binary string t of the same length which satisfies the following conditions: For any l and r ( 1 \u2264 l \u2264 r \u2264 n ) the length of the longest non- decreasing subsequence of the substring s_ ls_ l+ 1. . . s_ r is equal to the length of the longest non- decreasing subsequence of the substring t_ lt_ l+ 1. . . t_ r ; The number of zeroes in t is the maximum possible. A non- decreasing subsequence of a string p is a sequence of indices i_ 1, i_ 2, . . . , i_ k such that i_ 1 < i_ 2 < . . . < i_ k and p_ i_ 1\u2264 p_ i_ 2\u2264. . . \u2264 p_ i_ k . The length of the subsequence is k . If there are multiple substrings which satisfy the conditions, output any.",
    "input": "The first line contains a binary string of length not more than 2 000 .",
    "output": "Output a binary string which satisfied the above conditions. If there are many such strings, output any of them.",
    "note": "In the first example: For the substrings of the length 1 the length of the longest non- decreasing subsequnce is 1 ; For l = 1, r = 2 the longest non- decreasing subsequnce of the substring s_ 1s_ 2 is 11 and the longest non- decreasing subsequnce of the substring t_ 1t_ 2 is 01 ; For l = 1, r = 3 the longest non- decreasing subsequnce of the substring s_ 1s_ 3 is 11 and the longest non- decreasing subsequnce of the substring t_ 1t_ 3 is 00 ; For l = 2, r = 3 the longest non- decreasing subsequnce of the substring s_ 2s_ 3 is 1 and the longest non- decreasing subsequnce of the substring t_ 2t_ 3 is 1 ; The second example is similar to the first one.",
    "topics": [
      "brute force",
      "greedy",
      "strings"
    ]
  },
  {
    "title": "You Are Given Some Strings...",
    "url": "https://codeforces.com/problemset/problem/1202/E",
    "history": "You are given a string t and n strings s_ 1, s_ 2, . . . , s_ n . All strings consist of lowercase Latin letters. Let f( t, s) be the number of occurences of string s in string t . For example, f( ' aaabacaa' , ' aa' ) = 3 , and f( ' ababa' , ' aba' ) = 2 . Calculate the value of \u2211_ i= 1^ n\u2211_ j= 1^ n f( t, s_ i + s_ j) , where s + t is the concatenation of strings s and t . Note that if there are two pairs i_ 1 , j_ 1 and i_ 2 , j_ 2 such that s_ i_ 1 + s_ j_ 1 = s_ i_ 2 + s_ j_ 2 , you should include both f( t, s_ i_ 1 + s_ j_ 1) and f( t, s_ i_ 2 + s_ j_ 2) in answer.",
    "input": "The first line contains string t ( 1 \u2264 | t| \u2264 2 \u00b7 10^ 5 ) . The second line contains integer n ( 1 \u2264 n \u2264 2 \u00b7 10^ 5 ) . Each of next n lines contains string s_ i ( 1 \u2264 | s_ i| \u2264 2 \u00b7 10^ 5 ) . It is guaranteed that \u2211_ i= 1^ n | s_ i| \u2264 2 \u00b7 10^ 5 . All strings consist of lowercase English letters.",
    "output": "Print one integer \u2014 the value of \u2211_ i= 1^ n\u2211_ j= 1^ n f( t, s_ i + s_ j) .",
    "note": "",
    "topics": [
      "brute force",
      "string suffix structures",
      "strings"
    ]
  },
  {
    "title": "Print a 1337-string...",
    "url": "https://codeforces.com/problemset/problem/1202/D",
    "history": "The subsequence is a sequence that can be derived from another sequence by deleting some elements without changing the order of the remaining elements. You are given an integer n . You have to find a sequence s consisting of digits { 1, 3, 7} such that it has exactly n subsequences equal to 1337 . For example, sequence 337133377 has 6 subsequences equal to 1337 : 337133377 ( you can remove the second and fifth characters) ; 337133377 ( you can remove the third and fifth characters) ; 337133377 ( you can remove the fourth and fifth characters) ; 337133377 ( you can remove the second and sixth characters) ; 337133377 ( you can remove the third and sixth characters) ; 337133377 ( you can remove the fourth and sixth characters) . Note that the length of the sequence s must not exceed 10^ 5 . You have to answer t independent queries.",
    "input": "The first line contains one integer t ( 1 \u2264 t \u2264 10 ) \u2014 the number of queries. Next t lines contains a description of queries: the i - th line contains one integer n_ i ( 1 \u2264 n_ i \u2264 10^ 9 ) .",
    "output": "For the i - th query print one string s_ i ( 1 \u2264 | s_ i| \u2264 10^ 5 ) consisting of digits { 1, 3, 7} . String s_ i must have exactly n_ i subsequences 1337 . If there are multiple such strings, print any of them.",
    "note": "",
    "topics": [
      "combinatorics",
      "constructive algorithms",
      "math",
      "strings"
    ]
  },
  {
    "title": "You Are Given a WASD-string...",
    "url": "https://codeforces.com/problemset/problem/1202/C",
    "history": "You have a string s \u2014 a sequence of commands for your toy robot. The robot is placed in some cell of a rectangular grid. He can perform four commands: ' W' \u2014 move one cell up; ' S' \u2014 move one cell down; ' A' \u2014 move one cell left; ' D' \u2014 move one cell right. Let Grid( s) be the grid of minimum possible area such that there is a position in the grid where you can place the robot in such a way that it will not fall from the grid while running the sequence of commands s . For example, if s = DSAWWAW then Grid( s) is the 4 \u00d7 3 grid: you can place the robot in the cell ( 3, 2) ; the robot performs the command ' D' and moves to ( 3, 3) ; the robot performs the command ' S' and moves to ( 4, 3) ; the robot performs the command ' A' and moves to ( 4, 2) ; the robot performs the command ' W' and moves to ( 3, 2) ; the robot performs the command ' W' and moves to ( 2, 2) ; the robot performs the command ' A' and moves to ( 2, 1) ; the robot performs the command ' W' and moves to ( 1, 1) . You have 4 extra letters: one ' W' , one ' A' , one ' S' , one ' D' . You' d like to insert at most one of these letters in any position of sequence s to minimize the area of Grid( s) . What is the minimum area of Grid( s) you can achieve?",
    "input": "The first line contains one integer T ( 1 \u2264 T \u2264 1000 ) \u2014 the number of queries. Next T lines contain queries: one per line. This line contains single string s ( 1 \u2264 | s| \u2264 2 \u00b7 10^ 5 , s_ i \u2208{ W, A, S, D} ) \u2014 the sequence of commands. It' s guaranteed that the total length of s over all queries doesn' t exceed 2 \u00b7 10^ 5 .",
    "output": "Print T integers: one per query. For each query print the minimum area of Grid( s) you can achieve.",
    "note": "In the first query you have to get string DSAWWDAW . In second and third queries you can not decrease the area of Grid( s) .",
    "topics": [
      "brute force",
      "data structures",
      "dp",
      "greedy",
      "implementation",
      "math",
      "strings"
    ]
  },
  {
    "title": "Important Exam",
    "url": "https://codeforces.com/problemset/problem/1201/A",
    "history": "A class of students wrote a multiple- choice test. There are n students in the class. The test had m questions, each of them had 5 possible answers ( A, B, C, D or E) . There is exactly one correct answer for each question. The correct answer for question i worth a_ i points. Incorrect answers are graded with zero points. The students remember what answers they gave on the exam, but they don' t know what are the correct answers. They are very optimistic, so they want to know what is the maximum possible total score of all students in the class.",
    "input": "The first line contains integers n and m ( 1 \u2264 n, m \u2264 1000 ) \u2014 the number of students in the class and the number of questions in the test. Each of the next n lines contains string s_ i ( | s_ i| = m ) , describing an answer of the i - th student. The j - th character represents the student answer ( A, B, C, D or E) on the j - th question. The last line contains m integers a_ 1, a_ 2, . . . , a_ m ( 1 \u2264 a_ i \u2264 1000 ) \u2014 the number of points for the correct answer for every question.",
    "output": "Print a single integer \u2014 the maximum possible total score of the class.",
    "note": "In the first example, one of the most optimal test answers is \" ABCD\" , this way the total number of points will be 16 . In the second example, one of the most optimal test answers is \" CCC\" , this way each question will be answered by exactly one student and the total number of points is 5 + 4 + 12 = 21 .",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Compress Words",
    "url": "https://codeforces.com/problemset/problem/1200/E",
    "history": "Amugae has a sentence consisting of n words. He want to compress this sentence into one word. Amugae doesn' t like repetitions, so when he merges two words into one word, he removes the longest prefix of the second word that coincides with a suffix of the first word. For example, he merges \" sample\" and \" please\" into \" samplease\" . Amugae will merge his sentence left to right ( i. e. first merge the first two words, then merge the result with the third word and so on) . Write a program that prints the compressed word after the merging process ends.",
    "input": "The first line contains an integer n ( 1 \u2264 n \u2264 10^ 5 ) , the number of the words in Amugae' s sentence. The second line contains n words separated by single space. Each words is non- empty and consists of uppercase and lowercase English letters and digits ( ' A' , ' B' , . . . , ' Z' , ' a' , ' b' , . . . , ' z' , ' 0' , ' 1' , . . . , ' 9' ) . The total length of the words does not exceed 10^ 6 .",
    "output": "In the only line output the compressed word after the merging process ends as described in the problem.",
    "note": "",
    "topics": [
      "brute force",
      "hashing",
      "implementation",
      "string suffix structures",
      "strings"
    ]
  },
  {
    "title": "From S To T",
    "url": "https://codeforces.com/problemset/problem/1194/C",
    "history": "You are given three strings s , t and p consisting of lowercase Latin letters. You may perform any number ( possibly, zero) operations on these strings. During each operation you choose any character from p , erase it from p and insert it into string s ( you may insert this character anywhere you want: in the beginning of s , in the end or between any two consecutive characters) . For example, if p is aba, and s is de, then the following outcomes are possible ( the character we erase from p and insert into s is highlighted) : aba \u2192 ba, de \u2192 ade; aba \u2192 ba, de \u2192 dae; aba \u2192 ba, de \u2192 dea; aba \u2192 aa, de \u2192 bde; aba \u2192 aa, de \u2192 dbe; aba \u2192 aa, de \u2192 deb; aba \u2192 ab, de \u2192 ade; aba \u2192 ab, de \u2192 dae; aba \u2192 ab, de \u2192 dea; Your goal is to perform several ( maybe zero) operations so that s becomes equal to t . Please determine whether it is possible. Note that you have to answer q independent queries.",
    "input": "The first line contains one integer q ( 1 \u2264 q \u2264 100 ) \u2014 the number of queries. Each query is represented by three consecutive lines. The first line of each query contains the string s ( 1 \u2264 | s| \u2264 100 ) consisting of lowercase Latin letters. The second line of each query contains the string t ( 1 \u2264 | t| \u2264 100 ) consisting of lowercase Latin letters. The third line of each query contains the string p ( 1 \u2264 | p| \u2264 100 ) consisting of lowercase Latin letters.",
    "output": "For each query print YES if it is possible to make s equal to t , and NO otherwise. You may print every letter in any case you want ( so, for example, the strings yEs, yes, Yes and YES will all be recognized as positive answer) .",
    "note": "In the first test case there is the following sequence of operation: s = ab, t = acxb, p = cax; s = acb, t = acxb, p = ax; s = acxb, t = acxb, p = a. In the second test case there is the following sequence of operation: s = a, t = aaaa, p = aaabbcc; s = aa, t = aaaa, p = aabbcc; s = aaa, t = aaaa, p = abbcc; s = aaaa, t = aaaa, p = bbcc.",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Keanu Reeves",
    "url": "https://codeforces.com/problemset/problem/1189/A",
    "history": "After playing Neo in the legendary \" Matrix\" trilogy, Keanu Reeves started doubting himself: maybe we really live in virtual reality? To find if this is true, he needs to solve the following problem. Let' s call a string consisting of only zeroes and ones good if it contains different numbers of zeroes and ones. For example, 1, 101, 0000 are good, while 01, 1001, and 111000 are not good. We are given a string s of length n consisting of only zeroes and ones. We need to cut s into minimal possible number of substrings s_ 1, s_ 2, . . . , s_ k such that all of them are good. More formally, we have to find minimal by number of strings sequence of good strings s_ 1, s_ 2, . . . , s_ k such that their concatenation ( joining) equals s , i. e. s_ 1 + s_ 2 + . . . + s_ k = s . For example, cuttings 110010 into 110 and 010 or into 11 and 0010 are valid, as 110, 010, 11, 0010 are all good, and we can' t cut 110010 to the smaller number of substrings as 110010 isn' t good itself. At the same time, cutting of 110010 into 1100 and 10 isn' t valid as both strings aren' t good. Also, cutting of 110010 into 1, 1, 0010 isn' t valid, as it isn' t minimal, even though all 3 strings are good. Can you help Keanu? We can show that the solution always exists. If there are multiple optimal answers, print any.",
    "input": "The first line of the input contains a single integer n ( 1\u2264 n \u2264 100 ) \u2014 the length of the string s . The second line contains the string s of length n consisting only from zeros and ones.",
    "output": "In the first line, output a single integer k ( 1\u2264 k ) \u2014 a minimal number of strings you have cut s into. In the second line, output k strings s_ 1, s_ 2, . . . , s_ k separated with spaces. The length of each string has to be positive. Their concatenation has to be equal to s and all of them have to be good. If there are multiple answers, print any.",
    "note": "In the first example, the string 1 wasn' t cut at all. As it is good, the condition is satisfied. In the second example, 1 and 0 both are good. As 10 isn' t good, the answer is indeed minimal. In the third example, 100 and 011 both are good. As 100011 isn' t good, the answer is indeed minimal.",
    "topics": [
      "strings"
    ]
  },
  {
    "title": "Letters Shop",
    "url": "https://codeforces.com/problemset/problem/1187/B",
    "history": "The letters shop showcase is a string s , consisting of n lowercase Latin letters. As the name tells, letters are sold in the shop. Letters are sold one by one from the leftmost to the rightmost. Any customer can only buy some prefix of letters from the string s . There are m friends, the i - th of them is named t_ i . Each of them is planning to estimate the following value: how many letters ( the length of the shortest prefix) would s/ he need to buy if s/ he wanted to construct her/ his name of bought letters. The name can be constructed if each letter is presented in the equal or greater amount. For example, for s = \" arrayhead\" and t_ i = \" arya\" 5 letters have to be bought ( \" arrayhead\" ) . For example, for s = \" arrayhead\" and t_ i = \" harry\" 6 letters have to be bought ( \" arrayhead\" ) . For example, for s = \" arrayhead\" and t_ i = \" ray\" 5 letters have to be bought ( \" arrayhead\" ) . For example, for s = \" arrayhead\" and t_ i = \" r\" 2 letters have to be bought ( \" arrayhead\" ) . For example, for s = \" arrayhead\" and t_ i = \" areahydra\" all 9 letters have to be bought ( \" arrayhead\" ) . It is guaranteed that every friend can construct her/ his name using the letters from the string s . Note that the values for friends are independent, friends are only estimating them but not actually buying the letters.",
    "input": "The first line contains one integer n ( 1 \u2264 n \u2264 2 \u00b7 10^ 5 ) \u2014 the length of showcase string s . The second line contains string s , consisting of exactly n lowercase Latin letters. The third line contains one integer m ( 1 \u2264 m \u2264 5 \u00b7 10^ 4 ) \u2014 the number of friends. The i - th of the next m lines contains t_ i ( 1 \u2264 | t_ i| \u2264 2 \u00b7 10^ 5 ) \u2014 the name of the i - th friend. It is guaranteed that \u2211_ i= 1^ m | t_ i| \u2264 2 \u00b7 10^ 5 .",
    "output": "For each friend print the length of the shortest prefix of letters from s s/ he would need to buy to be able to construct her/ his name of them. The name can be constructed if each letter is presented in the equal or greater amount. It is guaranteed that every friend can construct her/ his name using the letters from the string s .",
    "note": "",
    "topics": [
      "binary search",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Email from Polycarp",
    "url": "https://codeforces.com/problemset/problem/1185/B",
    "history": "Methodius received an email from his friend Polycarp. However, Polycarp' s keyboard is broken, so pressing a key on it once may cause the corresponding symbol to appear more than once ( if you press a key on a regular keyboard, it prints exactly one symbol) . For example, as a result of typing the word \" hello\" , the following words could be printed: \" hello\" , \" hhhhello\" , \" hheeeellllooo\" , but the following could not be printed: \" hell\" , \" helo\" , \" hhllllooo\" . Note, that when you press a key, the corresponding symbol must appear ( possibly, more than once) . The keyboard is broken in a random manner, it means that pressing the same key you can get the different number of letters in the result. For each word in the letter, Methodius has guessed what word Polycarp actually wanted to write, but he is not sure about it, so he asks you to help him. You are given a list of pairs of words. For each pair, determine if the second word could be printed by typing the first one on Polycarp' s keyboard.",
    "input": "The first line of the input contains one integer n ( 1 \u2264 n \u2264 10^ 5 ) \u2014 the number of pairs to check. Further input contains n descriptions of pairs. The first line of each description contains a single non- empty word s consisting of lowercase Latin letters. The second line of the description contains a single non- empty word t consisting of lowercase Latin letters. The lengths of both strings are not greater than 10^ 6 . It is guaranteed that the total length of all words s in the input is not greater than 10^ 6 . Also, it is guaranteed that the total length of all words t in the input is not greater than 10^ 6 .",
    "output": "Output n lines. In the i - th line for the i - th pair of words s and t print YES if the word t could be printed by typing the word s . Otherwise, print NO.",
    "note": "",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Subsequences (hard version)",
    "url": "https://codeforces.com/problemset/problem/1183/H",
    "history": "The only difference between the easy and the hard versions is constraints. A subsequence is a string that can be derived from another string by deleting some or no symbols without changing the order of the remaining symbols. Characters to be deleted are not required to go successively, there can be any gaps between them. For example, for the string \" abaca\" the following strings are subsequences: \" abaca\" , \" aba\" , \" aaa\" , \" a\" and \" \" ( empty string) . But the following strings are not subsequences: \" aabaca\" , \" cb\" and \" bcaa\" . You are given a string s consisting of n lowercase Latin letters. In one move you can take any subsequence t of the given string and add it to the set S . The set S can' t contain duplicates. This move costs n - | t| , where | t| is the length of the added subsequence ( i. e. the price equals to the number of the deleted characters) . Your task is to find out the minimum possible total cost to obtain a set S of size k or report that it is impossible to do so.",
    "input": "The first line of the input contains two integers n and k ( 1 \u2264 n \u2264 100, 1 \u2264 k \u2264 10^ 12 ) \u2014 the length of the string and the size of the set, correspondingly. The second line of the input contains a string s consisting of n lowercase Latin letters.",
    "output": "Print one integer \u2014 if it is impossible to obtain the set S of size k , print - 1. Otherwise, print the minimum possible total cost to do it.",
    "note": "In the first example we can generate S = \" asdf\" , \" asd\" , \" adf\" , \" asf\" , \" sdf\" . The cost of the first element in S is 0 and the cost of the others is 1 . So the total cost of S is 4 .",
    "topics": [
      "dp",
      "strings"
    ]
  },
  {
    "title": "Beautiful Lyrics",
    "url": "https://codeforces.com/problemset/problem/1182/C",
    "history": "You are given n words, each of which consists of lowercase alphabet letters. Each word contains at least one vowel. You are going to choose some of the given words and make as many beautiful lyrics as possible. Each lyric consists of two lines. Each line consists of two words separated by whitespace. A lyric is beautiful if and only if it satisfies all conditions below. The number of vowels in the first word of the first line is the same as the number of vowels in the first word of the second line. The number of vowels in the second word of the first line is the same as the number of vowels in the second word of the second line. The last vowel of the first line is the same as the last vowel of the second line. Note that there may be consonants after the vowel. Also, letters \" a\" , \" e\" , \" o\" , \" i\" , and \" u\" are vowels. Note that \" y\" is never vowel. For example of a beautiful lyric, \" hello hellooowww\" \" whatsup yowowowow\" is a beautiful lyric because there are two vowels each in \" hello\" and \" whatsup\" , four vowels each in \" hellooowww\" and \" yowowowow\" ( keep in mind that \" y\" is not a vowel) , and the last vowel of each line is \" o\" . For example of a not beautiful lyric, \" hey man\" \" iam mcdic\" is not a beautiful lyric because \" hey\" and \" iam\" don' t have same number of vowels and the last vowels of two lines are different ( \" a\" in the first and \" i\" in the second) . How many beautiful lyrics can you write from given words? Note that you cannot use a word more times than it is given to you. For example, if a word is given three times, you can use it at most three times.",
    "input": "The first line contains single integer n ( 1 \u2264 n \u2264 10^ 5 ) \u2014 the number of words. The i - th of the next n lines contains string s_ i consisting lowercase alphabet letters \u2014 the i - th word. It is guaranteed that the sum of the total word length is equal or less than 10^ 6 . Each word contains at least one vowel.",
    "output": "In the first line, print m \u2014 the number of maximum possible beautiful lyrics. In next 2m lines, print m beautiful lyrics ( two lines per lyric) . If there are multiple answers, print any.",
    "note": "In the first example, those beautiful lyrics are one of the possible answers. Let' s look at the first lyric on the sample output of the first example. \" about proud hooray round\" forms a beautiful lyric because \" about\" and \" hooray\" have same number of vowels, \" proud\" and \" round\" have same number of vowels, and both lines have same last vowel. On the other hand, you cannot form any beautiful lyric with the word \" codeforces\" . In the second example, you cannot form any beautiful lyric from given words. In the third example, you can use the word \" same\" up to three times.",
    "topics": [
      "data structures",
      "greedy",
      "strings"
    ]
  },
  {
    "title": "Plus from Picture",
    "url": "https://codeforces.com/problemset/problem/1182/B",
    "history": "You have a given picture with size w \u00d7 h . Determine if the given picture has a single \" + \" shape or not. A \" + \" shape is described below: A \" + \" shape has one center nonempty cell. There should be some ( at least one) consecutive non- empty cells in each direction ( left, right, up, down) from the center. In other words, there should be a ray in each direction. All other cells are empty. Find out if the given picture has single \" + \" shape.",
    "input": "The first line contains two integers h and w ( 1 \u2264 h , w \u2264 500 ) \u2014 the height and width of the picture. The i - th of the next h lines contains string s_ i of length w consisting \" . \" and \" * \" where \" . \" denotes the empty space and \" * \" denotes the non- empty space.",
    "output": "If the given picture satisfies all conditions, print \" YES\" . Otherwise, print \" NO\" . You can output each letter in any case ( upper or lower) .",
    "note": "In the first example, the given picture contains one \" + \" . In the second example, two vertical branches are located in a different column. In the third example, there is a dot outside of the shape. In the fourth example, the width of the two vertical branches is 2 . In the fifth example, there are two shapes. In the sixth example, there is an empty space inside of the shape.",
    "topics": [
      "dfs and similar",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Split a Number",
    "url": "https://codeforces.com/problemset/problem/1181/B",
    "history": "Dima worked all day and wrote down on a long paper strip his favorite number n consisting of l digits. Unfortunately, the strip turned out to be so long that it didn' t fit in the Dima' s bookshelf. To solve the issue, Dima decided to split the strip into two non- empty parts so that each of them contains a positive integer without leading zeros. After that he will compute the sum of the two integers and write it down on a new strip. Dima wants the resulting integer to be as small as possible, because it increases the chances that the sum will fit it in the bookshelf. Help Dima decide what is the minimum sum he can obtain.",
    "input": "The first line contains a single integer l ( 2 \u2264 l \u2264 100 000 ) \u2014 the length of the Dima' s favorite number. The second line contains the positive integer n initially written on the strip: the Dima' s favorite number. The integer n consists of exactly l digits and it does not contain leading zeros. Dima guarantees, that there is at least one valid way to split the strip.",
    "output": "Print a single integer \u2014 the smallest number Dima can obtain.",
    "note": "In the first example Dima can split the number 1234567 into integers 1234 and 567 . Their sum is 1801 . In the second example Dima can split the number 101 into integers 10 and 1 . Their sum is 11 . Note that it is impossible to split the strip into \" 1\" and \" 01\" since the numbers can' t start with zeros.",
    "topics": [
      "greedy",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Archaeology",
    "url": "https://codeforces.com/problemset/problem/1178/E",
    "history": "Alice bought a Congo Prime Video subscription and was watching a documentary on the archaeological findings from Factor' s Island on Loch Katrine in Scotland. The archaeologists found a book whose age and origin are unknown. Perhaps Alice can make some sense of it? The book contains a single string of characters \" a\" , \" b\" and \" c\" . It has been pointed out that no two consecutive characters are the same. It has also been conjectured that the string contains an unusually long subsequence that reads the same from both sides. Help Alice verify this by finding such subsequence that contains at least half of the characters of the original string, rounded down. Note that you don' t have to maximise the length of it. A string a is a subsequence of a string b if a can be obtained from b by deletion of several ( possibly, zero or all) characters.",
    "input": "The input consists of a single string s ( 2 \u2264 | s| \u2264 10^ 6 ) . The string s consists only of characters \" a\" , \" b\" , \" c\" . It is guaranteed that no two consecutive characters are equal.",
    "output": "Output a palindrome t that is a subsequence of s and | t| \u2265\u230a| s| / 2\u230b . If there are multiple solutions, you may print any of them. You don' t have to maximise the length of t . If there are no solutions, output a string \" IMPOSSIBLE\" ( quotes for clarity) .",
    "note": "In the first example, other valid answers include \" cacac\" , \" caac\" , \" aca\" and \" ccc\" .",
    "topics": [
      "brute force",
      "constructive algorithms",
      "greedy",
      "strings"
    ]
  },
  {
    "title": "WOW Factor",
    "url": "https://codeforces.com/problemset/problem/1178/B",
    "history": "Recall that string a is a subsequence of a string b if a can be obtained from b by deletion of several ( possibly zero or all) characters. For example, for the string a = \" wowwo\" , the following strings are subsequences: \" wowwo\" , \" wowo\" , \" oo\" , \" wow\" , \" \" , and others, but the following are not subsequences: \" owoo\" , \" owwwo\" , \" ooo\" . The wow factor of a string is the number of its subsequences equal to the word \" wow\" . Bob wants to write a string that has a large wow factor. However, the \" w\" key on his keyboard is broken, so he types two \" v\" s instead. Little did he realise that he may have introduced more \" w\" s than he thought. Consider for instance the string \" ww\" . Bob would type it as \" vvvv\" , but this string actually contains three occurrences of \" w\" : \" vvvv\" \" vvvv\" \" vvvv\" For example, the wow factor of the word \" vvvovvv\" equals to four because there are four wows: \" vvvovvv\" \" vvvovvv\" \" vvvovvv\" \" vvvovvv\" Note that the subsequence \" vvvovvv\" does not count towards the wow factor, as the \" v\" s have to be consecutive. For a given string s , compute and output its wow factor. Note that it is not guaranteed that it is possible to get s from another string replacing \" w\" with \" vv\" . For example, s can be equal to \" vov\" .",
    "input": "The input contains a single non- empty string s , consisting only of characters \" v\" and \" o\" . The length of s is at most 10^ 6 .",
    "output": "Output a single integer, the wow factor of s .",
    "note": "The first example is explained in the legend.",
    "topics": [
      "dp",
      "strings"
    ]
  },
  {
    "title": "Minus and Minus Give Plus",
    "url": "https://codeforces.com/problemset/problem/1170/C",
    "history": "Everyone knows that two consecutive ( adjacent) \" minus\" signs can be replaced with a single \" plus\" sign. You are given the string s , consisting of \" plus\" and \" minus\" signs only. Zero or more operations can be performed with it. In each operation you can choose any two adjacent \" minus\" signs, and replace them with a single \" plus\" sign. Thus, in one operation, the length of the string is reduced by exactly 1 . You are given two strings s and t . Determine if you can use 0 or more operations to get the string t from the string s .",
    "input": "The first line of the input contains an integer k ( 1 \u2264 k \u2264 10^ 5 ) , denoting the number of test cases in the input. The following lines contain descriptions of the test sets, each set consists of two lines. First comes the line containing s ( the length of the line s does not exceed 2\u00b710^ 5 ) , then comes the line containing t ( the length of the line t does not exceed 2\u00b710^ 5 ) . The lines s and t are non- empty, and they contain only \" plus\" and \" minus\" signs. The sum of the lengths of lines s over all test cases in the input does not exceed 2\u00b710^ 5 . Similarly, the sum of the lengths of lines t over all test cases in the input does not exceed 2\u00b710^ 5 .",
    "output": "Print k lines: the i - th line must contain YES if the answer to the i - th test case is positive, otherwise NO. Print YES and NO using uppercase letters only.",
    "note": "",
    "topics": [
      "*special",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Telephone Number",
    "url": "https://codeforces.com/problemset/problem/1167/A",
    "history": "A telephone number is a sequence of exactly 11 digits, where the first digit is 8. For example, the sequence 80011223388 is a telephone number, but the sequences 70011223388 and 80000011223388 are not. You are given a string s of length n , consisting of digits. In one operation you can delete any character from string s . For example, it is possible to obtain strings 112, 111 or 121 from string 1121. You need to determine whether there is such a sequence of operations ( possibly empty) , after which the string s becomes a telephone number.",
    "input": "The first line contains one integer t ( 1 \u2264 t \u2264 100 ) \u2014 the number of test cases. The first line of each test case contains one integer n ( 1 \u2264 n \u2264 100 ) \u2014 the length of string s . The second line of each test case contains the string s ( | s| = n ) consisting of digits.",
    "output": "For each test print one line. If there is a sequence of operations, after which s becomes a telephone number, print YES. Otherwise, print NO.",
    "note": "In the first test case you need to delete the first and the third digits. Then the string 7818005553535 becomes 88005553535.",
    "topics": [
      "brute force",
      "greedy",
      "strings"
    ]
  },
  {
    "title": "Mysterious Code",
    "url": "https://codeforces.com/problemset/problem/1163/D",
    "history": "During a normal walk in the forest, Katie has stumbled upon a mysterious code! However, the mysterious code had some characters unreadable. She has written down this code as a string c consisting of lowercase English characters and asterisks ( \" * \" ) , where each of the asterisks denotes an unreadable character. Excited with her discovery, Katie has decided to recover the unreadable characters by replacing each asterisk with arbitrary lowercase English letter ( different asterisks might be replaced with different letters) . Katie has a favorite string s and a not- so- favorite string t and she would love to recover the mysterious code so that it has as many occurrences of s as possible and as little occurrences of t as possible. Formally, let' s denote f( x, y) as the number of occurrences of y in x ( for example, f( aababa, ab) = 2 ) . Katie wants to recover the code c' conforming to the original c , such that f( c' , s) - f( c' , t) is largest possible. However, Katie is not very good at recovering codes in general, so she would like you to help her out.",
    "input": "The first line contains string c ( 1 \u2264 | c| \u2264 1000 ) \u2014 the mysterious code . It is guaranteed that c consists of lowercase English characters and asterisks \" * \" only. The second and third line contain strings s and t respectively ( 1 \u2264 | s| , | t| \u2264 50 , s = \u0338 t ) . It is guaranteed that s and t consist of lowercase English characters only.",
    "output": "Print a single integer \u2014 the largest possible value of f( c' , s) - f( c' , t) of the recovered code.",
    "note": "In the first example, for c' equal to \" katie\" f( c' , s) = 1 and f( c' , t) = 0 , which makes f( c' , s) - f( c' , t) = 1 which is the largest possible. In the second example, the only c' conforming to the given c is \" caat\" . The corresponding f( c' , s) - f( c' , t) = 1 - 2 = - 1 . In the third example, there are multiple ways to recover the code such that f( c' , s) - f( c' , t) is largest possible, for example \" aaa\" , \" aac\" , or even \" zaz\" . The value of f( c' , s) - f( c' , t) = 0 for all of these recovered codes. In the fourth example, the optimal recovered code c' would be \" ccc\" . The corresponding f( c' , s) - f( c' , t) = 2 .",
    "topics": [
      "dp",
      "strings"
    ]
  },
  {
    "title": "The minimal unique substring",
    "url": "https://codeforces.com/problemset/problem/1158/B",
    "history": "Let s be some string consisting of symbols \" 0\" or \" 1\" . Let' s call a string t a substring of string s , if there exists such number 1 \u2264 l \u2264 | s| - | t| + 1 that t = s_ l s_ l+ 1. . . s_ l + | t| - 1 . Let' s call a substring t of string s unique, if there exist only one such l . For example, let s = \" 1010111\" . A string t = \" 010\" is an unique substring of s , because l = 2 is the only one suitable number. But, for example t = \" 10\" isn' t a unique substring of s , because l = 1 and l = 3 are suitable. And for example t = \" 00\" at all isn' t a substring of s , because there is no suitable l . Today Vasya solved the following problem at the informatics lesson: given a string consisting of symbols \" 0\" and \" 1\" , the task is to find the length of its minimal unique substring. He has written a solution to this problem and wants to test it. He is asking you to help him. You are given 2 positive integers n and k , such that ( n 2) = ( k 2) , where ( x 2) is operation of taking remainder of x by dividing on 2 . Find any string s consisting of n symbols \" 0\" or \" 1\" , such that the length of its minimal unique substring is equal to k .",
    "input": "The first line contains two integers n and k , separated by spaces ( 1 \u2264 k \u2264 n \u2264 100 000 , ( k 2) = ( n 2) ) .",
    "output": "Print a string s of length n , consisting of symbols \" 0\" and \" 1\" . Minimal length of the unique substring of s should be equal to k . You can find any suitable string. It is guaranteed, that there exists at least one such string.",
    "note": "In the first test, it' s easy to see, that the only unique substring of string s = \" 1111\" is all string s , which has length 4 . In the second test a string s = \" 01010\" has minimal unique substring t = \" 101\" , which has length 3 . In the third test a string s = \" 1011011\" has minimal unique substring t = \" 110\" , which has length 3 .",
    "topics": [
      "constructive algorithms",
      "math",
      "strings"
    ]
  },
  {
    "title": "Ugly Pairs",
    "url": "https://codeforces.com/problemset/problem/1156/B",
    "history": "You are given a string, consisting of lowercase Latin letters. A pair of neighbouring letters in a string is considered ugly if these letters are also neighbouring in a alphabet. For example, string \" abaca\" contains ugly pairs at positions ( 1, 2) \u2014 \" ab\" and ( 2, 3) \u2014 \" ba\" . Letters ' a' and ' z' aren' t considered neighbouring in a alphabet. Can you rearrange the letters of a given string so that there are no ugly pairs? You can choose any order of the letters of the given string but you can' t add any new letters or remove the existing ones. You can also leave the order the same. If there are multiple answers, print any of them. You also have to answer T separate queries.",
    "input": "The first line contains a single integer T ( 1 \u2264 T \u2264 100 ) \u2014 the number of queries. Each of the next T lines contains string s ( 1 \u2264 | s| \u2264 100) \u2014 the string for the next query. It is guaranteed that it contains only lowercase Latin letters. Note that in hacks you have to set T = 1 .",
    "output": "Print T lines. The i - th line should contain the answer to the i - th query. If the answer for the i - th query exists, then print such a rearrangment of letters of the given string that it contains no ugly pairs. You can choose any order of the letters of the given string but you can' t add any new letters or remove the existing ones. You can also leave the order the same. If there are multiple answers, print any of them. Otherwise print \" No answer\" for that query.",
    "note": "In the first example answer \" bdac\" is also correct. The second example showcases the fact that only neighbouring in alphabet letters are not allowed. The same letter is ok. There are lots of valid answers for the third example.",
    "topics": [
      "dfs and similar",
      "greedy",
      "implementation",
      "sortings",
      "strings"
    ]
  },
  {
    "title": "Reverse a Substring",
    "url": "https://codeforces.com/problemset/problem/1155/A",
    "history": "You are given a string s consisting of n lowercase Latin letters. Let' s define a substring as a contiguous subsegment of a string. For example, \" acab\" is a substring of \" abacaba\" ( it starts in position 3 and ends in position 6 ) , but \" aa\" or \" d\" aren' t substrings of this string. So the substring of the string s from position l to position r is s[ l; r] = s_ l s_ l + 1. . . s_ r . You have to choose exactly one of the substrings of the given string and reverse it ( i. e. make s[ l; r] = s_ r s_ r - 1. . . s_ l ) to obtain a string that is less lexicographically. Note that it is not necessary to obtain the minimum possible string. If it is impossible to reverse some substring of the given string to obtain a string that is less, print \" NO\" . Otherwise print \" YES\" and any suitable substring. String x is lexicographically less than string y , if either x is a prefix of y ( and x y ) , or there exists such i ( 1 \u2264 i \u2264 min( | x| , | y| ) ) , that x_ i < y_ i , and for any j ( 1 \u2264 j < i ) x_ j = y_ j . Here | a| denotes the length of the string a . The lexicographic comparison of strings is implemented by operator < in modern programming languages\u200b\u200b.",
    "input": "The first line of the input contains one integer n ( 2 \u2264 n \u2264 3 \u00b7 10^ 5 ) \u2014 the length of s . The second line of the input contains the string s of length n consisting only of lowercase Latin letters.",
    "output": "If it is impossible to reverse some substring of the given string to obtain a string which is lexicographically less, print \" NO\" . Otherwise print \" YES\" and two indices l and r ( 1 \u2264 l < r \u2264 n ) denoting the substring you have to reverse. If there are multiple answers, you can print any.",
    "note": "In the first testcase the resulting string is \" aacabba\" .",
    "topics": [
      "implementation",
      "sortings",
      "strings"
    ]
  },
  {
    "title": "Serval and Parenthesis Sequence",
    "url": "https://codeforces.com/problemset/problem/1153/C",
    "history": "Serval soon said goodbye to Japari kindergarten, and began his life in Japari Primary School. In his favorite math class, the teacher taught him the following interesting definitions. A parenthesis sequence is a string, containing only characters \" ( \" and \" ) \" . A correct parenthesis sequence is a parenthesis sequence that can be transformed into a correct arithmetic expression by inserting characters \" 1\" and \" + \" between the original characters of the sequence. For example, parenthesis sequences \" ( ) ( ) \" , \" ( ( ) ) \" are correct ( the resulting expressions are: \" ( 1+ 1) + ( 1+ 1) \" , \" ( ( 1+ 1) + 1) \" ) , while \" ) ( \" and \" ) \" are not. Note that the empty string is a correct parenthesis sequence by definition. We define that | s| as the length of string s . A strict prefix s[ 1. . . l] ( 1\u2264 l< | s| ) of a string s = s_ 1s_ 2. . . s_ | s| is string s_ 1s_ 2. . . s_ l . Note that the empty string and the whole string are not strict prefixes of any string by the definition. Having learned these definitions, he comes up with a new problem. He writes down a string s containing only characters \" ( \" , \" ) \" and \" ? \" . And what he is going to do, is to replace each of the \" ? \" in s independently by one of \" ( \" and \" ) \" to make all strict prefixes of the new sequence not a correct parenthesis sequence, while the new sequence should be a correct parenthesis sequence. After all, he is just a primary school student so this problem is too hard for him to solve. As his best friend, can you help him to replace the question marks? If there are many solutions, any of them is acceptable.",
    "input": "The first line contains a single integer | s| ( 1\u2264 | s| \u2264 3 \u00b7 10^ 5 ) , the length of the string. The second line contains a string s , containing only \" ( \" , \" ) \" and \" ? \" .",
    "output": "A single line contains a string representing the answer. If there are many solutions, any of them is acceptable. If there is no answer, print a single line containing \" : ( \" ( without the quotes) .",
    "note": "It can be proved that there is no solution for the second sample, so print \" : ( \" .",
    "topics": [
      "greedy",
      "strings"
    ]
  },
  {
    "title": "Maxim and Biology",
    "url": "https://codeforces.com/problemset/problem/1151/A",
    "history": "Today in the scientific lyceum of the Kingdom of Kremland, there was a biology lesson. The topic of the lesson was the genomes. Let' s call the genome the string \" ACTG\" . Maxim was very boring to sit in class, so the teacher came up with a task for him: on a given string s consisting of uppercase letters and length of at least 4 , you need to find the minimum number of operations that you need to apply, so that the genome appears in it as a substring. For one operation, you can replace any letter in the string s with the next or previous in the alphabet. For example, for the letter \" D\" the previous one will be \" C\" , and the next \u2014 \" E\" . In this problem, we assume that for the letter \" A\" , the previous one will be the letter \" Z\" , and the next one will be \" B\" , and for the letter \" Z\" , the previous one is the letter \" Y\" , and the next one is the letter \" A\" . Help Maxim solve the problem that the teacher gave him. A string a is a substring of a string b if a can be obtained from b by deletion of several ( possibly, zero or all) characters from the beginning and several ( possibly, zero or all) characters from the end.",
    "input": "The first line contains a single integer n ( 4 \u2264 n \u2264 50 ) \u2014 the length of the string s . The second line contains the string s , consisting of exactly n uppercase letters of the Latin alphabet.",
    "output": "Output the minimum number of operations that need to be applied to the string s so that the genome appears as a substring in it.",
    "note": "In the first example, you should replace the letter \" Z\" with \" A\" for one operation, the letter \" H\" \u2014 with the letter \" G\" for one operation. You will get the string \" ACTG\" , in which the genome is present as a substring. In the second example, we replace the letter \" A\" with \" C\" for two operations, the letter \" D\" \u2014 with the letter \" A\" for three operations. You will get the string \" ZACTG\" , in which there is a genome.",
    "topics": [
      "brute force",
      "strings"
    ]
  },
  {
    "title": "Three Religions",
    "url": "https://codeforces.com/problemset/problem/1149/B",
    "history": "During the archaeological research in the Middle East you found the traces of three ancient religions: First religion, Second religion and Third religion. You compiled the information on the evolution of each of these beliefs, and you now wonder if the followers of each religion could coexist in peace. The Word of Universe is a long word containing the lowercase English characters only. At each moment of time, each of the religion beliefs could be described by a word consisting of lowercase English characters. The three religions can coexist in peace if their descriptions form disjoint subsequences of the Word of Universe. More formally, one can paint some of the characters of the Word of Universe in three colors: 1 , 2 , 3 , so that each character is painted in at most one color, and the description of the i - th religion can be constructed from the Word of Universe by removing all characters that aren' t painted in color i . The religions however evolve. In the beginning, each religion description is empty. Every once in a while, either a character is appended to the end of the description of a single religion, or the last character is dropped from the description. After each change, determine if the religions could coexist in peace.",
    "input": "The first line of the input contains two integers n, q ( 1 \u2264 n \u2264 100 000 , 1 \u2264 q \u2264 1000 ) \u2014 the length of the Word of Universe and the number of religion evolutions, respectively. The following line contains the Word of Universe \u2014 a string of length n consisting of lowercase English characters. Each of the following line describes a single evolution and is in one of the following formats: + i c ( i \u2208{ 1, 2, 3} , c \u2208{ a, b, . . . , z} : append the character c to the end of i - th religion description. - i ( i \u2208{ 1, 2, 3} ) \u2013 remove the last character from the i - th religion description. You can assume that the pattern is non- empty. You can assume that no religion will have description longer than 250 characters.",
    "output": "Write q lines. The i - th of them should be YES if the religions could coexist in peace after the i - th evolution, or NO otherwise. You can print each character in any case ( either upper or lower) .",
    "note": "In the first example, after the 6th evolution the religion descriptions are: ad, bc, and ab. The following figure shows how these descriptions form three disjoint subsequences of the Word of Universe:",
    "topics": [
      "dp",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Chladni Figure",
    "url": "https://codeforces.com/problemset/problem/1147/B",
    "history": "Inaka has a disc, the circumference of which is n units. The circumference is equally divided by n points numbered clockwise from 1 to n , such that points i and i + 1 ( 1 \u2264 i < n ) are adjacent, and so are points n and 1 . There are m straight segments on the disc, the endpoints of which are all among the aforementioned n points. Inaka wants to know if her image is rotationally symmetrical, i. e. if there is an integer k ( 1 \u2264 k < n ) , such that if all segments are rotated clockwise around the center of the circle by k units, the new image will be the same as the original one.",
    "input": "The first line contains two space- separated integers n and m ( 2 \u2264 n \u2264 100 000 , 1 \u2264 m \u2264 200 000 ) \u2014 the number of points and the number of segments, respectively. The i - th of the following m lines contains two space- separated integers a_ i and b_ i ( 1 \u2264 a_ i, b_ i \u2264 n , a_ i = \u0338 b_ i ) that describe a segment connecting points a_ i and b_ i . It is guaranteed that no segments coincide.",
    "output": "Output one line \u2014 \" Yes\" if the image is rotationally symmetrical, and \" No\" otherwise ( both excluding quotation marks) . You can output each letter in any case ( upper or lower) .",
    "note": "The first two examples are illustrated below. Both images become the same as their respective original ones after a clockwise rotation of 120 degrees around the center.",
    "topics": [
      "brute force",
      "strings"
    ]
  },
  {
    "title": "Hate \"A\"",
    "url": "https://codeforces.com/problemset/problem/1146/B",
    "history": "Bob has a string s consisting of lowercase English letters. He defines s' to be the string after removing all \" a\" characters from s ( keeping all other characters in the same order) . He then generates a new string t by concatenating s and s' . In other words, t= s+ s' ( look at notes for an example) . You are given a string t . Your task is to find some s that Bob could have used to generate t . It can be shown that if an answer exists, it will be unique.",
    "input": "The first line of input contains a string t ( 1 \u2264 | t| \u2264 10^ 5 ) consisting of lowercase English letters.",
    "output": "Print a string s that could have generated t . It can be shown if an answer exists, it is unique. If no string exists, print \" : ( \" ( without double quotes, there is no space between the characters) .",
    "note": "In the first example, we have s = \" aaaaa\" , and s' = \" \" . In the second example, no such s can work that will generate the given t . In the third example, we have s = \" ababacac\" , and s' = \" bbcc\" , and t = s + s' = \" ababacacbbcc\" .",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Love \"A\"",
    "url": "https://codeforces.com/problemset/problem/1146/A",
    "history": "Alice has a string s . She really likes the letter \" a\" . She calls a string good if strictly more than half of the characters in that string are \" a\" s. For example \" aaabb\" , \" axaa\" are good strings, and \" baca\" , \" awwwa\" , \" \" ( empty string) are not. Alice can erase some characters from her string s . She would like to know what is the longest string remaining after erasing some characters ( possibly zero) to get a good string. It is guaranteed that the string has at least one \" a\" in it, so the answer always exists.",
    "input": "The first line contains a string s ( 1 \u2264 | s| \u2264 50 ) consisting of lowercase English letters. It is guaranteed that there is at least one \" a\" in s .",
    "output": "Print a single integer, the length of the longest good string that Alice can get after erasing some characters from s .",
    "note": "In the first example, it' s enough to erase any four of the \" x\" s. The answer is 3 since that is the maximum number of characters that can remain. In the second example, we don' t need to erase any characters.",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Median String",
    "url": "https://codeforces.com/problemset/problem/1144/E",
    "history": "You are given two strings s and t , both consisting of exactly k lowercase Latin letters, s is lexicographically less than t . Let' s consider list of all strings consisting of exactly k lowercase Latin letters, lexicographically not less than s and not greater than t ( including s and t ) in lexicographical order. For example, for k= 2 , s= \" az\" and t= \" bf\" the list will be [ \" az\" , \" ba\" , \" bb\" , \" bc\" , \" bd\" , \" be\" , \" bf\" ] . Your task is to print the median ( the middle element) of this list. For the example above this will be \" bc\" . It is guaranteed that there is an odd number of strings lexicographically not less than s and not greater than t .",
    "input": "The first line of the input contains one integer k ( 1 \u2264 k \u2264 2 \u00b7 10^ 5 ) \u2014 the length of strings. The second line of the input contains one string s consisting of exactly k lowercase Latin letters. The third line of the input contains one string t consisting of exactly k lowercase Latin letters. It is guaranteed that s is lexicographically less than t . It is guaranteed that there is an odd number of strings lexicographically not less than s and not greater than t .",
    "output": "Print one string consisting exactly of k lowercase Latin letters \u2014 the median ( the middle element) of list of strings of length k lexicographically not less than s and not greater than t .",
    "note": "",
    "topics": [
      "bitmasks",
      "math",
      "number theory",
      "strings"
    ]
  },
  {
    "title": "Diverse Strings",
    "url": "https://codeforces.com/problemset/problem/1144/A",
    "history": "A string is called diverse if it contains consecutive ( adjacent) letters of the Latin alphabet and each letter occurs exactly once. For example, the following strings are diverse: \" fced\" , \" xyz\" , \" r\" and \" dabcef\" . The following string are not diverse: \" az\" , \" aa\" , \" bad\" and \" babc\" . Note that the letters ' a' and ' z' are not adjacent. Formally, consider positions of all letters in the string in the alphabet. These positions should form contiguous segment, i. e. they should come one by one without any gaps. And all letters in the string should be distinct ( duplicates are not allowed) . You are given a sequence of strings. For each string, if it is diverse, print \" Yes\" . Otherwise, print \" No\" .",
    "input": "The first line contains integer n ( 1 \u2264 n \u2264 100 ) , denoting the number of strings to process. The following n lines contains strings, one string per line. Each string contains only lowercase Latin letters, its length is between 1 and 100 , inclusive.",
    "output": "Print n lines, one line per a string in the input. The line should contain \" Yes\" if the corresponding string is diverse and \" No\" if the corresponding string is not diverse. You can print each letter in any case ( upper or lower) . For example, \" YeS\" , \" no\" and \" yES\" are all acceptable.",
    "note": "",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Good String",
    "url": "https://codeforces.com/problemset/problem/1140/B",
    "history": "You have a string s of length n consisting of only characters > and < . You may do some operations with this string, for each operation you have to choose some character that still remains in the string. If you choose a character > , the character that comes right after it is deleted ( if the character you chose was the last one, nothing happens) . If you choose a character < , the character that comes right before it is deleted ( if the character you chose was the first one, nothing happens) . For example, if we choose character > in string > > < > , the string will become to > > > . And if we choose character < in string > < , the string will become to < . The string is good if there is a sequence of operations such that after performing it only one character will remain in the string. For example, the strings > , > > are good. Before applying the operations, you may remove any number of characters from the given string ( possibly none, possibly up to n - 1 , but not the whole string) . You need to calculate the minimum number of characters to be deleted from string s so that it becomes good.",
    "input": "The first line contains one integer t ( 1 \u2264 t \u2264 100 ) \u2013 the number of test cases. Each test case is represented by two lines. The first line of i - th test case contains one integer n ( 1 \u2264 n \u2264 100 ) \u2013 the length of string s . The second line of i - th test case contains string s , consisting of only characters > and < .",
    "output": "For each test case print one line. For i - th test case print the minimum number of characters to be deleted from string s so that it becomes good.",
    "note": "In the first test case we can delete any character in string < > . In the second test case we don' t need to delete any characters. The string > < < is good, because we can perform the following sequence of operations: > < < \u2192 < < \u2192 < .",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Even Substrings",
    "url": "https://codeforces.com/problemset/problem/1139/A",
    "history": "You are given a string s= s_ 1s_ 2. . . s_ n of length n , which only contains digits 1 , 2 , . . . , 9 . A substring s[ l . . . r] of s is a string s_ l s_ l + 1 s_ l + 2. . . s_ r . A substring s[ l . . . r] of s is called even if the number represented by it is even. Find the number of even substrings of s . Note, that even if some substrings are equal as strings, but have different l and r , they are counted as different substrings.",
    "input": "The first line contains an integer n ( 1 \u2264 n \u2264 65000 ) \u2014 the length of the string s . The second line contains a string s of length n . The string s consists only of digits 1 , 2 , . . . , 9 .",
    "output": "Print the number of even substrings of s .",
    "note": "In the first example, the [ l, r] pairs corresponding to even substrings are: s[ 1 . . . 2] s[ 2 . . . 2] s[ 1 . . . 4] s[ 2 . . . 4] s[ 3 . . . 4] s[ 4 . . . 4] In the second example, all 10 substrings of s are even substrings. Note, that while substrings s[ 1 . . . 1] and s[ 2 . . . 2] both define the substring \" 2\" , they are still counted as different substrings.",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Circus",
    "url": "https://codeforces.com/problemset/problem/1138/B",
    "history": "Polycarp is a head of a circus troupe. There are n \u2014 an even number \u2014 artists in the troupe. It is known whether the i - th artist can perform as a clown ( if yes, then c_ i = 1 , otherwise c_ i = 0 ) , and whether they can perform as an acrobat ( if yes, then a_ i = 1 , otherwise a_ i = 0 ) . Split the artists into two performances in such a way that: each artist plays in exactly one performance, the number of artists in the two performances is equal ( i. e. equal to n/ 2 ) , the number of artists that can perform as clowns in the first performance is the same as the number of artists that can perform as acrobats in the second performance.",
    "input": "The first line contains a single integer n ( 2 \u2264 n \u2264 5 000 , n is even) \u2014 the number of artists in the troupe. The second line contains n digits c_ 1 c_ 2 . . . c_ n , the i - th of which is equal to 1 if the i - th artist can perform as a clown, and 0 otherwise. The third line contains n digits a_ 1 a_ 2 . . . a_ n , the i - th of which is equal to 1 , if the i - th artist can perform as an acrobat, and 0 otherwise.",
    "output": "Print n/ 2 distinct integers \u2014 the indices of the artists that should play in the first performance. If there are multiple answers, print any. If there is no solution, print a single integer - 1 .",
    "note": "In the first example, one of the possible divisions into two performances is as follows: in the first performance artists 1 and 4 should take part. Then the number of artists in the first performance who can perform as clowns is equal to 1 . And the number of artists in the second performance who can perform as acrobats is 1 as well. In the second example, the division is not possible. In the third example, one of the possible divisions is as follows: in the first performance artists 3 and 4 should take part. Then in the first performance there are 2 artists who can perform as clowns. And the number of artists in the second performance who can perform as acrobats is 2 as well.",
    "topics": [
      "brute force",
      "greedy",
      "math",
      "strings"
    ]
  },
  {
    "title": "Camp Schedule",
    "url": "https://codeforces.com/problemset/problem/1137/B",
    "history": "The new camp by widely- known over the country Spring Programming Camp is going to start soon. Hence, all the team of friendly curators and teachers started composing the camp' s schedule. After some continuous discussion, they came up with a schedule s , which can be represented as a binary string, in which the i - th symbol is ' 1' if students will write the contest in the i - th day and ' 0' if they will have a day off. At the last moment Gleb said that the camp will be the most productive if it runs with the schedule t ( which can be described in the same format as schedule s ) . Since the number of days in the current may be different from number of days in schedule t , Gleb required that the camp' s schedule must be altered so that the number of occurrences of t in it as a substring is maximum possible. At the same time, the number of contest days and days off shouldn' t change, only their order may change. Could you rearrange the schedule in the best possible way?",
    "input": "The first line contains string s ( 1 \u2a7d | s| \u2a7d 500 000 ) , denoting the current project of the camp' s schedule. The second line contains string t ( 1 \u2a7d | t| \u2a7d 500 000 ) , denoting the optimal schedule according to Gleb. Strings s and t contain characters ' 0' and ' 1' only.",
    "output": "In the only line print the schedule having the largest number of substrings equal to t . Printed schedule should consist of characters ' 0' and ' 1' only and the number of zeros should be equal to the number of zeros in s and the number of ones should be equal to the number of ones in s . In case there multiple optimal schedules, print any of them.",
    "note": "In the first example there are two occurrences, one starting from first position and one starting from fourth position. In the second example there is only one occurrence, which starts from third position. Note, that the answer is not unique. For example, if we move the first day ( which is a day off) to the last position, the number of occurrences of t wouldn' t change. In the third example it' s impossible to make even a single occurrence.",
    "topics": [
      "greedy",
      "hashing",
      "strings"
    ]
  },
  {
    "title": "String Multiplication",
    "url": "https://codeforces.com/problemset/problem/1131/E",
    "history": "Roman and Denis are on the trip to the programming competition. Since the trip was long, they soon got bored, and hence decided to came up with something. Roman invented a pizza' s recipe, while Denis invented a string multiplication. According to Denis, the result of multiplication ( product) of strings s of length m and t is a string t + s_ 1 + t + s_ 2 + . . . + t + s_ m + t , where s_ i denotes the i - th symbol of the string s , and \" + \" denotes string concatenation. For example, the product of strings \" abc\" and \" de\" is a string \" deadebdecde\" , while the product of the strings \" ab\" and \" z\" is a string \" zazbz\" . Note, that unlike the numbers multiplication, the product of strings s and t is not necessarily equal to product of t and s . Roman was jealous of Denis, since he invented such a cool operation, and hence decided to invent something string- related too. Since Roman is beauty- lover, he decided to define the beauty of the string as the length of the longest substring, consisting of only one letter. For example, the beauty of the string \" xayyaaabca\" is equal to 3 , since there is a substring \" aaa\" , while the beauty of the string \" qwerqwer\" is equal to 1 , since all neighboring symbols in it are different. In order to entertain Roman, Denis wrote down n strings p_ 1, p_ 2, p_ 3, . . . , p_ n on the paper and asked him to calculate the beauty of the string ( . . . ( ( ( p_ 1 \u00b7 p_ 2) \u00b7 p_ 3) \u00b7. . . ) \u00b7 p_ n , where s \u00b7 t denotes a multiplication of strings s and t . Roman hasn' t fully realized how Denis' s multiplication works, so he asked you for a help. Denis knows, that Roman is very impressionable, he guarantees, that the beauty of the resulting string is at most 10^ 9 .",
    "input": "The first line contains a single integer n ( 2 \u2264 n \u2264 100 000 ) \u2014 the number of strings, wroted by Denis. Next n lines contain non- empty strings p_ 1, p_ 2, . . . , p_ n , consisting of lowercase english letters. It' s guaranteed, that the total length of the strings p_ i is at most 100 000 , and that' s the beauty of the resulting product is at most 10^ 9 .",
    "output": "Print exactly one integer \u2014 the beauty of the product of the strings.",
    "note": "In the first example, the product of strings is equal to \" abaaaba\" . In the second example, the product of strings is equal to \" abanana\" .",
    "topics": [
      "dp",
      "greedy",
      "strings"
    ]
  },
  {
    "title": "Morse Code",
    "url": "https://codeforces.com/problemset/problem/1129/C",
    "history": "In Morse code, an letter of English alphabet is represented as a string of some length from 1 to 4 . Moreover, each Morse code representation of an English letter contains only dots and dashes. In this task, we will represent a dot with a \" 0\" and a dash with a \" 1\" . Because there are 2^ 1+ 2^ 2+ 2^ 3+ 2^ 4 = 30 strings with length 1 to 4 containing only \" 0\" and/ or \" 1\" , not all of them correspond to one of the 26 English letters. In particular, each string of \" 0\" and/ or \" 1\" of length at most 4 translates into a distinct English letter, except the following four strings that do not correspond to any English alphabet: \" 0011\" , \" 0101\" , \" 1110\" , and \" 1111\" . You will work with a string S , which is initially empty. For m times, either a dot or a dash will be appended to S , one at a time. Your task is to find and report, after each of these modifications to string S , the number of non- empty sequences of English letters that are represented with some substring of S in Morse code. Since the answers can be incredibly tremendous, print them modulo 10^ 9 + 7 .",
    "input": "The first line contains an integer m ( 1 \u2264 m \u2264 3 000 ) \u2014 the number of modifications to S . Each of the next m lines contains either a \" 0\" ( representing a dot) or a \" 1\" ( representing a dash) , specifying which character should be appended to S .",
    "output": "Print m lines, the i - th of which being the answer after the i - th modification to S .",
    "note": "Let us consider the first sample after all characters have been appended to S , so S is \" 111\" . As you can see, \" 1\" , \" 11\" , and \" 111\" all correspond to some distinct English letter. In fact, they are translated into a ' T' , an ' M' , and an ' O' , respectively. All non- empty sequences of English letters that are represented with some substring of S in Morse code, therefore, are as follows. \" T\" ( translates into \" 1\" ) \" M\" ( translates into \" 11\" ) \" O\" ( translates into \" 111\" ) \" TT\" ( translates into \" 11\" ) \" TM\" ( translates into \" 111\" ) \" MT\" ( translates into \" 111\" ) \" TTT\" ( translates into \" 111\" ) Although unnecessary for this task, a conversion table from English alphabets into Morse code can be found here.",
    "topics": [
      "binary search",
      "data structures",
      "dp",
      "hashing",
      "sortings",
      "string suffix structures",
      "strings"
    ]
  },
  {
    "title": "Compress String",
    "url": "https://codeforces.com/problemset/problem/1120/C",
    "history": "Suppose you are given a string s of length n consisting of lowercase English letters. You need to compress it using the smallest possible number of coins. To compress the string, you have to represent s as a concatenation of several non- empty strings: s = t_ 1 t_ 2. . . t_ k . The i - th of these strings should be encoded with one of the two ways: if | t_ i| = 1 , meaning that the current string consists of a single character, you can encode it paying a coins; if t_ i is a substring of t_ 1 t_ 2. . . t_ i - 1 , then you can encode it paying b coins. A string x is a substring of a string y if x can be obtained from y by deletion of several ( possibly, zero or all) characters from the beginning and several ( possibly, zero or all) characters from the end. So your task is to calculate the minimum possible number of coins you need to spend in order to compress the given string s .",
    "input": "The first line contains three positive integers, separated by spaces: n , a and b ( 1 \u2264 n, a, b \u2264 5000 ) \u2014 the length of the string, the cost to compress a one- character string and the cost to compress a string that appeared before. The second line contains a single string s , consisting of n lowercase English letters.",
    "output": "Output a single integer \u2014 the smallest possible number of coins you need to spend to compress s .",
    "note": "In the first sample case, you can set t_ 1 = ' a' , t_ 2 = ' b' , t_ 3 = ' a' and pay 3 + 3 + 1 = 7 coins, since t_ 3 is a substring of t_ 1t_ 2 . In the second sample, you just need to compress every character by itself. In the third sample, you set t_ 1 = t_ 2 = ' a' , t_ 3 = ' aa' and pay 10 + 1 + 1 = 12 coins, since t_ 2 is a substring of t_ 1 and t_ 3 is a substring of t_ 1 t_ 2 .",
    "topics": [
      "dp",
      "strings"
    ]
  },
  {
    "title": "Superhero Transformation",
    "url": "https://codeforces.com/problemset/problem/1111/A",
    "history": "We all know that a superhero can transform to certain other superheroes. But not all Superheroes can transform to any other superhero. A superhero with name s can transform to another superhero with name t if s can be made equal to t by changing any vowel in s to any other vowel and any consonant in s to any other consonant. Multiple changes can be made. In this problem, we consider the letters ' a' , ' e' , ' i' , ' o' and ' u' to be vowels and all the other letters to be consonants. Given the names of two superheroes, determine if the superhero with name s can be transformed to the Superhero with name t .",
    "input": "The first line contains the string s having length between 1 and 1000 , inclusive. The second line contains the string t having length between 1 and 1000 , inclusive. Both strings s and t are guaranteed to be different and consist of lowercase English letters only.",
    "output": "Output \" Yes\" ( without quotes) if the superhero with name s can be transformed to the superhero with name t and \" No\" ( without quotes) otherwise. You can print each letter in any case ( upper or lower) .",
    "note": "In the first sample, since both ' a' and ' u' are vowels, it is possible to convert string s to t . In the third sample, ' k' is a consonant, whereas ' a' is a vowel, so it is not possible to convert string s to t .",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Modest Substrings",
    "url": "https://codeforces.com/problemset/problem/1110/H",
    "history": "You are given two integers l and r . Let' s call an integer x modest, if l \u2264 x \u2264 r . Find a string of length n , consisting of digits, which has the largest possible number of substrings, which make a modest integer. Substring having leading zeros are not counted. If there are many answers, find lexicographically smallest one. If some number occurs multiple times as a substring, then in the counting of the number of modest substrings it is counted multiple times as well.",
    "input": "The first line contains one integer l ( 1 \u2264 l \u2264 10^ 800 ) . The second line contains one integer r ( l \u2264 r \u2264 10^ 800 ) . The third line contains one integer n ( 1 \u2264 n \u2264 2 000 ) .",
    "output": "In the first line, print the maximum possible number of modest substrings. In the second line, print a string of length n having exactly that number of modest substrings. If there are multiple such strings, print the lexicographically smallest of them.",
    "note": "In the first example, string \u00ab101\u00bb has modest substrings \u00ab1\u00bb, \u00ab10\u00bb, \u00ab1\u00bb. In the second example, string \u00ab111\u00bb has modest substrings \u00ab1\u00bb ( 3 times) and \u00ab11\u00bb ( 2 times) .",
    "topics": [
      "dp",
      "strings"
    ]
  },
  {
    "title": "Sasha and One More Name",
    "url": "https://codeforces.com/problemset/problem/1109/B",
    "history": "Reading books is one of Sasha' s passions. Once while he was reading one book, he became acquainted with an unusual character. The character told about himself like that: \" Many are my names in many countries. Mithrandir among the Elves, Tharku\u0302n to the Dwarves, Olo\u0301rin I was in my youth in the West that is forgotten, in the South Inca\u0301nus, in the North Gandalf; to the East I go not. \" And at that moment Sasha thought, how would that character be called in the East? In the East all names are palindromes. A string is a palindrome if it reads the same backward as forward. For example, such strings as \" kazak\" , \" oo\" and \" r\" are palindromes, but strings \" abb\" and \" ij\" are not. Sasha believed that the hero would be named after one of the gods of the East. As long as there couldn' t be two equal names, so in the East people did the following: they wrote the original name as a string on a piece of paper, then cut the paper minimum number of times k , so they got k+ 1 pieces of paper with substrings of the initial string, and then unite those pieces together to get a new string. Pieces couldn' t be turned over, they could be shuffled. In this way, it' s possible to achive a string abcdefg from the string f| de| abc| g using 3 cuts ( by swapping papers with substrings f and abc) . The string cbadefg can' t be received using the same cuts. More formally, Sasha wants for the given palindrome s find such minimum k , that you can cut this string into k + 1 parts, and then unite them in such a way that the final string will be a palindrome and it won' t be equal to the initial string s . It there is no answer, then print \" Impossible\" ( without quotes) .",
    "input": "The first line contains one string s ( 1 \u2264 | s| \u2264 5 000 ) \u2014 the initial name, which consists only of lowercase Latin letters. It is guaranteed that s is a palindrome.",
    "output": "Print one integer k \u2014 the minimum number of cuts needed to get a new name, or \" Impossible\" ( without quotes) .",
    "note": "In the first example, you can cut the string in those positions: no| l| on, and then unite them as follows on| l| no. It can be shown that there is no solution with one cut. In the second example, you can cut the string right in the middle, and swap peaces, so you get toot. In the third example, you can' t make a string, that won' t be equal to the initial one. In the fourth example, you can cut the suffix nik and add it to the beginning, so you get nikkinnikkin.",
    "topics": [
      "constructive algorithms",
      "hashing",
      "strings"
    ]
  },
  {
    "title": "Digits Sequence Dividing",
    "url": "https://codeforces.com/problemset/problem/1107/A",
    "history": "You are given a sequence s consisting of n digits from 1 to 9 . You have to divide it into at least two segments ( segment \u2014 is a consecutive sequence of elements) ( in other words, you have to place separators between some digits of the sequence) in such a way that each element belongs to exactly one segment and if the resulting division will be represented as an integer numbers sequence then each next element of this sequence will be strictly greater than the previous one. More formally: if the resulting division of the sequence is t_ 1, t_ 2, . . . , t_ k , where k is the number of element in a division, then for each i from 1 to k- 1 the condition t_ i < t_ i + 1 ( using numerical comparing, it means that the integer representations of strings are compared) should be satisfied. For example, if s= 654 then you can divide it into parts [ 6, 54] and it will be suitable division. But if you will divide it into parts [ 65, 4] then it will be bad division because 65 > 4 . If s= 123 then you can divide it into parts [ 1, 23] , [ 1, 2, 3] but not into parts [ 12, 3] . Your task is to find any suitable division for each of the q independent queries.",
    "input": "The first line of the input contains one integer q ( 1 \u2264 q \u2264 300 ) \u2014 the number of queries. The first line of the i - th query contains one integer number n_ i ( 2 \u2264 n_ i \u2264 300 ) \u2014 the number of digits in the i - th query. The second line of the i - th query contains one string s_ i of length n_ i consisting only of digits from 1 to 9 .",
    "output": "If the sequence of digits in the i - th query cannot be divided into at least two parts in a way described in the problem statement, print the single line \" NO\" for this query. Otherwise in the first line of the answer to this query print \" YES\" , on the second line print k_ i \u2014 the number of parts in your division of the i - th query sequence and in the third line print k_ i strings t_ i, 1, t_ i, 2, . . . , t_ i, k_ i \u2014 your division. Parts should be printed in order of the initial string digits. It means that if you write the parts one after another without changing their order then you' ll get the string s_ i . See examples for better understanding.",
    "note": "",
    "topics": [
      "greedy",
      "strings"
    ]
  },
  {
    "title": "Zuhair and Strings",
    "url": "https://codeforces.com/problemset/problem/1105/B",
    "history": "Given a string s of length n and integer k ( 1 \u2264 k \u2264 n ) . The string s has a level x , if x is largest non- negative integer, such that it' s possible to find in s : x non- intersecting ( non- overlapping) substrings of length k , all characters of these x substrings are the same ( i. e. each substring contains only one distinct character and this character is the same for all the substrings) . A substring is a sequence of consecutive ( adjacent) characters, it is defined by two integers i and j ( 1 \u2264 i \u2264 j \u2264 n ) , denoted as s[ i . . . j] = \" s_ is_ i+ 1. . . s_ j \" . For example, if k = 2 , then: the string \" aabb\" has level 1 ( you can select substring \" aa\" ) , the strings \" zzzz\" and \" zzbzz\" has level 2 ( you can select two non- intersecting substrings \" zz\" in each of them) , the strings \" abed\" and \" aca\" have level 0 ( you can' t find at least one substring of the length k= 2 containing the only distinct character) . Zuhair gave you the integer k and the string s of length n . You need to find x , the level of the string s .",
    "input": "The first line contains two integers n and k ( 1 \u2264 k \u2264 n \u2264 2 \u00b7 10^ 5 ) \u2014 the length of the string and the value of k . The second line contains the string s of length n consisting only of lowercase Latin letters.",
    "output": "Print a single integer x \u2014 the level of the string.",
    "note": "In the first example, we can select 2 non- intersecting substrings consisting of letter ' a' : \" ( aa) ac( aa) bb\" , so the level is 2 . In the second example, we can select either substring \" a\" or \" b\" to get the answer 1 .",
    "topics": [
      "brute force",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Balanced Ternary String",
    "url": "https://codeforces.com/problemset/problem/1102/D",
    "history": "You are given a string s consisting of exactly n characters, and each character is either ' 0' , ' 1' or ' 2' . Such strings are called ternary strings. Your task is to replace minimum number of characters in this string with other characters to obtain a balanced ternary string ( balanced ternary string is a ternary string such that the number of characters ' 0' in this string is equal to the number of characters ' 1' , and the number of characters ' 1' ( and ' 0' obviously) is equal to the number of characters ' 2' ) . Among all possible balanced ternary strings you have to obtain the lexicographically ( alphabetically) smallest. Note that you can neither remove characters from the string nor add characters to the string. Also note that you can replace the given characters only with characters ' 0' , ' 1' and ' 2' . It is guaranteed that the answer exists.",
    "input": "The first line of the input contains one integer n ( 3 \u2264 n \u2264 3 \u00b7 10^ 5 , n is divisible by 3 ) \u2014 the number of characters in s . The second line contains the string s consisting of exactly n characters ' 0' , ' 1' and ' 2' .",
    "output": "Print one string \u2014 the lexicographically ( alphabetically) smallest balanced ternary string which can be obtained from the given one with minimum number of replacements. Because n is divisible by 3 it is obvious that the answer exists. And it is obvious that there is only one possible answer.",
    "note": "",
    "topics": [
      "greedy",
      "strings"
    ]
  },
  {
    "title": "\u0416-function",
    "url": "https://codeforces.com/problemset/problem/1098/F",
    "history": "The length of the longest common prefix of two strings s= s_ 1 s_ 2 . . . s_ n and t = t_ 1 t_ 2 . . . t_ m is defined as the maximum k \u2264min( n, m) such that s_ 1 s_ 2 . . . s_ k equals t_ 1 t_ 2 . . . t_ k . Let' s denote the longest common prefix of two strings s and t as lcp( s, t) . Z- function of a string s_ 1 s_ 2 . . . s_ n is a sequence of integers z_ 1, z_ 2, . . . , z_ n , where z_ i = lcp( s_ 1 s_ 2 . . . s_ n, s_ i s_ i+ 1. . . s_ n) . \u0416- function of a string s is defined as z_ 1 + z_ 2 + . . . + z_ n . You' re given a string s= s_ 1 s_ 2 . . . s_ n and q queries. Each query is described by two integers l_ i and r_ i , where 1 \u2264 l_ i \u2264 r_ i \u2264 n . The answer for the query is defined as \u0416- function of the string s_ l_ i s_ l_ i + 1. . . s_ r_ i .",
    "input": "The first line contains the string s , consisting of lowercase English letters ( 1 \u2264 | s| \u2264 200 000 ) . The second line contains one integer q \u2014 the number of queries ( 1 \u2264 q \u2264 200 000 ) . Each of the following q lines contains two integers l_ i and r_ i , describing the query ( 1 \u2264 l_ i \u2264 r_ i \u2264 | s| ) .",
    "output": "For every query output one integer: the value of \u0416- function of the corresponding substring.",
    "note": "In the first sample case there are four queries: the first query corresponds to the substring bb, and its \u0416- function equals 2 + 1 = 3 ; the second query corresponds to the substring abb, and its \u0416- function equals 3 + 0 + 0 = 3 ; the third query corresponds to the substring b, and its \u0416- function equals 1 . the fourth query corresponds to the substring abdd, and its \u0416- function equals 4 + 0 + 0 + 0= 4 .",
    "topics": [
      "string suffix structures",
      "strings"
    ]
  },
  {
    "title": "Mateusz and an Infinite Sequence",
    "url": "https://codeforces.com/problemset/problem/1097/H",
    "history": "A Thue- Morse- Radecki- Mateusz sequence ( Thorse- Radewoosh sequence in short) is an infinite sequence constructed from a finite sequence gen of length d and an integer m , obtained in the following sequence of steps: In the beginning, we define the one- element sequence M_ 0= ( 0) . In the k - th step, k \u2265 1 , we define the sequence M_ k to be the concatenation of the d copies of M_ k- 1 . However, each of them is altered slightly \u2014 in the i - th of them ( 1 \u2264 i \u2264 d ) , each element x is changed to ( x+ gen_ i) m . For instance, if we pick gen = ( 0, 1, 2) and m = 4 : M_ 0 = ( 0) , M_ 1 = ( 0, 1, 2) , M_ 2 = ( 0, 1, 2, 1, 2, 3, 2, 3, 0) , M_ 3 = ( 0, 1, 2, 1, 2, 3, 2, 3, 0, 1, 2, 3, 2, 3, 0, 3, 0, 1, 2, 3, 0, 3, 0, 1, 0, 1, 2) , and so on. As you can see, as long as the first element of gen is 0 , each consecutive step produces a sequence whose prefix is the sequence generated in the previous step. Therefore, we can define the infinite Thorse- Radewoosh sequence M_ \u221e as the sequence obtained by applying the step above indefinitely. For the parameters above, M_ \u221e = ( 0, 1, 2, 1, 2, 3, 2, 3, 0, 1, 2, 3, 2, 3, 0, 3, 0, 1, . . . ) . Mateusz picked a sequence gen and an integer m , and used them to obtain a Thorse- Radewoosh sequence M_ \u221e . He then picked two integers l , r , and wrote down a subsequence of this sequence A : = ( ( M_ \u221e) _ l, ( M_ \u221e) _ l+ 1, . . . , ( M_ \u221e) _ r) . Note that we use the 1 - based indexing both for M_ \u221e and A . Mateusz has his favorite sequence B with length n , and would like to see how large it is compared to A . Let' s say that B majorizes sequence X of length n ( let' s denote it as B \u2265 X ) if and only if for all i \u2208{ 1, 2, . . . , n} , we have B_ i \u2265 X_ i . He now asks himself how many integers x in the range [ 1, | A| - n + 1] there are such that B \u2265 ( A_ x, A_ x+ 1, A_ x+ 2, . . . , A_ x+ n- 1) . As both sequences were huge, answering the question using only his pen and paper turned out to be too time- consuming. Can you help him automate his research?",
    "input": "The first line contains two integers d and m ( 2 \u2264 d \u2264 20 , 2 \u2264 m \u2264 60 ) \u2014 the length of the sequence gen and an integer used to perform the modular operations. The second line contains d integers gen_ i ( 0 \u2264gen_ i < m ) . It' s guaranteed that the first element of the sequence gen is equal to zero. The third line contains one integer n ( 1 \u2264 n \u2264 30000 ) \u2014 the length of the sequence B . The fourth line contains n integers B_ i ( 0 \u2264 B_ i < m ) . The fifth line contains two integers l and r ( 1 \u2264 l \u2264 r \u2264 10^ 18 , r- l+ 1 \u2265 n ) .",
    "output": "Print a single integer \u2014 the answer to the problem.",
    "note": "Thorse- Radewoosh sequence in the first example is the standard Thue- Morse sequence, so the sequence A is as follows: 11010011001011010010 . Here are the places where the sequence B majorizes A :",
    "topics": [
      "bitmasks",
      "brute force",
      "dp",
      "strings"
    ]
  },
  {
    "title": "Substring Removal",
    "url": "https://codeforces.com/problemset/problem/1096/B",
    "history": "You are given a string s of length n consisting only of lowercase Latin letters. A substring of a string is a contiguous subsequence of that string. So, string \" forces\" is substring of string \" codeforces\" , but string \" coder\" is not. Your task is to calculate the number of ways to remove exactly one substring from this string in such a way that all remaining characters are equal ( the number of distinct characters either zero or one) . It is guaranteed that there is at least two different characters in s . Note that you can remove the whole string and it is correct. Also note that you should remove at least one character. Since the answer can be rather large ( not very large though) print it modulo 998244353 . If you are Python programmer, consider using PyPy instead of Python when you submit your code.",
    "input": "The first line of the input contains one integer n ( 2 \u2264 n \u2264 2 \u00b7 10^ 5 ) \u2014 the length of the string s . The second line of the input contains the string s of length n consisting only of lowercase Latin letters. It is guaranteed that there is at least two different characters in s .",
    "output": "Print one integer \u2014 the number of ways modulo 998244353 to remove exactly one substring from s in such way that all remaining characters are equal.",
    "note": "Let s[ l; r] be the substring of s from the position l to the position r inclusive. Then in the first example you can remove the following substrings: s[ 1; 2] ; s[ 1; 3] ; s[ 1; 4] ; s[ 2; 2] ; s[ 2; 3] ; s[ 2; 4] . In the second example you can remove the following substrings: s[ 1; 4] ; s[ 1; 5] ; s[ 1; 6] ; s[ 1; 7] ; s[ 2; 7] ; s[ 3; 7] . In the third example you can remove the following substrings: s[ 1; 1] ; s[ 1; 2] ; s[ 2; 2] .",
    "topics": [
      "combinatorics",
      "math",
      "strings"
    ]
  },
  {
    "title": "Letters Rearranging",
    "url": "https://codeforces.com/problemset/problem/1093/B",
    "history": "You are given a string s consisting only of lowercase Latin letters. You can rearrange all letters of this string as you wish. Your task is to obtain a good string by rearranging the letters of the given string or report that it is impossible to do it. Let' s call a string good if it is not a palindrome. Palindrome is a string which is read from left to right the same as from right to left. For example, strings \" abacaba\" , \" aa\" and \" z\" are palindromes and strings \" bba\" , \" xd\" are not. You have to answer t independent queries.",
    "input": "The first line of the input contains one integer t ( 1 \u2264 t \u2264 100 ) \u2014 number of queries. Each of the next t lines contains one string. The i - th line contains a string s_ i consisting only of lowercase Latin letter. It is guaranteed that the length of s_ i is from 1 to 1000 ( inclusive) .",
    "output": "Print t lines. In the i - th line print the answer to the i - th query: - 1 if it is impossible to obtain a good string by rearranging the letters of s_ i and any good string which can be obtained from the given one ( by rearranging the letters) otherwise.",
    "note": "In the first query we cannot rearrange letters to obtain a good string. Other examples ( not all) of correct answers to the second query: \" ababaca\" , \" abcabaa\" , \" baacaba\" . In the third query we can do nothing to obtain a good string.",
    "topics": [
      "constructive algorithms",
      "greedy",
      "sortings",
      "strings"
    ]
  },
  {
    "title": "Prefixes and Suffixes",
    "url": "https://codeforces.com/problemset/problem/1092/C",
    "history": "Ivan wants to play a game with you. He picked some string s of length n consisting only of lowercase Latin letters. You don' t know this string. Ivan has informed you about all its improper prefixes and suffixes ( i. e. prefixes and suffixes of lengths from 1 to n- 1 ) , but he didn' t tell you which strings are prefixes and which are suffixes. Ivan wants you to guess which of the given 2n- 2 strings are prefixes of the given string and which are suffixes. It may be impossible to guess the string Ivan picked ( since multiple strings may give the same set of suffixes and prefixes) , but Ivan will accept your answer if there is at least one string that is consistent with it. Let the game begin!",
    "input": "The first line of the input contains one integer number n ( 2 \u2264 n \u2264 100 ) \u2014 the length of the guessed string s . The next 2n- 2 lines are contain prefixes and suffixes, one per line. Each of them is the string of length from 1 to n- 1 consisting only of lowercase Latin letters. They can be given in arbitrary order. It is guaranteed that there are exactly 2 strings of each length from 1 to n- 1 . It is also guaranteed that these strings are prefixes and suffixes of some existing string of length n .",
    "output": "Print one string of length 2n- 2 \u2014 the string consisting only of characters ' P' and ' S' . The number of characters ' P' should be equal to the number of characters ' S' . The i - th character of this string should be ' P' if the i - th of the input strings is the prefix and ' S' otherwise. If there are several possible answers, you can print any.",
    "note": "The only string which Ivan can guess in the first example is \" ababa\" . The only string which Ivan can guess in the second example is \" aaa\" . Answers \" SPSP\" , \" SSPP\" and \" PSPS\" are also acceptable. In the third example Ivan can guess the string \" ac\" or the string \" ca\" . The answer \" SP\" is also acceptable.",
    "topics": [
      "strings"
    ]
  },
  {
    "title": "Two Prefixes",
    "url": "https://codeforces.com/problemset/problem/1090/J",
    "history": "Misha didn' t do his math homework for today' s lesson once again. As a punishment, his teacher Dr. Andrew decided to give him a hard, but very useless task. Dr. Andrew has written two strings s and t of lowercase English letters at the blackboard. He reminded Misha that prefix of a string is a string formed by removing several ( possibly none) of its last characters, and a concatenation of two strings is a string formed by appending the second string to the right of the first string. The teacher asked Misha to write down on the blackboard all strings that are the concatenations of some non- empty prefix of s and some non- empty prefix of t. When Misha did it, Dr. Andrew asked him how many distinct strings are there. Misha spent almost the entire lesson doing that and completed the task. Now he asks you to write a program that would do this task automatically.",
    "input": "The first line contains the string s consisting of lowercase English letters. The second line contains the string t consisting of lowercase English letters. The lengths of both string do not exceed 105.",
    "output": "Output a single integer \u2014 the number of distinct strings that are concatenations of some non- empty prefix of s with some non- empty prefix of t.",
    "note": "In the first example, the string s has three non- empty prefixes: a, ab, aba. The string t has two non- empty prefixes: a, aa. In total, Misha has written five distinct strings: aa, aaa, aba, abaa, abaaa. The string abaa has been written twice. In the second example, Misha has written eight distinct strings: aa, aaa, aaaa, aaaaa, aaaaaa, aaaaaaa, aaaaaaaa, aaaaaaaaa.",
    "topics": [
      "strings"
    ]
  },
  {
    "title": "Vasya and Templates",
    "url": "https://codeforces.com/problemset/problem/1085/E",
    "history": "Vasya owns three strings s , a and b , each of them consists only of first k Latin letters. Let a template be such a string of length k that each of the first k Latin letters appears in it exactly once ( thus there are k! distinct templates) . Application of template p to the string s is the replacement of each character in string s with p_ i , i is the index of this letter in the alphabet. For example, applying template \" bdca\" to a string \" aabccd\" yields string \" bbdcca\" . Vasya wants to know if there exists such a template which yields a string lexicographically greater than or equal to string a and lexicographically less than or equal to string b after applying it to s . If there exist multiple suitable templates, print any of them. String a is lexicographically less than string b if there is some i ( 1 \u2264 i \u2264 n ) that a_ i < b_ i and for any j ( 1 \u2264 j < i ) a_ j = b_ j . You are required to answer t testcases independently.",
    "input": "The first line contains a single integer t ( 1 \u2264 t \u2264 10^ 6 ) \u2014 the number of testcases. In hacks you can only use t = 1 . Each of the next t lines contains the description of the testcase in the following form: The first line of the testcase contains a single integer k ( 1 \u2264 k \u2264 26 ) \u2014 the length of the template. The second line of the testcase contains the string s ( 1 \u2264 | s| \u2264 10^ 6 ) . The third line of the testcase contains the string a . The fourth line of the testcase contains the string b . Strings s , a and b have the same length ( | s| = | a| = | b| ) and consist only of the first k Latin letters, all letters are lowercase. It is guaranteed that string a is lexicographically less than or equal to string b . It is also guaranteed that the total length of strings over all testcase won' t exceed 3 \u00b7 10^ 6 .",
    "output": "Print the answers to all testcases in the following form: If there exists no suitable template then print \" NO\" in the first line. Otherwise print \" YES\" in the first line and the template itself in the second line ( k lowercase letters, each of the first k Latin letters should appear exactly once) . If there exist multiple suitable templates, print any of them.",
    "note": "",
    "topics": [
      "greedy",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Right-Left Cipher",
    "url": "https://codeforces.com/problemset/problem/1085/A",
    "history": "Polycarp loves ciphers. He has invented his own cipher called Right- Left. Right- Left cipher is used for strings. To encrypt the string s= s_ 1s_ 2. . . s_ n Polycarp uses the following algorithm: he writes down s_ 1 , he appends the current word with s_ 2 ( i. e. writes down s_ 2 to the right of the current result) , he prepends the current word with s_ 3 ( i. e. writes down s_ 3 to the left of the current result) , he appends the current word with s_ 4 ( i. e. writes down s_ 4 to the right of the current result) , he prepends the current word with s_ 5 ( i. e. writes down s_ 5 to the left of the current result) , and so on for each position until the end of s . For example, if s = \" techno\" the process is: \" t\" \u2192 \" te\" \u2192 \" cte\" \u2192 \" cteh\" \u2192 \" ncteh\" \u2192 \" ncteho\" . So the encrypted s = \" techno\" is \" ncteho\" . Given string t \u2014 the result of encryption of some string s . Your task is to decrypt it, i. e. find the string s .",
    "input": "The only line of the input contains t \u2014 the result of encryption of some string s . It contains only lowercase Latin letters. The length of t is between 1 and 50 , inclusive.",
    "output": "Print such string s that after encryption it equals t .",
    "note": "",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "The Fair Nut and Strings",
    "url": "https://codeforces.com/problemset/problem/1083/B",
    "history": "Recently, the Fair Nut has written k strings of length n , consisting of letters \" a\" and \" b\" . He calculated c \u2014 the number of strings that are prefixes of at least one of the written strings. Every string was counted only one time. Then, he lost his sheet with strings. He remembers that all written strings were lexicographically not smaller than string s and not bigger than string t . He is interested: what is the maximum value of c that he could get. A string a is lexicographically smaller than a string b if and only if one of the following holds: a is a prefix of b , but a b ; in the first position where a and b differ, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b .",
    "input": "The first line contains two integers n and k ( 1 \u2264 n \u2264 5 \u00b7 10^ 5 , 1 \u2264 k \u2264 10^ 9 ) . The second line contains a string s ( | s| = n ) \u2014 the string consisting of letters \" a\" and \" b. The third line contains a string t ( | t| = n ) \u2014 the string consisting of letters \" a\" and \" b. It is guaranteed that string s is lexicographically not bigger than t .",
    "output": "Print one number \u2014 maximal value of c .",
    "note": "In the first example, Nut could write strings \" aa\" , \" ab\" , \" ba\" , \" bb\" . These 4 strings are prefixes of at least one of the written strings, as well as \" a\" and \" b\" . Totally, 6 strings. In the second example, Nut could write strings \" aba\" , \" baa\" , \" bba\" . In the third example, there are only two different strings that Nut could write. If both of them are written, c= 8 .",
    "topics": [
      "greedy",
      "strings"
    ]
  },
  {
    "title": "Speed Dial",
    "url": "https://codeforces.com/problemset/problem/1082/F",
    "history": "Polycarp' s phone book contains n phone numbers, each of them is described by s_ i \u2014 the number itself and m_ i \u2014 the number of times Polycarp dials it in daily. Polycarp has just bought a brand new phone with an amazing speed dial feature! More precisely, k buttons on it can have a number assigned to it ( not necessary from the phone book) . To enter some number Polycarp can press one of these k buttons and then finish the number using usual digit buttons ( entering a number with only digit buttons is also possible) . Speed dial button can only be used when no digits are entered. No button can have its number reassigned. What is the minimal total number of digit number presses Polycarp can achieve after he assigns numbers to speed dial buttons and enters each of the numbers from his phone book the given number of times in an optimal way?",
    "input": "The first line contains two integers n and k ( 1 \u2264 n \u2264 500 , 1 \u2264 k \u2264 10 ) \u2014 the amount of numbers in Polycarp' s phone book and the number of speed dial buttons his new phone has. The i - th of the next n lines contain a string s_ i and an integer m_ i ( 1 \u2264 m_ i \u2264 500) , where s_ i is a non- empty string of digits from 0 to 9 inclusive ( the i - th number) , and m_ i is the amount of times it will be dialed, respectively. It is guaranteed that the total length of all phone numbers will not exceed 500 .",
    "output": "Print a single integer \u2014 the minimal total number of digit number presses Polycarp can achieve after he assigns numbers to speed dial buttons and enters each of the numbers from his phone book the given number of times in an optimal way.",
    "note": "The only speed dial button in the first example should have \" 0001\" on it. The total number of digit button presses will be 0 \u00b7 5 for the first number + 3 \u00b7 4 for the second + 2 \u00b7 1 for the third. 14 in total. The only speed dial button in the second example should have \" 00\" on it. The total number of digit button presses will be 2 \u00b7 5 for the first number + 1 \u00b7 6 for the second + 2 \u00b7 1 for the third. 18 in total.",
    "topics": [
      "dp",
      "strings",
      "trees"
    ]
  },
  {
    "title": "Palindromic Magic",
    "url": "https://codeforces.com/problemset/problem/1081/H",
    "history": "After learning some fancy algorithms about palindromes, Chouti found palindromes very interesting, so he wants to challenge you with this problem. Chouti has got two strings A and B . Since he likes palindromes, he would like to pick a as some non- empty palindromic substring of A and b as some non- empty palindromic substring of B . Concatenating them, he will get string ab . Chouti thinks strings he could get this way are interesting, so he wants to know how many different strings he can get.",
    "input": "The first line contains a single string A ( 1 \u2264 | A| \u2264 2 \u00b7 10^ 5 ) . The second line contains a single string B ( 1 \u2264 | B| \u2264 2 \u00b7 10^ 5 ) . Strings A and B contain only lowercase English letters.",
    "output": "The first and only line should contain a single integer \u2014 the number of possible strings.",
    "note": "In the first example, attainable strings are \" a\" + \" a\" = \" aa\" , \" aa\" + \" a\" = \" aaa\" , \" aa\" + \" aba\" = \" aaaba\" , \" aa\" + \" b\" = \" aab\" , \" a\" + \" aba\" = \" aaba\" , \" a\" + \" b\" = \" ab\" . In the second example, attainable strings are \" aa\" , \" aaa\" , \" aaaa\" , \" aaaba\" , \" aab\" , \" aaba\" , \" ab\" , \" abaa\" , \" abaaa\" , \" abaaba\" , \" abab\" , \" ba\" , \" baa\" , \" baba\" , \" bb\" . Notice that though \" a\" + \" aa\" = \" aa\" + \" a\" = \" aaa\" , \" aaa\" will only be counted once.",
    "topics": [
      "data structures",
      "hashing",
      "strings"
    ]
  },
  {
    "title": "Sonya and Matrix Beauty",
    "url": "https://codeforces.com/problemset/problem/1080/E",
    "history": "Sonya had a birthday recently. She was presented with the matrix of size n\u00d7 m and consist of lowercase Latin letters. We assume that the rows are numbered by integers from 1 to n from bottom to top, and the columns are numbered from 1 to m from left to right. Let' s call a submatrix ( i_ 1, j_ 1, i_ 2, j_ 2) ( 1\u2264 i_ 1\u2264 i_ 2\u2264 n; 1\u2264 j_ 1\u2264 j_ 2\u2264 m) elements a_ ij of this matrix, such that i_ 1\u2264 i\u2264 i_ 2 and j_ 1\u2264 j\u2264 j_ 2 . Sonya states that a submatrix is beautiful if we can independently reorder the characters in each row ( not in column) so that all rows and columns of this submatrix form palidroms. Let' s recall that a string is called palindrome if it reads the same from left to right and from right to left. For example, strings abacaba, bcaacb, a are palindromes while strings abca, acbba, ab are not. Help Sonya to find the number of beautiful submatrixes. Submatrixes are different if there is an element that belongs to only one submatrix.",
    "input": "The first line contains two integers n and m ( 1\u2264 n, m\u2264 250) \u2014 the matrix dimensions. Each of the next n lines contains m lowercase Latin letters.",
    "output": "Print one integer \u2014 the number of beautiful submatrixes.",
    "note": "In the first example, the following submatrixes are beautiful: ( ( 1, 1) , ( 1, 1) ) ; ( ( 1, 2) , ( 1, 2) ) ; ( ( 1, 3) , ( 1, 3) ) ; ( ( 1, 1) , ( 1, 3) ) . In the second example, all submatrixes that consist of one element and the following are beautiful: ( ( 1, 1) , ( 2, 1) ) ; ( ( 1, 1) , ( 1, 3) ) ; ( ( 2, 1) , ( 2, 3) ) ; ( ( 1, 1) , ( 2, 3) ) ; ( ( 2, 1) , ( 2, 2) ) . Some of the beautiful submatrixes are: ( ( 1, 1) , ( 1, 5) ) ; ( ( 1, 2) , ( 3, 4) ) ; ( ( 1, 1) , ( 3, 5) ) . The submatrix ( ( 1, 1) , ( 3, 5) ) is beautiful since it can be reordered as: acccaaabaaacccaIn such a matrix every row and every column form palindromes.",
    "topics": [
      "strings"
    ]
  },
  {
    "title": "Minimizing the String",
    "url": "https://codeforces.com/problemset/problem/1076/A",
    "history": "You are given a string s consisting of n lowercase Latin letters. You have to remove at most one ( i. e. zero or one) character of this string in such a way that the string you obtain will be lexicographically smallest among all strings that can be obtained using this operation. String s = s_ 1 s_ 2 . . . s_ n is lexicographically smaller than string t = t_ 1 t_ 2 . . . t_ m if n < m and s_ 1 = t_ 1, s_ 2 = t_ 2, . . . , s_ n = t_ n or there exists a number p such that p \u2264 min( n, m) and s_ 1 = t_ 1, s_ 2 = t_ 2, . . . , s_ p- 1 = t_ p- 1 and s_ p < t_ p . For example, \" aaa\" is smaller than \" aaaa\" , \" abb\" is smaller than \" abc\" , \" pqr\" is smaller than \" z\" .",
    "input": "The first line of the input contains one integer n ( 2 \u2264 n \u2264 2 \u00b7 10^ 5 ) \u2014 the length of s . The second line of the input contains exactly n lowercase Latin letters \u2014 the string s .",
    "output": "Print one string \u2014 the smallest possible lexicographically string that can be obtained by removing at most one character from the string s .",
    "note": "In the first example you can remove any character of s to obtain the string \" aa\" . In the second example \" abca\" < \" abcd\" < \" abcda\" < \" abda\" < \" acda\" < \" bcda\" .",
    "topics": [
      "greedy",
      "strings"
    ]
  },
  {
    "title": "Diverse Substring",
    "url": "https://codeforces.com/problemset/problem/1073/A",
    "history": "You are given a string s , consisting of n lowercase Latin letters. A substring of string s is a continuous segment of letters from s . For example, \" defor\" is a substring of \" codeforces\" and \" fors\" is not. The length of the substring is the number of letters in it. Let' s call some string of length n diverse if and only if there is no letter to appear strictly more than n/ 2 times. For example, strings \" abc\" and \" iltlml\" are diverse and strings \" aab\" and \" zz\" are not. Your task is to find any diverse substring of string s or report that there is none. Note that it is not required to maximize or minimize the length of the resulting substring.",
    "input": "The first line contains a single integer n ( 1 \u2264 n \u2264 1000 ) \u2014 the length of string s . The second line is the string s , consisting of exactly n lowercase Latin letters.",
    "output": "Print \" NO\" if there is no diverse substring in the string s . Otherwise the first line should contain \" YES\" . The second line should contain any diverse substring of string s .",
    "note": "The first example has lots of correct answers. Please, restrain yourself from asking if some specific answer is correct for some specific test or not, these questions always lead to \" No comments\" answer.",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Fibonacci Suffix",
    "url": "https://codeforces.com/problemset/problem/1065/G",
    "history": "Let' s denote ( yet again) the sequence of Fibonacci strings: F( 0) = 0, F( 1) = 1, F( i) = F( i - 2) + F( i - 1) , where the plus sign denotes the concatenation of two strings. Let' s denote the lexicographically sorted sequence of suffixes of string F( i) as A( F( i) ) . For example, F( 4) is 01101, and A( F( 4) ) is the following sequence: 01, 01101, 1, 101, 1101. Elements in this sequence are numbered from 1 . Your task is to print m first characters of k - th element of A( F( n) ) . If there are less than m characters in this suffix, then output the whole suffix.",
    "input": "The only line of the input contains three numbers n , k and m ( 1 \u2264 n, m \u2264 200 , 1 \u2264 k \u2264 10^ 18 ) denoting the index of the Fibonacci string you have to consider, the index of the element of A( F( n) ) and the number of characters you have to output, respectively. It is guaranteed that k does not exceed the length of F( n) .",
    "output": "Output m first characters of k - th element of A( F( n) ) , or the whole element if its length is less than m .",
    "note": "",
    "topics": [
      "strings"
    ]
  },
  {
    "title": "Side Transmutations",
    "url": "https://codeforces.com/problemset/problem/1065/E",
    "history": "Consider some set of distinct characters A and some string S , consisting of exactly n characters, where each character is present in A . You are given an array of m integers b ( b_ 1 < b_ 2 < . . . < b_ m ) . You are allowed to perform the following move on the string S : Choose some valid i and set k = b_ i ; Take the first k characters of S = Pr_ k ; Take the last k characters of S = Su_ k ; Substitute the first k characters of S with the reversed Su_ k ; Substitute the last k characters of S with the reversed Pr_ k . For example, let' s take a look at S = \" abcdefghi\" and k = 2 . Pr_ 2 = \" ab\" , Su_ 2 = \" hi\" . Reversed Pr_ 2 = \" ba\" , Su_ 2 = \" ih\" . Thus, the resulting S is \" ihcdefgba\" . The move can be performed arbitrary number of times ( possibly zero) . Any i can be selected multiple times over these moves. Let' s call some strings S and T equal if and only if there exists such a sequence of moves to transmute string S to string T . For the above example strings \" abcdefghi\" and \" ihcdefgba\" are equal. Also note that this implies S = S . The task is simple. Count the number of distinct strings. The answer can be huge enough, so calculate it modulo 998244353 .",
    "input": "The first line contains three integers n , m and | A| ( 2 \u2264 n \u2264 10^ 9 , 1 \u2264 m \u2264 min( n/ 2, 2 \u00b7 10^ 5) , 1 \u2264 | A| \u2264 10^ 9 ) \u2014 the length of the strings, the size of the array b and the size of the set A , respectively. The second line contains m integers b_ 1, b_ 2, . . . , b_ m ( 1 \u2264 b_ i \u2264n/ 2 , b_ 1 < b_ 2 < . . . < b_ m ) .",
    "output": "Print a single integer \u2014 the number of distinct strings of length n with characters from set A modulo 998244353 .",
    "note": "Here are all the distinct strings for the first example. The chosen letters ' a' and ' b' are there just to show that the characters in A are different. \" aaa\" \" aab\" = \" baa\" \" aba\" \" abb\" = \" bba\" \" bab\" \" bbb\"",
    "topics": [
      "combinatorics",
      "strings"
    ]
  },
  {
    "title": "Oh Those Palindromes",
    "url": "https://codeforces.com/problemset/problem/1063/A",
    "history": "A non- empty string is called palindrome, if it reads the same from the left to the right and from the right to the left. For example, \" abcba\" , \" a\" , and \" abba\" are palindromes, while \" abab\" and \" xy\" are not. A string is called a substring of another string, if it can be obtained from that string by dropping some ( possibly zero) number of characters from the beginning and from the end of it. For example, \" abc\" , \" ab\" , and \" c\" are substrings of the string \" abc\" , while \" ac\" and \" d\" are not. Let' s define a palindromic count of the string as the number of its substrings that are palindromes. For example, the palindromic count of the string \" aaa\" is 6 because all its substrings are palindromes, and the palindromic count of the string \" abc\" is 3 because only its substrings of length 1 are palindromes. You are given a string s . You can arbitrarily rearrange its characters. You goal is to obtain a string with the maximum possible value of palindromic count.",
    "input": "The first line contains an integer n ( 1 \u2264 n \u2264 100 000 ) \u2014 the length of string s . The second line contains string s that consists of exactly n lowercase characters of Latin alphabet.",
    "output": "Print string t , which consists of the same set of characters ( and each characters appears exactly the same number of times) as string s . Moreover, t should have the maximum possible value of palindromic count among all such strings strings. If there are multiple such strings, print any of them.",
    "note": "In the first example, string \" ololo\" has 9 palindromic substrings: \" o\" , \" l\" , \" o\" , \" l\" , \" o\" , \" olo\" , \" lol\" , \" olo\" , \" ololo\" . Note, that even though some substrings coincide, they are counted as many times as they appear in the resulting string. In the second example, the palindromic count of string \" abccbaghghghgdfd\" is 29 .",
    "topics": [
      "constructive algorithms",
      "strings"
    ]
  },
  {
    "title": "Detect Robots",
    "url": "https://codeforces.com/problemset/problem/1056/H",
    "history": "You successfully found poor Arkady near the exit of the station you' ve perfectly predicted. You sent him home on a taxi and suddenly came up with a question. There are n crossroads in your city and several bidirectional roads connecting some of them. A taxi ride is a path from some crossroads to another one without passing the same crossroads twice. You have a collection of rides made by one driver and now you wonder if this driver can be a robot or they are definitely a human. You think that the driver can be a robot if for every two crossroads a and b the driver always chooses the same path whenever he drives from a to b . Note that a and b here do not have to be the endpoints of a ride and that the path from b to a can be different. On the contrary, if the driver ever has driven two different paths from a to b , they are definitely a human. Given the system of roads and the description of all rides available to you, determine if the driver can be a robot or not.",
    "input": "Each test contains one or more test cases. The first line contains a single integer t ( 1 \u2264 t \u2264 3 \u00b7 10^ 5 ) \u2014 the number of test cases. The first line of each test case contains a single integer n ( 1 \u2264 n \u2264 3 \u00b7 10^ 5 ) \u2014 the number of crossroads in the city. The next line contains a single integer q ( 1 \u2264 q \u2264 3 \u00b7 10^ 5 ) \u2014 the number of rides available to you. Each of the following q lines starts with a single integer k ( 2 \u2264 k \u2264 n ) \u2014 the number of crossroads visited by the driver on this ride. It is followed by k integers c_ 1 , c_ 2 , . . . , c_ k ( 1 \u2264 c_ i \u2264 n ) \u2014 the crossroads in the order the driver visited them. It is guaranteed that all crossroads in one ride are distinct. It is guaranteed that the sum of values k among all rides of all test cases does not exceed 3 \u00b7 10^ 5 . It is guaranteed that the sum of values n and the sum of values q doesn' t exceed 3 \u00b7 10^ 5 among all test cases.",
    "output": "Output a single line for each test case. If the driver can be a robot, output \" Robot\" in a single line. Otherwise, output \" Human\" . You can print each letter in any case ( upper or lower) .",
    "note": "In the first example it is clear that the driver used two different ways to get from crossroads 1 to crossroads 3 . It must be a human. In the second example the driver always drives the cycle 1 \u2192 2 \u2192 3 \u2192 4 \u2192 1 until he reaches destination.",
    "topics": [
      "data structures",
      "strings"
    ]
  },
  {
    "title": "Check Transcription",
    "url": "https://codeforces.com/problemset/problem/1056/E",
    "history": "One of Arkady' s friends works at a huge radio telescope. A few decades ago the telescope has sent a signal s towards a faraway galaxy. Recently they' ve received a response t which they believe to be a response from aliens! The scientists now want to check if the signal t is similar to s . The original signal s was a sequence of zeros and ones ( everyone knows that binary code is the universe- wide language) . The returned signal t , however, does not look as easy as s , but the scientists don' t give up! They represented t as a sequence of English letters and say that t is similar to s if you can replace all zeros in s with some string r_ 0 and all ones in s with some other string r_ 1 and obtain t . The strings r_ 0 and r_ 1 must be different and non- empty. Please help Arkady' s friend and find the number of possible replacements for zeros and ones ( the number of pairs of strings r_ 0 and r_ 1 ) that transform s to t .",
    "input": "The first line contains a string s ( 2 \u2264 | s| \u2264 10^ 5 ) consisting of zeros and ones \u2014 the original signal. The second line contains a string t ( 1 \u2264 | t| \u2264 10^ 6 ) consisting of lowercase English letters only \u2014 the received signal. It is guaranteed, that the string s contains at least one ' 0' and at least one ' 1' .",
    "output": "Print a single integer \u2014 the number of pairs of strings r_ 0 and r_ 1 that transform s to t . In case there are no such pairs, print 0 .",
    "note": "In the first example, the possible pairs ( r_ 0, r_ 1) are as follows: \" a\" , \" aaaaa\" \" aa\" , \" aaaa\" \" aaaa\" , \" aa\" \" aaaaa\" , \" a\" The pair \" aaa\" , \" aaa\" is not allowed, since r_ 0 and r_ 1 must be different. In the second example, the following pairs are possible: \" ko\" , \" kokotlin\" \" koko\" , \" tlin\"",
    "topics": [
      "brute force",
      "data structures",
      "hashing",
      "strings"
    ]
  },
  {
    "title": "Tree and XOR",
    "url": "https://codeforces.com/problemset/problem/1055/F",
    "history": "You are given a connected undirected graph without cycles ( that is, a tree) of n vertices, moreover, there is a non- negative integer written on every edge. Consider all pairs of vertices ( v, u) ( that is, there are exactly n^ 2 such pairs) and for each pair calculate the bitwise exclusive or ( xor) of all integers on edges of the simple path between v and u . If the path consists of one vertex only, then xor of all integers on edges of this path is equal to 0 . Suppose we sorted the resulting n^ 2 values in non- decreasing order. You need to find the k - th of them. The definition of xor is as follows. Given two integers x and y , consider their binary representations ( possibly with leading zeros) : x_ k . . . x_ 2 x_ 1 x_ 0 and y_ k . . . y_ 2 y_ 1 y_ 0 ( where k is any number so that all bits of x and y can be represented) . Here, x_ i is the i - th bit of the number x and y_ i is the i - th bit of the number y . Let r = x \u2295 y be the result of the xor operation of x and y . Then r is defined as r_ k . . . r_ 2 r_ 1 r_ 0 where: r_ i = { 1, if x_ i y_ i 0, if x_ i = y_ i .",
    "input": "The first line contains two integers n and k ( 2 \u2264 n \u2264 10^ 6 , 1 \u2264 k \u2264 n^ 2 ) \u2014 the number of vertices in the tree and the number of path in the list with non- decreasing order. Each of the following n - 1 lines contains two integers p_ i and w_ i ( 1 \u2264 p_ i \u2264 i , 0 \u2264 w_ i < 2^ 62 ) \u2014 the ancestor of vertex i + 1 and the weight of the corresponding edge.",
    "output": "Print one integer: k - th smallest xor of a path in the tree.",
    "note": "The tree in the second sample test looks like this: For such a tree in total 9 paths exist: 1 \u2192 1 of value 0 2 \u2192 2 of value 0 3 \u2192 3 of value 0 2 \u2192 3 ( goes through 1 ) of value 1 = 2 \u2295 3 3 \u2192 2 ( goes through 1 ) of value 1 = 2 \u2295 3 1 \u2192 2 of value 2 2 \u2192 1 of value 2 1 \u2192 3 of value 3 3 \u2192 1 of value 3",
    "topics": [
      "strings",
      "trees"
    ]
  },
  {
    "title": "Refactoring",
    "url": "https://codeforces.com/problemset/problem/1055/D",
    "history": "Alice has written a program and now tries to improve its readability. One of the ways to improve readability is to give sensible names to the variables, so now Alice wants to rename some variables in her program. In her IDE there is a command called \" massive refactoring\" , which can replace names of many variable in just one run. To use it, Alice needs to select two strings s and t and after that for each variable the following algorithm is performed: if the variable' s name contains s as a substring, then the first ( and only first) occurrence of s is replaced with t . If the name doesn' t contain s , then this variable' s name stays the same. The list of variables is known and for each variable both the initial name and the name Alice wants this variable change to are known. Moreover, for each variable the lengths of the initial name and the target name are equal ( otherwise the alignment of the code could become broken) . You need to perform renaming of all variables in exactly one run of the massive refactoring command or determine that it is impossible.",
    "input": "The first line contains the only integer n ( 1 \u2264 n \u2264 3000 ) \u2014 the number of variables in Alice' s program. The following n lines contain the initial names of variables w_ 1, w_ 2, . . . , w_ n , one per line. After that, n more lines go, the i - th of them contains the target name w' _ i for the i - th variable. It is guaranteed that 1 \u2264 | w_ i| = | w' _ i| \u2264 3000 . It is guaranteed that there is at least one variable having its target name different from the initial name. Both initial and target names consist of lowercase English letters only. For each variable the length of its initial name is equal to the length of its target name.",
    "output": "If it is impossible to rename all variables with one call of \" massive refactoring\" , print \" NO\" ( quotes for clarity) . Otherwise, on the first line print \" YES\" ( quotes for clarity) and on the following lines print s and t ( 1 \u2264 | s| , | t| \u2264 5000 ) , which should be used for replacement. Strings s and t should consist only of lowercase letters of English alphabet. If there are multiple ways to perform a \" massive refactoring\" , you can use any of them.",
    "note": "",
    "topics": [
      "greedy",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Vasya and Big Integers",
    "url": "https://codeforces.com/problemset/problem/1051/E",
    "history": "Vasya owns three big integers \u2014 a, l, r . Let' s define a partition of x such a sequence of strings s_ 1, s_ 2, . . . , s_ k that s_ 1 + s_ 2 + . . . + s_ k = x , where + is a concatanation of strings. s_ i is the i - th element of the partition. For example, number 12345 has the following partitions: [ \" 1\" , \" 2\" , \" 3\" , \" 4\" , \" 5\" ] , [ \" 123\" , \" 4\" , \" 5\" ] , [ \" 1\" , \" 2345\" ] , [ \" 12345\" ] and lots of others. Let' s call some partition of a beautiful if each of its elements contains no leading zeros. Vasya want to know the number of beautiful partitions of number a , which has each of s_ i satisfy the condition l \u2264 s_ i \u2264 r . Note that the comparison is the integer comparison, not the string one. Help Vasya to count the amount of partitions of number a such that they match all the given requirements. The result can be rather big, so print it modulo 998244353 .",
    "input": "The first line contains a single integer a ( 1 \u2264 a \u2264 10^ 1000000) . The second line contains a single integer l ( 0 \u2264 l \u2264 10^ 1000000) . The third line contains a single integer r ( 0 \u2264 r \u2264 10^ 1000000) . It is guaranteed that l \u2264 r . It is also guaranteed that numbers a, l, r contain no leading zeros.",
    "output": "Print a single integer \u2014 the amount of partitions of number a such that they match all the given requirements modulo 998244353 .",
    "note": "In the first test case, there are two good partitions 13+ 5 and 1+ 3+ 5 . In the second test case, there is one good partition 1+ 0+ 0+ 0+ 0 .",
    "topics": [
      "binary search",
      "data structures",
      "dp",
      "hashing",
      "strings"
    ]
  },
  {
    "title": "Vasya And Password",
    "url": "https://codeforces.com/problemset/problem/1051/A",
    "history": "Vasya came up with a password to register for EatForces \u2014 a string s . The password in EatForces should be a string, consisting of lowercase and uppercase Latin letters and digits. But since EatForces takes care of the security of its users, user passwords must contain at least one digit, at least one uppercase Latin letter and at least one lowercase Latin letter. For example, the passwords \" abaCABA12\" , \" Z7q\" and \" 3R24m\" are valid, and the passwords \" qwerty\" , \" qwerty12345\" and \" Password\" are not. A substring of string s is a string x = s_ l s_ l + 1. . . s_ l + len - 1 ( 1 \u2264 l \u2264 | s| , 0 \u2264 len \u2264 | s| - l + 1) . len is the length of the substring. Note that the empty string is also considered a substring of s , it has the length 0 . Vasya' s password, however, may come too weak for the security settings of EatForces. He likes his password, so he wants to replace some its substring with another string of the same length in order to satisfy the above conditions. This operation should be performed exactly once, and the chosen string should have the minimal possible length. Note that the length of s should not change after the replacement of the substring, and the string itself should contain only lowercase and uppercase Latin letters and digits.",
    "input": "The first line contains a single integer T ( 1 \u2264 T \u2264 100 ) \u2014 the number of testcases. Each of the next T lines contains the initial password s ( 3 \u2264 | s| \u2264 100) , consisting of lowercase and uppercase Latin letters and digits. Only T = 1 is allowed for hacks.",
    "output": "For each testcase print a renewed password, which corresponds to given conditions. The length of the replaced substring is calculated as following: write down all the changed positions. If there are none, then the length is 0 . Otherwise the length is the difference between the first and the last changed position plus one. For example, the length of the changed substring between the passwords \" abcdef\" \u2192 \" a7cdEf\" is 4 , because the changed positions are 2 and 5 , thus ( 5 - 2) + 1 = 4 . It is guaranteed that such a password always exists. If there are several suitable passwords \u2014 output any of them.",
    "note": "In the first example Vasya' s password lacks a digit, he replaces substring \" C\" with \" 4\" and gets password \" abcD4E\" . That means, he changed the substring of length 1. In the second example Vasya' s password is ok from the beginning, and nothing has to be changed. That is the same as replacing the empty substring with another empty substring ( length 0) .",
    "topics": [
      "greedy",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Moonwalk challenge",
    "url": "https://codeforces.com/problemset/problem/1045/J",
    "history": "Since astronauts from BubbleCup XI mission finished their mission on the Moon and are big fans of famous singer, they decided to spend some fun time before returning to the Earth and hence created a so called \" Moonwalk challenge\" game. Teams of astronauts are given the map of craters on the Moon and direct bidirectional paths from some craters to others that are safe for \" Moonwalking\" . Each of those direct paths is colored in one color and there is unique path between each two craters. Goal of the game is to find two craters such that given array of colors appears most times as continuous subarray on the path between those two craters ( overlapping appearances should be counted) . To help your favorite team win, you should make a program that, given the map, answers the queries of the following type: For two craters and array of colors answer how many times given array appears as continuous subarray on the path from the first crater to the second. Colors are represented as lowercase English alphabet letters.",
    "input": "In the first line, integer N ( 2 \u2264 N \u2264 10^ 5) \u2014 number of craters on the Moon. Craters are numerated with numbers 1 to N . In next N- 1 lines, three values u, v, L ( 1 \u2264 u, v \u2264 N, L \u2208{ a, . . . , z} ) \u2014 denoting that there is a direct path with color L between craters u and v . Next line contains integer Q ( 1 \u2264 Q \u2264 10^ 5) \u2014 number of queries. Next Q lines contain three values u, v ( 1 \u2264 u, v \u2264 N) and S ( | S| \u2264 100) , where u and v are the two cratersfor which you should find how many times array of colors S ( represented as string) appears on the path from u to v .",
    "output": "For each query output one number that represents number of occurrences of array S on the path from u to v .",
    "note": "",
    "topics": [
      "data structures",
      "strings",
      "trees"
    ]
  },
  {
    "title": "Palindrome Pairs",
    "url": "https://codeforces.com/problemset/problem/1045/I",
    "history": "After learning a lot about space exploration, a little girl named Ana wants to change the subject. Ana is a girl who loves palindromes ( string that can be read the same backwards as forward) . She has learned how to check for a given string whether it' s a palindrome or not, but soon she grew tired of this problem, so she came up with a more interesting one and she needs your help to solve it: You are given an array of strings which consist of only small letters of the alphabet. Your task is to find how many palindrome pairs are there in the array. A palindrome pair is a pair of strings such that the following condition holds: at least one permutation of the concatenation of the two strings is a palindrome. In other words, if you have two strings, let' s say \" aab\" and \" abcac\" , and you concatenate them into \" aababcac\" , we have to check if there exists a permutation of this new string such that it is a palindrome ( in this case there exists the permutation \" aabccbaa\" ) . Two pairs are considered different if the strings are located on different indices. The pair of strings with indices ( i, j) is considered the same as the pair ( j, i) .",
    "input": "The first line contains a positive integer N ( 1 \u2264 N \u2264 100 000 ) , representing the length of the input array. Eacg of the next N lines contains a string ( consisting of lowercase English letters from ' a' to ' z' ) \u2014 an element of the input array. The total number of characters in the input array will be less than 1 000 000 .",
    "output": "Output one number, representing how many palindrome pairs there are in the array.",
    "note": "The first example: aa + bb \u2192 abba. The second example: aab + abcac = aababcac \u2192 aabccbaa aab + aa = aabaa abcac + aa = abcacaa \u2192 aacbcaa dffe + ed = dffeed \u2192 fdeedf dffe + aade = dffeaade \u2192 adfaafde ed + aade = edaade \u2192 aeddea",
    "topics": [
      "hashing",
      "strings"
    ]
  },
  {
    "title": "Speckled Band",
    "url": "https://codeforces.com/problemset/problem/1043/G",
    "history": "Ildar took a band ( a thin strip of cloth) and colored it. Formally, the band has n cells, each of them is colored into one of 26 colors, so we can denote each color with one of the lowercase letters of English alphabet. Ildar decided to take some segment of the band [ l, r] ( 1 \u2264 l \u2264 r \u2264 n ) he likes and cut it from the band. So he will create a new band that can be represented as a string t = s_ l s_ l+ 1. . . s_ r . After that Ildar will play the following game: he cuts the band t into some new bands and counts the number of different bands among them. Formally, Ildar chooses 1 \u2264 k \u2264 | t| indexes 1 \u2264 i_ 1 < i_ 2 < . . . < i_ k = | t| and cuts t to k bands- strings t_ 1 t_ 2 . . . t_ i_ 1, t_ i_ 1 + 1. . . t_ i_ 2, . . . , t_ i_ k- 1 + 1. . . t_ i_ k and counts the number of different bands among them. He wants to know the minimal possible number of different bands he can get under the constraint that at least one band repeats at least two times. The result of the game is this number. If it is impossible to cut t in such a way, the result of the game is - 1. Unfortunately Ildar hasn' t yet decided which segment he likes, but he has q segments- candidates [ l_ 1, r_ 1] , [ l_ 2, r_ 2] , . . . , [ l_ q, r_ q] . Your task is to calculate the result of the game for each of them.",
    "input": "The first line contains one integer n ( 1 \u2264 n \u2264 200 000 ) \u2014 the length of the band Ildar has. The second line contains a string s consisting of n lowercase English letters \u2014 the band Ildar has. The third line contains a single integer q ( 1 \u2264 q \u2264 200 000 ) \u2014 the number of segments Ildar has chosen as candidates. Each of the next q lines contains two integer integers l_ i and r_ i ( 1 \u2264 l_ i \u2264 r_ i \u2264 n ) denoting the ends of the i - th segment.",
    "output": "Output q lines, where the i - th of them should contain the result of the game on the segment [ l_ i, r_ i] .",
    "note": "Consider the first example. If Ildar chooses the segment [ 1, 6] , he cuts a string t = abcabc . If he cuts t into two bands abc and abc , the band abc repeats two times and the number of different tapes is 1 . So, the result of this game is 1 . If Ildar chooses the segment [ 4, 7] , he cuts a string t = abcd . It is impossible to cut this band in such a way that there is at least one band repeating at least two times. So, the result of this game is - 1 . If Ildar chooses the segment [ 3, 6] , he cuts a string t = cabc . If he cuts t into three bands c , ab and c , the band c repeats two times and the number of different bands is 2 . So, the result of this game is 2 .",
    "topics": [
      "data structures",
      "divide and conquer",
      "hashing",
      "string suffix structures",
      "strings"
    ]
  },
  {
    "title": "Wrap Around",
    "url": "https://codeforces.com/problemset/problem/1038/F",
    "history": "You are given a binary string s . Find the number of distinct cyclical binary strings of length n which contain s as a substring. The cyclical string t contains s as a substring if there is some cyclical shift of string t , such that s is a substring of this cyclical shift of t . For example, the cyclical string \" 000111\" contains substrings \" 001\" , \" 01110\" and \" 10\" , but doesn' t contain \" 0110\" and \" 10110\" . Two cyclical strings are called different if they differ from each other as strings. For example, two different strings, which differ from each other by a cyclical shift, are still considered different cyclical strings.",
    "input": "The first line contains a single integer n ( 1 \u2264 n \u2264 40 ) \u2014 the length of the target string t . The next line contains the string s ( 1 \u2264 | s| \u2264 n ) \u2014 the string which must be a substring of cyclical string t . String s contains only characters ' 0' and ' 1' .",
    "output": "Print the only integer \u2014 the number of distinct cyclical binary strings t , which contain s as a substring.",
    "note": "In the first example, there are three cyclical strings, which contain \" 0\" \u2014 \" 00\" , \" 01\" and \" 10\" . In the second example, there are only two such strings \u2014 \" 1010\" , \" 0101\" .",
    "topics": [
      "dp",
      "strings"
    ]
  },
  {
    "title": "Equality",
    "url": "https://codeforces.com/problemset/problem/1038/A",
    "history": "You are given a string s of length n , which consists only of the first k letters of the Latin alphabet. All letters in string s are uppercase. A subsequence of string s is a string that can be derived from s by deleting some of its symbols without changing the order of the remaining symbols. For example, \" ADE\" and \" BD\" are subsequences of \" ABCDE\" , but \" DEA\" is not. A subsequence of s called good if the number of occurences of each of the first k letters of the alphabet is the same. Find the length of the longest good subsequence of s .",
    "input": "The first line of the input contains integers n ( 1\u2264 n \u2264 10^ 5 ) and k ( 1 \u2264 k \u2264 26 ) . The second line of the input contains the string s of length n . String s only contains uppercase letters from ' A' to the k - th letter of Latin alphabet.",
    "output": "Print the only integer \u2014 the length of the longest good subsequence of string s .",
    "note": "In the first example, \" ACBCAB\" ( \" ACAABCCAB\" ) is one of the subsequences that has the same frequency of ' A' , ' B' and ' C' . Subsequence \" CAB\" also has the same frequency of these letters, but doesn' t have the maximum possible length. In the second example, none of the subsequences can have ' D' , hence the answer is 0 .",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Equalize",
    "url": "https://codeforces.com/problemset/problem/1037/C",
    "history": "You are given two binary strings a and b of the same length. You can perform the following two operations on the string a : Swap any two bits at indices i and j respectively ( 1 \u2264 i, j \u2264 n ) , the cost of this operation is | i - j| , that is, the absolute difference between i and j . Select any arbitrary index i ( 1 \u2264 i \u2264 n ) and flip ( change 0 to 1 or 1 to 0 ) the bit at this index. The cost of this operation is 1 . Find the minimum cost to make the string a equal to b . It is not allowed to modify string b .",
    "input": "The first line contains a single integer n ( 1 \u2264 n \u2264 10^ 6 ) \u2014 the length of the strings a and b . The second and third lines contain strings a and b respectively. Both strings a and b have length n and contain only ' 0' and ' 1' .",
    "output": "Output the minimum cost to make the string a equal to b .",
    "note": "In the first example, one of the optimal solutions is to flip index 1 and index 3 , the string a changes in the following way: \" 100\" \u2192 \" 000\" \u2192 \" 001\" . The cost is 1 + 1 = 2 . The other optimal solution is to swap bits and indices 1 and 3 , the string a changes then \" 100\" \u2192 \" 001\" , the cost is also | 1 - 3| = 2 . In the second example, the optimal solution is to swap bits at indices 2 and 3 , the string a changes as \" 0101\" \u2192 \" 0011\" . The cost is | 2 - 3| = 1 .",
    "topics": [
      "dp",
      "greedy",
      "strings"
    ]
  },
  {
    "title": "Many Equal Substrings",
    "url": "https://codeforces.com/problemset/problem/1029/A",
    "history": "You are given a string t consisting of n lowercase Latin letters and an integer number k . Let' s define a substring of some string s with indices from l to r as s[ l . . . r] . Your task is to construct such string s of minimum possible length that there are exactly k positions i such that s[ i . . . i + n - 1] = t . In other words, your task is to construct such string s of minimum possible length that there are exactly k substrings of s equal to t . It is guaranteed that the answer is always unique.",
    "input": "The first line of the input contains two integers n and k ( 1 \u2264 n, k \u2264 50 ) \u2014 the length of the string t and the number of substrings. The second line of the input contains the string t consisting of exactly n lowercase Latin letters.",
    "output": "Print such string s of minimum possible length that there are exactly k substrings of s equal to t . It is guaranteed that the answer is always unique.",
    "note": "",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Palindromic Twist",
    "url": "https://codeforces.com/problemset/problem/1027/A",
    "history": "You are given a string s consisting of n lowercase Latin letters. n is even. For each position i ( 1 \u2264 i \u2264 n ) in string s you are required to change the letter on this position either to the previous letter in alphabetic order or to the next one ( letters ' a' and ' z' have only one of these options) . Letter in every position must be changed exactly once. For example, letter ' p' should be changed either to ' o' or to ' q' , letter ' a' should be changed to ' b' and letter ' z' should be changed to ' y' . That way string \" codeforces\" , for example, can be changed to \" dpedepqbft\" ( ' c' \u2192 ' d' , ' o' \u2192 ' p' , ' d' \u2192 ' e' , ' e' \u2192 ' d' , ' f' \u2192 ' e' , ' o' \u2192 ' p' , ' r' \u2192 ' q' , ' c' \u2192 ' b' , ' e' \u2192 ' f' , ' s' \u2192 ' t' ) . String s is called a palindrome if it reads the same from left to right and from right to left. For example, strings \" abba\" and \" zz\" are palindromes and strings \" abca\" and \" zy\" are not. Your goal is to check if it' s possible to make string s a palindrome by applying the aforementioned changes to every position. Print \" YES\" if string s can be transformed to a palindrome and \" NO\" otherwise. Each testcase contains several strings, for each of them you are required to solve the problem separately.",
    "input": "The first line contains a single integer T ( 1 \u2264 T \u2264 50 ) \u2014 the number of strings in a testcase. Then 2T lines follow \u2014 lines ( 2i - 1) and 2i of them describe the i - th string. The first line of the pair contains a single integer n ( 2 \u2264 n \u2264 100 , n is even) \u2014 the length of the corresponding string. The second line of the pair contains a string s , consisting of n lowercase Latin letters.",
    "output": "Print T lines. The i - th line should contain the answer to the i - th string of the input. Print \" YES\" if it' s possible to make the i - th string a palindrome by applying the aforementioned changes to every position. Print \" NO\" otherwise.",
    "note": "The first string of the example can be changed to \" bcbbcb\" , two leftmost letters and two rightmost letters got changed to the next letters, two middle letters got changed to the previous letters. The second string can be changed to \" be\" , \" bg\" , \" de\" , \" dg\" , but none of these resulting strings are palindromes. The third string can be changed to \" beeb\" which is a palindrome. The fifth string can be changed to \" lk\" , \" lm\" , \" nk\" , \" nm\" , but none of these resulting strings are palindromes. Also note that no letter can remain the same, so you can' t obtain strings \" ll\" or \" mm\" .",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Single Wildcard Pattern Matching",
    "url": "https://codeforces.com/problemset/problem/1023/A",
    "history": "You are given two strings s and t . The string s consists of lowercase Latin letters and at most one wildcard character ' * ' , the string t consists only of lowercase Latin letters. The length of the string s equals n , the length of the string t equals m . The wildcard character ' * ' in the string s ( if any) can be replaced with an arbitrary sequence ( possibly empty) of lowercase Latin letters. No other character of s can be replaced with anything. If it is possible to replace a wildcard character ' * ' in s to obtain a string t , then the string t matches the pattern s . For example, if s= \" aba* aba\" then the following strings match it \" abaaba\" , \" abacaba\" and \" abazzzaba\" , but the following strings do not match: \" ababa\" , \" abcaaba\" , \" codeforces\" , \" aba1aba\" , \" aba? aba\" . If the given string t matches the given string s , print \" YES\" , otherwise print \" NO\" .",
    "input": "The first line contains two integers n and m ( 1 \u2264 n, m \u2264 2 \u00b7 10^ 5 ) \u2014 the length of the string s and the length of the string t , respectively. The second line contains string s of length n , which consists of lowercase Latin letters and at most one wildcard character ' * ' . The third line contains string t of length m , which consists only of lowercase Latin letters.",
    "output": "Print \" YES\" ( without quotes) , if you can obtain the string t from the string s . Otherwise print \" NO\" ( without quotes) .",
    "note": "In the first example a wildcard character ' * ' can be replaced with a string \" force\" . So the string s after this replacement is \" codeforces\" and the answer is \" YES\" . In the second example a wildcard character ' * ' can be replaced with an empty string. So the string s after this replacement is \" vkcup\" and the answer is \" YES\" . There is no wildcard character ' * ' in the third example and the strings \" v\" and \" k\" are different so the answer is \" NO\" . In the fourth example there is no such replacement of a wildcard character ' * ' that you can obtain the string t so the answer is \" NO\" .",
    "topics": [
      "brute force",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "The Supersonic Rocket",
    "url": "https://codeforces.com/problemset/problem/1017/E",
    "history": "After the war, the supersonic rocket became the most common public transportation. Each supersonic rocket consists of two \" engines\" . Each engine is a set of \" power sources\" . The first engine has n power sources, and the second one has m power sources. A power source can be described as a point ( x_ i, y_ i) on a 2- D plane. All points in each engine are different. You can manipulate each engine separately. There are two operations that you can do with each engine. You can do each operation as many times as you want. For every power source as a whole in that engine: ( x_ i, y_ i) becomes ( x_ i+ a, y_ i+ b) , a and b can be any real numbers. In other words, all power sources will be shifted. For every power source as a whole in that engine: ( x_ i, y_ i) becomes ( x_ i cos\u03b8 - y_ i sin\u03b8, x_ i sin\u03b8 + y_ i cos\u03b8) , \u03b8 can be any real number. In other words, all power sources will be rotated. The engines work as follows: after the two engines are powered, their power sources are being combined ( here power sources of different engines may coincide) . If two power sources A( x_ a, y_ a) and B( x_ b, y_ b) exist, then for all real number k that 0 k 1 , a new power source will be created C_ k( kx_ a+ ( 1- k) x_ b, ky_ a+ ( 1- k) y_ b) . Then, this procedure will be repeated again with all new and old power sources. After that, the \" power field\" from all power sources will be generated ( can be considered as an infinite set of all power sources occurred) . A supersonic rocket is \" safe\" if and only if after you manipulate the engines, destroying any power source and then power the engine, the power field generated won' t be changed ( comparing to the situation where no power source erased) . Two power fields are considered the same if and only if any power source in one field belongs to the other one as well. Given a supersonic rocket, check whether it is safe or not.",
    "input": "The first line contains two integers n , m ( 3 \u2264 n, m \u2264 10^ 5 ) \u2014 the number of power sources in each engine. Each of the next n lines contains two integers x_ i and y_ i ( 0\u2264 x_ i, y_ i\u2264 10^ 8 ) \u2014 the coordinates of the i - th power source in the first engine. Each of the next m lines contains two integers x_ i and y_ i ( 0\u2264 x_ i, y_ i\u2264 10^ 8 ) \u2014 the coordinates of the i - th power source in the second engine. It is guaranteed that there are no two or more power sources that are located in the same point in each engine.",
    "output": "Print \" YES\" if the supersonic rocket is safe, otherwise \" NO\" . You can print each letter in an arbitrary case ( upper or lower) .",
    "note": "The first sample: Those near pairs of blue and orange points actually coincide. First, manipulate the first engine: use the second operation with \u03b8 = \u03c0 ( to rotate all power sources 180 degrees) . The power sources in the first engine become ( 0, 0) , ( 0, - 2) , and ( - 2, 0) . Second, manipulate the second engine: use the first operation with a = b = - 2 . The power sources in the second engine become ( - 2, 0) , ( 0, 0) , ( 0, - 2) , and ( - 1, - 1) . You can examine that destroying any point, the power field formed by the two engines are always the solid triangle ( 0, 0) , ( - 2, 0) , ( 0, - 2) . In the second sample, no matter how you manipulate the engines, there always exists a power source in the second engine that power field will shrink if you destroy it.",
    "topics": [
      "geometry",
      "hashing",
      "strings"
    ]
  },
  {
    "title": "Bracket Substring",
    "url": "https://codeforces.com/problemset/problem/1015/F",
    "history": "You are given a bracket sequence s ( not necessarily a regular one) . A bracket sequence is a string containing only characters ' ( ' and ' ) ' . A regular bracket sequence is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters ' 1' and ' + ' between the original characters of the sequence. For example, bracket sequences \" ( ) ( ) \" and \" ( ( ) ) \" are regular ( the resulting expressions are: \" ( 1) + ( 1) \" and \" ( ( 1+ 1) + 1) \" ) , and \" ) ( \" , \" ( \" and \" ) \" are not. Your problem is to calculate the number of regular bracket sequences of length 2n containing the given bracket sequence s as a substring ( consecutive sequence of characters) modulo 10^ 9+ 7 ( 1000000007 ) .",
    "input": "The first line of the input contains one integer n ( 1 \u2264 n \u2264 100 ) \u2014 the half- length of the resulting regular bracket sequences ( the resulting sequences must have length equal to 2n ) . The second line of the input contains one string s ( 1 \u2264 | s| \u2264 200 ) \u2014 the string s that should be a substring in each of the resulting regular bracket sequences ( | s| is the length of s ) .",
    "output": "Print only one integer \u2014 the number of regular bracket sequences containing the given bracket sequence s as a substring. Since this number can be huge, print it modulo 10^ 9+ 7 ( 1000000007 ) .",
    "note": "All regular bracket sequences satisfying the conditions above for the first example: \" ( ( ( ( ) ) ) ( ) ) \" ; \" ( ( ( ) ( ) ) ) ( ) \" ; \" ( ( ( ) ) ) ( ) ( ) \" ; \" ( ( ) ( ( ) ) ) ( ) \" ; \" ( ) ( ( ( ) ) ) ( ) \" . All regular bracket sequences satisfying the conditions above for the second example: \" ( ( ( ) ) ) \" ; \" ( ( ) ( ) ) \" ; \" ( ( ) ) ( ) \" ; \" ( ) ( ( ) ) \" . And there is no regular bracket sequences of length 4 containing \" ( ( ( \" as a substring in the third example.",
    "topics": [
      "dp",
      "strings"
    ]
  },
  {
    "title": "AB-Strings",
    "url": "https://codeforces.com/problemset/problem/1012/D",
    "history": "There are two strings s and t, consisting only of letters a and b. You can make the following operation several times: choose a prefix of s, a prefix of t and swap them. Prefixes can be empty, also a prefix can coincide with a whole string. Your task is to find a sequence of operations after which one of the strings consists only of a letters and the other consists only of b letters. The number of operations should be minimized.",
    "input": "The first line contains a string s ( 1 \u2264 | s| \u2264 2\u00b7105) . The second line contains a string t ( 1 \u2264 | t| \u2264 2\u00b7105) . Here | s| and | t| denote the lengths of s and t, respectively. It is guaranteed that at least one of the strings contains at least one a letter and at least one of the strings contains at least one b letter.",
    "output": "The first line should contain a single integer n ( 0 \u2264 n \u2264 5\u00b7105) \u2014 the number of operations. Each of the next n lines should contain two space- separated integers ai, bi \u2014 the lengths of prefixes of s and t to swap, respectively. If there are multiple possible solutions, you can print any of them. It' s guaranteed that a solution with given constraints exists.",
    "note": "In the first example, you can solve the problem in two operations: Swap the prefix of the first string with length 1 and the prefix of the second string with length 0. After this swap, you' ll have strings ab and bbb. Swap the prefix of the first string with length 1 and the prefix of the second string with length 3. After this swap, you' ll have strings bbbb and a. In the second example, the strings are already appropriate, so no operations are needed.",
    "topics": [
      "constructive algorithms",
      "strings"
    ]
  },
  {
    "title": "Romaji",
    "url": "https://codeforces.com/problemset/problem/1008/A",
    "history": "Vitya has just started learning Berlanese language. It is known that Berlanese uses the Latin alphabet. Vowel letters are \" a\" , \" o\" , \" u\" , \" i\" , and \" e\" . Other letters are consonant. In Berlanese, there has to be a vowel after every consonant, but there can be any letter after any vowel. The only exception is a consonant \" n\" ; after this letter, there can be any letter ( not only a vowel) or there can be no letter at all. For example, the words \" harakiri\" , \" yupie\" , \" man\" , and \" nbo\" are Berlanese while the words \" horse\" , \" king\" , \" my\" , and \" nz\" are not. Help Vitya find out if a word s is Berlanese.",
    "input": "The first line of the input contains the string s consisting of | s| ( 1\u2264 | s| \u2264 100 ) lowercase Latin letters.",
    "output": "Print \" YES\" ( without quotes) if there is a vowel after every consonant except \" n\" , otherwise print \" NO\" . You can print each letter in any case ( upper or lower) .",
    "note": "In the first and second samples, a vowel goes after each consonant except \" n\" , so the word is Berlanese. In the third sample, the consonant \" c\" goes after the consonant \" r\" , and the consonant \" s\" stands on the end, so the word is not Berlanese.",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Delete from the Left",
    "url": "https://codeforces.com/problemset/problem/1005/B",
    "history": "You are given two strings s and t . In a single move, you can choose any of two strings and delete the first ( that is, the leftmost) character. After a move, the length of the string decreases by 1 . You can' t choose a string if it is empty. For example: by applying a move to the string \" where\" , the result is the string \" here\" , by applying a move to the string \" a\" , the result is an empty string \" \" . You are required to make two given strings equal using the fewest number of moves. It is possible that, in the end, both strings will be equal to the empty string, and so, are equal to each other. In this case, the answer is obviously the sum of the lengths of the initial strings. Write a program that finds the minimum number of moves to make two given strings s and t equal.",
    "input": "The first line of the input contains s . In the second line of the input contains t . Both strings consist only of lowercase Latin letters. The number of letters in each string is between 1 and 2\u00b710^ 5 , inclusive.",
    "output": "Output the fewest number of moves required. It is possible that, in the end, both strings will be equal to the empty string, and so, are equal to each other. In this case, the answer is obviously the sum of the lengths of the given strings.",
    "note": "In the first example, you should apply the move once to the first string and apply the move once to the second string. As a result, both strings will be equal to \" est\" . In the second example, the move should be applied to the string \" codeforces\" 8 times. As a result, the string becomes \" codeforces\" \u2192 \" es\" . The move should be applied to the string \" yes\" once. The result is the same string \" yes\" \u2192 \" es\" . In the third example, you can make the strings equal only by completely deleting them. That is, in the end, both strings will be empty. In the fourth example, the first character of the second string should be deleted.",
    "topics": [
      "brute force",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Abbreviation",
    "url": "https://codeforces.com/problemset/problem/1003/F",
    "history": "You are given a text consisting of n space- separated words. There is exactly one space character between any pair of adjacent words. There are no spaces before the first word and no spaces after the last word. The length of text is the number of letters and spaces in it. w_ i is the i - th word of text. All words consist only of lowercase Latin letters. Let' s denote a segment of words w[ i. . j] as a sequence of words w_ i, w_ i + 1, . . . , w_ j . Two segments of words w[ i_ 1 . . j_ 1] and w[ i_ 2 . . j_ 2] are considered equal if j_ 1 - i_ 1 = j_ 2 - i_ 2 , j_ 1 \u2265 i_ 1 , j_ 2 \u2265 i_ 2 , and for every t \u2208 [ 0, j_ 1 - i_ 1] w_ i_ 1 + t = w_ i_ 2 + t . For example, for the text \" to be or not to be\" the segments w[ 1. . 2] and w[ 5. . 6] are equal, they correspond to the words \" to be\" . An abbreviation is a replacement of some segments of words with their first uppercase letters. In order to perform an abbreviation, you have to choose at least two non- intersecting equal segments of words, and replace each chosen segment with the string consisting of first letters of the words in the segment ( written in uppercase) . For example, for the text \" a ab a a b ab a a b c\" you can replace segments of words w[ 2. . 4] and w[ 6. . 8] with an abbreviation \" AAA\" and obtain the text \" a AAA b AAA b c\" , or you can replace segments of words w[ 2. . 5] and w[ 6. . 9] with an abbreviation \" AAAB\" and obtain the text \" a AAAB AAAB c\" . What is the minimum length of the text after at most one abbreviation?",
    "input": "The first line of the input contains one integer n ( 1 \u2264 n \u2264 300 ) \u2014 the number of words in the text. The next line contains n space- separated words of the text w_ 1, w_ 2, . . . , w_ n . Each word consists only of lowercase Latin letters. It is guaranteed that the length of text does not exceed 10^ 5 .",
    "output": "Print one integer \u2014 the minimum length of the text after at most one abbreviation.",
    "note": "In the first example you can obtain the text \" TB or not TB\" . In the second example you can obtain the text \" a AAAB AAAB c\" . In the third example you can obtain the text \" AB aa AB bb\" .",
    "topics": [
      "dp",
      "hashing",
      "strings"
    ]
  },
  {
    "title": "A Tide of Riverscape",
    "url": "https://codeforces.com/problemset/problem/989/B",
    "history": "Walking along a riverside, Mino silently takes a note of something. \" Time, \" Mino thinks aloud. \" What? \" \" Time and tide wait for no man, \" explains Mino. \" My name, taken from the river, always reminds me of this. \" \" And what are you recording? \" \" You see it, tide. Everything has its own period, and I think I' ve figured out this one, \" says Mino with confidence. Doubtfully, Kanno peeks at Mino' s records. The records are expressed as a string s of characters ' 0' , ' 1' and ' . ' , where ' 0' denotes a low tide, ' 1' denotes a high tide, and ' . ' denotes an unknown one ( either high or low) . You are to help Mino determine whether it' s possible that after replacing each ' . ' independently with ' 0' or ' 1' , a given integer p is not a period of the resulting string. In case the answer is yes, please also show such a replacement to Mino. In this problem, a positive integer p is considered a period of string s , if for all 1 \u2264 i \u2264| s | - p , the i - th and ( i + p) - th characters of s are the same. Here | s | is the length of s .",
    "input": "The first line contains two space- separated integers n and p ( 1 \u2264 p \u2264 n \u2264 2000 ) \u2014 the length of the given string and the supposed period, respectively. The second line contains a string s of n characters \u2014 Mino' s records. s only contains characters ' 0' , ' 1' and ' . ' , and contains at least one ' . ' character.",
    "output": "Output one line \u2014 if it' s possible that p is not a period of the resulting string, output any one of such strings; otherwise output \" No\" ( without quotes, you can print letters in any case ( upper or lower) ) .",
    "note": "In the first example, 7 is not a period of the resulting string because the 1 - st and 8 - th characters of it are different. In the second example, 6 is not a period of the resulting string because the 4 - th and 10 - th characters of it are different. In the third example, 9 is always a period because the only constraint that the first and last characters are the same is already satisfied. Note that there are multiple acceptable answers for the first two examples, you can print any of them.",
    "topics": [
      "constructive algorithms",
      "strings"
    ]
  },
  {
    "title": "A Blend of Springtime",
    "url": "https://codeforces.com/problemset/problem/989/A",
    "history": "When the curtains are opened, a canvas unfolds outside. Kanno marvels at all the blonde colours along the riverside \u2014 not tangerines, but blossoms instead. \" What a pity it' s already late spring, \" sighs Mino with regret, \" one more drizzling night and they' d be gone. \" \" But these blends are at their best, aren' t they? \" Absorbed in the landscape, Kanno remains optimistic. The landscape can be expressed as a row of consecutive cells, each of which either contains a flower of colour amber or buff or canary yellow, or is empty. When a flower withers, it disappears from the cell that it originally belonged to, and it spreads petals of its colour in its two neighbouring cells ( or outside the field if the cell is on the side of the landscape) . In case petals fall outside the given cells, they simply become invisible. You are to help Kanno determine whether it' s possible that after some ( possibly none or all) flowers shed their petals, at least one of the cells contains all three colours, considering both petals and flowers. Note that flowers can wither in arbitrary order.",
    "input": "The first and only line of input contains a non- empty string s consisting of uppercase English letters ' A' , ' B' , ' C' and characters ' . ' ( dots) only ( | s | \u2264 100 ) \u2014 denoting cells containing an amber flower, a buff one, a canary yellow one, and no flowers, respectively.",
    "output": "Output \" Yes\" if it' s possible that all three colours appear in some cell, and \" No\" otherwise. You can print each letter in any case ( upper or lower) .",
    "note": "In the first example, the buff and canary yellow flowers can leave their petals in the central cell, blending all three colours in it. In the second example, it' s impossible to satisfy the requirement because there is no way that amber and buff meet in any cell.",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Substrings Sort",
    "url": "https://codeforces.com/problemset/problem/988/B",
    "history": "You are given n strings. Each string consists of lowercase English letters. Rearrange ( reorder) the given strings in such a way that for every string, all strings that are placed before it are its substrings. String a is a substring of string b if it is possible to choose several consecutive letters in b in such a way that they form a . For example, string \" for\" is contained as a substring in strings \" codeforces\" , \" for\" and \" therefore\" , but is not contained as a substring in strings \" four\" , \" fofo\" and \" rof\" .",
    "input": "The first line contains an integer n ( 1 \u2264 n \u2264 100 ) \u2014 the number of strings. The next n lines contain the given strings. The number of letters in each string is from 1 to 100 , inclusive. Each string consists of lowercase English letters. Some strings might be equal.",
    "output": "If it is impossible to reorder n given strings in required order, print \" NO\" ( without quotes) . Otherwise print \" YES\" ( without quotes) and n given strings in required order.",
    "note": "In the second example you cannot reorder the strings because the string \" abab\" is not a substring of the string \" abacaba\" .",
    "topics": [
      "sortings",
      "strings"
    ]
  },
  {
    "title": "Isomorphic Strings",
    "url": "https://codeforces.com/problemset/problem/985/F",
    "history": "You are given a string s of length n consisting of lowercase English letters. For two given strings s and t, say S is the set of distinct characters of s and T is the set of distinct characters of t. The strings s and t are isomorphic if their lengths are equal and there is a one- to- one mapping ( bijection) f between S and T for which f( si) = ti. Formally: f( si) = ti for any index i, for any character there is exactly one character that f( x) = y, for any character there is exactly one character that f( x) = y. For example, the strings \" aababc\" and \" bbcbcz\" are isomorphic. Also the strings \" aaaww\" and \" wwwaa\" are isomorphic. The following pairs of strings are not isomorphic: \" aab\" and \" bbb\" , \" test\" and \" best\" . You have to handle m queries characterized by three integers x, y, len ( 1 \u2264 x, y \u2264 n - len + 1) . For each query check if two substrings s[ x. . . x + len - 1] and s[ y. . . y + len - 1] are isomorphic.",
    "input": "The first line contains two space- separated integers n and m ( 1 \u2264 n \u2264 2\u00b7105, 1 \u2264 m \u2264 2\u00b7105) \u2014 the length of the string s and the number of queries. The second line contains string s consisting of n lowercase English letters. The following m lines contain a single query on each line: xi, yi and leni ( 1 \u2264 xi, yi \u2264 n, 1 \u2264 leni \u2264 n - max( xi, yi) + 1) \u2014 the description of the pair of the substrings to check.",
    "output": "For each query in a separate line print \" YES\" if substrings s[ xi. . . xi + leni - 1] and s[ yi. . . yi + leni - 1] are isomorphic and \" NO\" otherwise.",
    "note": "The queries in the example are following: substrings \" a\" and \" a\" are isomorphic: f( a) = a; substrings \" ab\" and \" ca\" are isomorphic: f( a) = c, f( b) = a; substrings \" bac\" and \" aba\" are not isomorphic since f( b) and f( c) must be equal to a at same time; substrings \" bac\" and \" cab\" are isomorphic: f( b) = c, f( a) = a, f( c) = b.",
    "topics": [
      "hashing",
      "strings"
    ]
  },
  {
    "title": "Antipalindrome",
    "url": "https://codeforces.com/problemset/problem/981/A",
    "history": "A string is a palindrome if it reads the same from the left to the right and from the right to the left. For example, the strings \" kek\" , \" abacaba\" , \" r\" and \" papicipap\" are palindromes, while the strings \" abb\" and \" iq\" are not. A substring s[ l . . . r] ( 1 \u2264 l \u2264 r \u2264 | s| ) of a string s = s_ 1s_ 2. . . s_ | s| is the string s_ ls_ l + 1. . . s_ r . Anna does not like palindromes, so she makes her friends call her Ann. She also changes all the words she reads in a similar way. Namely, each word s is changed into its longest substring that is not a palindrome. If all the substrings of s are palindromes, she skips the word at all. Some time ago Ann read the word s . What is the word she changed it into?",
    "input": "The first line contains a non- empty string s with length at most 50 characters, containing lowercase English letters only.",
    "output": "If there is such a substring in s that is not a palindrome, print the maximum length of such a substring. Otherwise print 0 . Note that there can be multiple longest substrings that are not palindromes, but their length is unique.",
    "note": "\" mew\" is not a palindrome, so the longest substring of it that is not a palindrome, is the string \" mew\" itself. Thus, the answer for the first example is 3 . The string \" uffuw\" is one of the longest non- palindrome substrings ( of length 5 ) of the string \" wuffuw\" , so the answer for the second example is 5 . All substrings of the string \" qqqqqqqq\" consist of equal characters so they are palindromes. This way, there are no non- palindrome substrings. Thus, the answer for the third example is 0 .",
    "topics": [
      "brute force",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Kuro and GCD and XOR and SUM",
    "url": "https://codeforces.com/problemset/problem/979/D",
    "history": "Kuro is currently playing an educational game about numbers. The game focuses on the greatest common divisor ( GCD) , the XOR value, and the sum of two numbers. Kuro loves the game so much that he solves levels by levels day by day. Sadly, he' s going on a vacation for a day, and he isn' t able to continue his solving streak on his own. As Katie is a reliable person, Kuro kindly asked her to come to his house on this day to play the game for him. Initally, there is an empty array a . The game consists of q tasks of two types. The first type asks Katie to add a number u_ i to a . The second type asks Katie to find a number v existing in a such that k_ i | GCD( x_ i, v) , x_ i + v \u2264 s_ i , and x_ i \u2295 v is maximized, where \u2295 denotes the bitwise XOR operation, GCD( c, d) denotes the greatest common divisor of integers c and d , and y | x means x is divisible by y , or report - 1 if no such numbers are found. Since you are a programmer, Katie needs you to automatically and accurately perform the tasks in the game to satisfy her dear friend Kuro. Let' s help her!",
    "input": "The first line contains one integer q ( 2 \u2264 q \u2264 10^ 5 ) \u2014 the number of tasks the game wants you to perform. q lines follow, each line begins with an integer t_ i \u2014 the type of the task: If t_ i = 1 , an integer u_ i follow ( 1 \u2264 u_ i \u2264 10^ 5 ) \u2014 you have to add u_ i to the array a . If t_ i = 2 , three integers x_ i , k_ i , and s_ i follow ( 1 \u2264 x_ i, k_ i, s_ i \u2264 10^ 5 ) \u2014 you must find a number v existing in the array a such that k_ i | GCD( x_ i, v) , x_ i + v \u2264 s_ i , and x_ i \u2295 v is maximized, where \u2295 denotes the XOR operation, or report - 1 if no such numbers are found. It is guaranteed that the type of the first task is type 1 , and there exists at least one task of type 2 .",
    "output": "For each task of type 2 , output on one line the desired number v , or - 1 if no such numbers are found.",
    "note": "In the first example, there are 5 tasks: The first task requires you to add 1 into a . a is now { 1} . The second task requires you to add 2 into a . a is now { 1, 2} . The third task asks you a question with x = 1 , k = 1 and s = 3 . Taking both 1 and 2 as v satisfies 1 | GCD( 1, v) and 1 + v \u2264 3 . Because 2 \u2295 1 = 3 > 1 \u2295 1 = 0 , 2 is the answer to this task. The fourth task asks you a question with x = 1 , k = 1 and s = 2 . Only v = 1 satisfies 1 | GCD( 1, v) and 1 + v \u2264 2 , so 1 is the answer to this task. The fifth task asks you a question with x = 1 , k = 1 and s = 1 . There are no elements in a that satisfy the conditions, so we report - 1 as the answer to this task.",
    "topics": [
      "binary search",
      "bitmasks",
      "brute force",
      "data structures",
      "dp",
      "dsu",
      "greedy",
      "math",
      "number theory",
      "strings",
      "trees"
    ]
  },
  {
    "title": "File Name",
    "url": "https://codeforces.com/problemset/problem/978/B",
    "history": "You can not just take the file and send it. When Polycarp trying to send a file in the social network \" Codehorses\" , he encountered an unexpected problem. If the name of the file contains three or more \" x\" ( lowercase Latin letters \" x\" ) in a row, the system considers that the file content does not correspond to the social network topic. In this case, the file is not sent and an error message is displayed. Determine the minimum number of characters to remove from the file name so after that the name does not contain \" xxx\" as a substring. Print 0 if the file name does not initially contain a forbidden substring \" xxx\" . You can delete characters in arbitrary positions ( not necessarily consecutive) . If you delete a character, then the length of a string is reduced by 1 . For example, if you delete the character in the position 2 from the string \" exxxii\" , then the resulting string is \" exxii\" .",
    "input": "The first line contains integer n ( 3 \u2264 n \u2264 100) \u2014 the length of the file name. The second line contains a string of length n consisting of lowercase Latin letters only \u2014 the file name.",
    "output": "Print the minimum number of characters to remove from the file name so after that the name does not contain \" xxx\" as a substring. If initially the file name dost not contain a forbidden substring \" xxx\" , print 0.",
    "note": "In the first example Polycarp tried to send a file with name contains number 33 , written in Roman numerals. But he can not just send the file, because it name contains three letters \" x\" in a row. To send the file he needs to remove any one of this letters.",
    "topics": [
      "greedy",
      "strings"
    ]
  },
  {
    "title": "Two-gram",
    "url": "https://codeforces.com/problemset/problem/977/B",
    "history": "Two- gram is an ordered pair ( i. e. string of length two) of capital Latin letters. For example, \" AZ\" , \" AA\" , \" ZA\" \u2014 three distinct two- grams. You are given a string s consisting of n capital Latin letters. Your task is to find any two- gram contained in the given string as a substring ( i. e. two consecutive characters of the string) maximal number of times. For example, for string s = \" BBAABBBA\" the answer is two- gram \" BB\" , which contained in s three times. In other words, find any most frequent two- gram. Note that occurrences of the two- gram can overlap with each other.",
    "input": "The first line of the input contains integer number n ( 2 \u2264 n \u2264 100 ) \u2014 the length of string s . The second line of the input contains the string s consisting of n capital Latin letters.",
    "output": "Print the only line containing exactly two capital Latin letters \u2014 any two- gram contained in the given string s as a substring ( i. e. two consecutive characters of the string) maximal number of times.",
    "note": "In the first example \" BA\" is also valid answer. In the second example the only two- gram \" ZZ\" can be printed because it contained in the string \" ZZZAA\" two times.",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Aramic script",
    "url": "https://codeforces.com/problemset/problem/975/A",
    "history": "In Aramic language words can only represent objects. Words in Aramic have special properties: A word is a root if it does not contain the same letter more than once. A root and all its permutations represent the same object. The root x of a word y is the word that contains all letters that appear in y in a way that each letter appears once. For example, the root of \" aaaa\" , \" aa\" , \" aaa\" is \" a\" , the root of \" aabb\" , \" bab\" , \" baabb\" , \" ab\" is \" ab\" . Any word in Aramic represents the same object as its root. You have an ancient script in Aramic. What is the number of different objects mentioned in the script?",
    "input": "The first line contains one integer n ( 1 \u2264 n \u2264 10^ 3 ) \u2014 the number of words in the script. The second line contains n words s_ 1, s_ 2, . . . , s_ n \u2014 the script itself. The length of each string does not exceed 10^ 3 . It is guaranteed that all characters of the strings are small latin letters.",
    "output": "Output one integer \u2014 the number of different objects mentioned in the given ancient Aramic script.",
    "note": "In the first test, there are two objects mentioned. The roots that represent them are \" a\" , \" ab\" . In the second test, there is only one object, its root is \" amer\" , the other strings are just permutations of \" amer\" .",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Short Code",
    "url": "https://codeforces.com/problemset/problem/965/E",
    "history": "Arkady' s code contains n variables. Each variable has a unique name consisting of lowercase English letters only. One day Arkady decided to shorten his code. He wants to replace each variable name with its non- empty prefix so that these new names are still unique ( however, a new name of some variable can coincide with some old name of another or same variable) . Among such possibilities he wants to find the way with the smallest possible total length of the new names. A string a is a prefix of a string b if you can delete some ( possibly none) characters from the end of b and obtain a . Please find this minimum possible total length of new names.",
    "input": "The first line contains a single integer n ( 1 \u2264 n \u2264 10^ 5 ) \u2014 the number of variables. The next n lines contain variable names, one per line. Each name is non- empty and contains only lowercase English letters. The total length of these strings is not greater than 10^ 5 . The variable names are distinct.",
    "output": "Print a single integer \u2014 the minimum possible total length of new variable names.",
    "note": "In the first example one of the best options is to shorten the names in the given order as \" cod\" , \" co\" , \" c\" . In the second example we can shorten the last name to \" aac\" and the first name to \" a\" without changing the other names.",
    "topics": [
      "data structures",
      "dp",
      "greedy",
      "strings",
      "trees"
    ]
  },
  {
    "title": "Frequency of String",
    "url": "https://codeforces.com/problemset/problem/963/D",
    "history": "You are given a string s . You should answer n queries. The i - th query consists of integer k_ i and string m_ i . The answer for this query is the minimum length of such a string t that t is a substring of s and m_ i has at least k_ i occurrences as a substring in t . A substring of a string is a continuous segment of characters of the string. It is guaranteed that for any two queries the strings m_ i from these queries are different.",
    "input": "The first line contains string s ( 1 \u2264 | s | \u2264 10^ 5) . The second line contains an integer n ( 1 \u2264 n \u2264 10^ 5 ) . Each of next n lines contains an integer k_ i ( 1 \u2264 k_ i \u2264 | s| ) and a non- empty string m_ i \u2014 parameters of the query with number i , in this order. All strings in input consists of lowercase English letters. Sum of length of all strings in input doesn' t exceed 10^ 5 . All m_ i are distinct.",
    "output": "For each query output the answer for it in a separate line. If a string m_ i occurs in s less that k_ i times, output - 1.",
    "note": "",
    "topics": [
      "hashing",
      "string suffix structures",
      "strings"
    ]
  },
  {
    "title": "Death Stars (medium)",
    "url": "https://codeforces.com/problemset/problem/958/A2",
    "history": "The stardate is 1983, and Princess Heidi is getting better at detecting the Death Stars. This time, two Rebel spies have yet again given Heidi two maps with the possible locations of the Death Star. Since she got rid of all double agents last time, she knows that both maps are correct, and indeed show the map of the solar system that contains the Death Star. However, this time the Empire has hidden the Death Star very well, and Heidi needs to find a place that appears on both maps in order to detect the Death Star. The first map is an N \u00d7 M grid, each cell of which shows some type of cosmic object that is present in the corresponding quadrant of space. The second map is an M \u00d7 N grid. Heidi needs to align those two maps in such a way that they overlap over some M \u00d7 M section in which all cosmic objects are identical. Help Heidi by identifying where such an M \u00d7 M section lies within both maps.",
    "input": "The first line of the input contains two space- separated integers N and M ( 1 \u2264 N \u2264 2000, 1 \u2264 M \u2264 200, M \u2264 N) . The next N lines each contain M lower- case Latin characters ( a- z) , denoting the first map. Different characters correspond to different cosmic object types. The next M lines each contain N characters, describing the second map in the same format.",
    "output": "The only line of the output should contain two space- separated integers i and j, denoting that the section of size M \u00d7 M in the first map that starts at the i- th row is equal to the section of the second map that starts at the j- th column. Rows and columns are numbered starting from 1. If there are several possible ways to align the maps, Heidi will be satisfied with any of those. It is guaranteed that a solution exists.",
    "note": "The 5- by- 5 grid for the first test case looks like this: maytheforcebewithyouhctwo",
    "topics": [
      "hashing",
      "strings"
    ]
  },
  {
    "title": "Scissors",
    "url": "https://codeforces.com/problemset/problem/955/D",
    "history": "Jenya has recently acquired quite a useful tool \u2014 k- scissors for cutting strings. They are generally used for cutting out two non- intersecting substrings of length k from an arbitrary string s ( its length should be at least 2\u00b7k in order to perform this operation) and concatenating them afterwards ( preserving the initial order) . For example, with the help of 2- scissors you can cut ab and de out of abcde and concatenate them into abde, but not ab and bc since they' re intersecting. It' s a nice idea to test this tool before using it in practice. After looking through the papers, Jenya came up with two strings s and t. His question is whether it is possible to apply his scissors to string s such that the resulting concatenation contains t as a substring?",
    "input": "The first line contains three integers n, m, k ( 2 \u2264 m \u2264 2\u00b7k \u2264 n \u2264 5\u00b7105) \u2014 length of s, length of t and the aforementioned scissors' parameter correspondingly. The next two lines feature s and t consisting of lowercase latin letters.",
    "output": "If there is no answer, print \u00abNo\u00bb. Otherwise print \u00abYes\u00bb and two integers L and R denoting the indexes where cutted substrings start ( 1- indexed) . If there are several possible answers, output any.",
    "note": "In the first sample case you can cut out two substrings starting at 1 and 5. The resulting string baaaab contains aaaa as a substring. In the second sample case the resulting string is bccb.",
    "topics": [
      "brute force",
      "strings"
    ]
  },
  {
    "title": "String Typing",
    "url": "https://codeforces.com/problemset/problem/954/B",
    "history": "You are given a string s consisting of n lowercase Latin letters. You have to type this string using your keyboard. Initially, you have an empty string. Until you type the whole string, you may perform the following operation: add a character to the end of the string. Besides, at most once you may perform one additional operation: copy the string and append it to itself. For example, if you have to type string abcabca, you can type it in 7 operations if you type all the characters one by one. However, you can type it in 5 operations if you type the string abc first and then copy it and type the last character. If you have to type string aaaaaaaaa, the best option is to type 4 characters one by one, then copy the string, and then type the remaining character. Print the minimum number of operations you need to type the given string.",
    "input": "The first line of the input containing only one integer number n ( 1 \u2264 n \u2264 100) \u2014 the length of the string you have to type. The second line containing the string s consisting of n lowercase Latin letters.",
    "output": "Print one integer number \u2014 the minimum number of operations you need to type the given string.",
    "note": "The first test described in the problem statement. In the second test you can only type all the characters one by one.",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "String Transformation",
    "url": "https://codeforces.com/problemset/problem/946/C",
    "history": "You are given a string s consisting of | s| small english letters. In one move you can replace any character of this string to the next character in alphabetical order ( a will be replaced with b, s will be replaced with t, etc. ) . You cannot replace letter z with any other letter. Your target is to make some number of moves ( not necessary minimal) to get string abcdefghijklmnopqrstuvwxyz ( english alphabet) as a subsequence. Subsequence of the string is the string that is obtained by deleting characters at some positions. You need to print the string that will be obtained from the given string and will be contain english alphabet as a subsequence or say that it is impossible.",
    "input": "The only one line of the input consisting of the string s consisting of | s| ( 1 \u2264 | s| \u2264 105) small english letters.",
    "output": "If you can get a string that can be obtained from the given string and will contain english alphabet as a subsequence, print it. Otherwise print \u00ab- 1\u00bb ( without quotes) .",
    "note": "",
    "topics": [
      "greedy",
      "strings"
    ]
  },
  {
    "title": "Phone Numbers",
    "url": "https://codeforces.com/problemset/problem/940/C",
    "history": "And where the are the phone numbers? You are given a string s consisting of lowercase English letters and an integer k. Find the lexicographically smallest string t of length k, such that its set of letters is a subset of the set of letters of s and s is lexicographically smaller than t. It' s guaranteed that the answer exists. Note that the set of letters is a set, not a multiset. For example, the set of letters of abadaba is a, b, d. String p is lexicographically smaller than string q, if p is a prefix of q, is not equal to q or there exists i, such that pi < qi and for all j < i it is satisfied that pj = qj. For example, abc is lexicographically smaller than abcd , abd is lexicographically smaller than abec, afa is not lexicographically smaller than ab and a is not lexicographically smaller than a.",
    "input": "The first line of input contains two space separated integers n and k ( 1 \u2264 n, k \u2264 100 000) \u2014 the length of s and the required length of t. The second line of input contains the string s consisting of n lowercase English letters.",
    "output": "Output the string t conforming to the requirements above. It' s guaranteed that the answer exists.",
    "note": "In the first example the list of strings t of length 3, such that the set of letters of t is a subset of letters of s is as follows: aaa, aab, aac, aba, abb, abc, aca, acb, . . . . Among them, those are lexicographically greater than abc: aca, acb, . . . . Out of those the lexicographically smallest is aca.",
    "topics": [
      "constructive algorithms",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Love Rescue",
    "url": "https://codeforces.com/problemset/problem/939/D",
    "history": "Valya and Tolya are an ideal pair, but they quarrel sometimes. Recently, Valya took offense at her boyfriend because he came to her in t- shirt with lettering that differs from lettering on her pullover. Now she doesn' t want to see him and Tolya is seating at his room and crying at her photos all day long. This story could be very sad but fairy godmother ( Tolya' s grandmother) decided to help them and restore their relationship. She secretly took Tolya' s t- shirt and Valya' s pullover and wants to make the letterings on them same. In order to do this, for one unit of mana she can buy a spell that can change some letters on the clothes. Your task is calculate the minimum amount of mana that Tolya' s grandmother should spend to rescue love of Tolya and Valya. More formally, letterings on Tolya' s t- shirt and Valya' s pullover are two strings with same length n consisting only of lowercase English letters. Using one unit of mana, grandmother can buy a spell of form ( c1, c2) ( where c1 and c2 are some lowercase English letters) , which can arbitrary number of times transform a single letter c1 to c2 and vise- versa on both Tolya' s t- shirt and Valya' s pullover. You should find the minimum amount of mana that grandmother should spend to buy a set of spells that can make the letterings equal. In addition you should output the required set of spells.",
    "input": "The first line contains a single integer n ( 1 \u2264 n \u2264 105) \u2014 the length of the letterings. The second line contains a string with length n, consisting of lowercase English letters \u2014 the lettering on Valya' s pullover. The third line contains the lettering on Tolya' s t- shirt in the same format.",
    "output": "In the first line output a single integer \u2014 the minimum amount of mana t required for rescuing love of Valya and Tolya. In the next t lines output pairs of space- separated lowercase English letters \u2014 spells that Tolya' s grandmother should buy. Spells and letters in spells can be printed in any order. If there are many optimal answers, output any.",
    "note": "In first example it' s enough to buy two spells: ( ' a' , ' d' ) and ( ' b' , ' a' ) . Then first letters will coincide when we will replace letter ' a' with ' d' . Second letters will coincide when we will replace ' b' with ' a' . Third letters will coincide when we will at first replace ' b' with ' a' and then ' a' with ' d' .",
    "topics": [
      "dfs and similar",
      "dsu",
      "graphs",
      "greedy",
      "strings"
    ]
  },
  {
    "title": "Lock Puzzle",
    "url": "https://codeforces.com/problemset/problem/936/C",
    "history": "Welcome to another task about breaking the code lock! Explorers Whitfield and Martin came across an unusual safe, inside of which, according to rumors, there are untold riches, among which one can find the solution of the problem of discrete logarithm! Of course, there is a code lock is installed on the safe. The lock has a screen that displays a string of n lowercase Latin letters. Initially, the screen displays string s. Whitfield and Martin found out that the safe will open when string t will be displayed on the screen. The string on the screen can be changed using the operation \u00abshift x\u00bb. In order to apply this operation, explorers choose an integer x from 0 to n inclusive. After that, the current string p = \u03b1\u03b2 changes to \u03b2R\u03b1, where the length of \u03b2 is x, and the length of \u03b1 is n - x. In other words, the suffix of the length x of string p is reversed and moved to the beginning of the string. For example, after the operation \u00abshift 4\u00bb the string \u00ababcacb\u00bb will be changed with string \u00abbcacab \u00bb, since \u03b1 = ab, \u03b2 = cacb, \u03b2R = bcac. Explorers are afraid that if they apply too many operations \u00abshift\u00bb, the lock will be locked forever. They ask you to find a way to get the string t on the screen, using no more than 6100 operations.",
    "input": "The first line contains an integer n, the length of the strings s and t ( 1 \u2264 n \u2264 2 000) . After that, there are two strings s and t, consisting of n lowercase Latin letters each.",
    "output": "If it is impossible to get string t from string s using no more than 6100 operations \u00abshift\u00bb, print a single number - 1. Otherwise, in the first line output the number of operations k ( 0 \u2264 k \u2264 6100) . In the next line output k numbers xi corresponding to the operations \u00abshift xi\u00bb ( 0 \u2264 xi \u2264 n) in the order in which they should be applied.",
    "note": "",
    "topics": [
      "constructive algorithms",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Palindrome Partition",
    "url": "https://codeforces.com/problemset/problem/932/G",
    "history": "Given a string s, find the number of ways to split s to substrings such that if there are k substrings ( p1, p2, p3, . . . , pk) in partition, then pi = pk - i + 1 for all i ( 1 \u2264 i \u2264 k) and k is even. Since the number of ways can be large, print it modulo 109 + 7.",
    "input": "The only line of input contains a string s ( 2 \u2264 | s| \u2264 106) of even length consisting of lowercase Latin letters.",
    "output": "Print one integer, the number of ways of partitioning the string modulo 109 + 7.",
    "note": "In the first case, the only way to partition the string is ab| cd| cd| ab. In the second case, the string can be partitioned as ab| b| ab| ab| ab| ab| b| ab or ab| b| abab| abab| b| ab or abbab| ab| ab| abbab.",
    "topics": [
      "dp",
      "string suffix structures",
      "strings"
    ]
  },
  {
    "title": "Game with String",
    "url": "https://codeforces.com/problemset/problem/930/B",
    "history": "Vasya and Kolya play a game with a string, using the following rules. Initially, Kolya creates a string s, consisting of small English letters, and uniformly at random chooses an integer k from a segment [ 0, len( s) - 1] . He tells Vasya this string s, and then shifts it k letters to the left, i. e. creates a new string t = sk + 1sk + 2. . . sns1s2. . . sk. Vasya does not know the integer k nor the string t, but he wants to guess the integer k. To do this, he asks Kolya to tell him the first letter of the new string, and then, after he sees it, open one more letter on some position, which Vasya can choose. Vasya understands, that he can' t guarantee that he will win, but he wants to know the probability of winning, if he plays optimally. He wants you to compute this probability. Note that Vasya wants to know the value of k uniquely, it means, that if there are at least two cyclic shifts of s that fit the information Vasya knowns, Vasya loses. Of course, at any moment of the game Vasya wants to maximize the probability of his win.",
    "input": "The only string contains the string s of length l ( 3 \u2264 l \u2264 5000) , consisting of small English letters only.",
    "output": "Print the only number \u2014 the answer for the problem. You answer is considered correct, if its absolute or relative error does not exceed 10 - 6. Formally, let your answer be a, and the jury' s answer be b. Your answer is considered correct if",
    "note": "In the first example Vasya can always open the second letter after opening the first letter, and the cyclic shift is always determined uniquely. In the second example if the first opened letter of t is \" t\" or \" c\" , then Vasya can' t guess the shift by opening only one other letter. On the other hand, if the first letter is \" i\" or \" a\" , then he can open the fourth letter and determine the shift uniquely.",
    "topics": [
      "implementation",
      "probabilities",
      "strings"
    ]
  },
  {
    "title": "Autocompletion",
    "url": "https://codeforces.com/problemset/problem/928/D",
    "history": "Arcady is a copywriter. His today' s task is to type up an already well- designed story using his favorite text editor. Arcady types words, punctuation signs and spaces one after another. Each letter and each sign ( including line feed) requires one keyboard click in order to be printed. Moreover, when Arcady has a non- empty prefix of some word on the screen, the editor proposes a possible autocompletion for this word, more precisely one of the already printed words such that its prefix matches the currently printed prefix if this word is unique. For example, if Arcady has already printed \u00abcodeforces\u00bb, \u00abcoding\u00bb and \u00abcodeforces\u00bb once again, then there will be no autocompletion attempt for \u00abcod\u00bb, but if he proceeds with \u00abcode\u00bb, the editor will propose \u00abcodeforces\u00bb. With a single click Arcady can follow the editor' s proposal, i. e. to transform the current prefix to it. Note that no additional symbols are printed after the autocompletion ( no spaces, line feeds, etc) . What is the minimum number of keyboard clicks Arcady has to perform to print the entire text, if he is not allowed to move the cursor or erase the already printed symbols? A word here is a contiguous sequence of latin letters bordered by spaces, punctuation signs and line/ text beginnings/ ends. Arcady uses only lowercase letters. For example, there are 20 words in \u00abit' s well- known that tic- tac- toe is a paper- and- pencil game for two players, x and o. \u00bb.",
    "input": "The only line contains Arcady' s text, consisting only of lowercase latin letters, spaces, line feeds and the following punctuation signs: \u00ab. \u00bb, \u00ab, \u00bb, \u00ab? \u00bb, \u00ab! \u00bb, \u00ab' \u00bb and \u00ab- \u00bb. The total amount of symbols doesn' t exceed 3\u00b7105. It' s guaranteed that all lines are non- empty.",
    "output": "Print a single integer \u2014 the minimum number of clicks.",
    "note": "In sample case one it' s optimal to use autocompletion for the first instance of \u00absnowboarding\u00bb after typing up \u00absn\u00bb and for the second instance of \u00absnowboarding\u00bb after typing up \u00absnowb\u00bb. This will save 7 clicks. In sample case two it doesn' t matter whether to use autocompletion or not.",
    "topics": [
      "*special",
      "strings",
      "trees"
    ]
  },
  {
    "title": "Login Verification",
    "url": "https://codeforces.com/problemset/problem/928/A",
    "history": "When registering in a social network, users are allowed to create their own convenient login to make it easier to share contacts, print it on business cards, etc. Login is an arbitrary sequence of lower and uppercase latin letters, digits and underline symbols ( \u00ab_ \u00bb) . However, in order to decrease the number of frauds and user- inattention related issues, it is prohibited to register a login if it is similar with an already existing login. More precisely, two logins s and t are considered similar if we can transform s to t via a sequence of operations of the following types: transform lowercase letters to uppercase and vice versa; change letter \u00abO\u00bb ( uppercase latin letter) to digit \u00ab0\u00bb and vice versa; change digit \u00ab1\u00bb ( one) to any letter among \u00abl\u00bb ( lowercase latin \u00abL\u00bb) , \u00abI\u00bb ( uppercase latin \u00abi\u00bb) and vice versa, or change one of these letters to other. For example, logins \u00abCodeforces\u00bb and \u00abcodef0rces\u00bb as well as \u00abOO0OOO00O0OOO0O00OOO0OO_ lol\u00bb and \u00abOO0OOO0O00OOO0O00OO0OOO_ 1oI\u00bb are considered similar whereas \u00abCodeforces\u00bb and \u00abCode_ forces\u00bb are not. You' re given a list of existing logins with no two similar amonst and a newly created user login. Check whether this new login is similar with any of the existing ones.",
    "input": "The first line contains a non- empty string s consisting of lower and uppercase latin letters, digits and underline symbols ( \u00ab_ \u00bb) with length not exceeding 50 \u2014 the login itself. The second line contains a single integer n ( 1 \u2264 n \u2264 1 000) \u2014 the number of existing logins. The next n lines describe the existing logins, following the same constraints as the user login ( refer to the first line of the input) . It' s guaranteed that no two existing logins are similar.",
    "output": "Print \u00abYes\u00bb ( without quotes) , if user can register via this login, i. e. none of the existing logins is similar with it. Otherwise print \u00abNo\u00bb ( without quotes) .",
    "note": "In the second sample case the user wants to create a login consisting of three zeros. It' s impossible due to collision with the third among the existing. In the third sample case the new login is similar with the second one.",
    "topics": [
      "*special",
      "strings"
    ]
  },
  {
    "title": "Picking Strings",
    "url": "https://codeforces.com/problemset/problem/923/D",
    "history": "Alice has a string consisting of characters ' A' , ' B' and ' C' . Bob can use the following transitions on any substring of our string in any order any number of times: A BC B AC C AB AAA empty string Note that a substring is one or more consecutive characters. For given queries, determine whether it is possible to obtain the target string from source.",
    "input": "The first line contains a string S ( 1 \u2264 | S| \u2264 105) . The second line contains a string T ( 1 \u2264 | T| \u2264 105) , each of these strings consists only of uppercase English letters ' A' , ' B' and ' C' . The third line contains the number of queries Q ( 1 \u2264 Q \u2264 105) . The following Q lines describe queries. The i- th of these lines contains four space separated integers ai, bi, ci, di. These represent the i- th query: is it possible to create T[ ci. . di] from S[ ai. . bi] by applying the above transitions finite amount of times? Here, U[ x. . y] is a substring of U that begins at index x ( indexed from 1) and ends at index y. In particular, U[ 1. . | U| ] is the whole string U. It is guaranteed that 1 \u2264 a \u2264 b \u2264 | S| and 1 \u2264 c \u2264 d \u2264 | T| .",
    "output": "Print a string of Q characters, where the i- th character is ' 1' if the answer to the i- th query is positive, and ' 0' otherwise.",
    "note": "In the first query we can achieve the result, for instance, by using transitions . The third query asks for changing AAB to A \u2014 but in this case we are not able to get rid of the character ' B' .",
    "topics": [
      "constructive algorithms",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Perfect Security",
    "url": "https://codeforces.com/problemset/problem/923/C",
    "history": "Alice has a very important message M consisting of some non- negative integers that she wants to keep secret from Eve. Alice knows that the only theoretically secure cipher is one- time pad. Alice generates a random key K of the length equal to the message' s length. Alice computes the bitwise xor of each element of the message and the key ( , where denotes the bitwise XOR operation) and stores this encrypted message A. Alice is smart. Be like Alice. For example, Alice may have wanted to store a message M = ( 0, 15, 9, 18) . She generated a key K = ( 16, 7, 6, 3) . The encrypted message is thus A = ( 16, 8, 15, 17) . Alice realised that she cannot store the key with the encrypted message. Alice sent her key K to Bob and deleted her own copy. Alice is smart. Really, be like Alice. Bob realised that the encrypted message is only secure as long as the key is secret. Bob thus randomly permuted the key before storing it. Bob thinks that this way, even if Eve gets both the encrypted message and the key, she will not be able to read the message. Bob is not smart. Don' t be like Bob. In the above example, Bob may have, for instance, selected a permutation ( 3, 4, 1, 2) and stored the permuted key P = ( 6, 3, 16, 7) . One year has passed and Alice wants to decrypt her message. Only now Bob has realised that this is impossible. As he has permuted the key randomly, the message is lost forever. Did we mention that Bob isn' t smart? Bob wants to salvage at least some information from the message. Since he is not so smart, he asks for your help. You know the encrypted message A and the permuted key P. What is the lexicographically smallest message that could have resulted in the given encrypted text? More precisely, for given A and P, find the lexicographically smallest message O, for which there exists a permutation \u03c0 such that for every i. Note that the sequence S is lexicographically smaller than the sequence T, if there is an index i such that Si < Ti and for all j < i the condition Sj = Tj holds.",
    "input": "The first line contains a single integer N ( 1 \u2264 N \u2264 300000) , the length of the message. The second line contains N integers A1, A2, . . . , AN ( 0 \u2264 Ai < 230) representing the encrypted message. The third line contains N integers P1, P2, . . . , PN ( 0 \u2264 Pi < 230) representing the permuted encryption key.",
    "output": "Output a single line with N integers, the lexicographically smallest possible message O. Note that all its elements should be non- negative.",
    "note": "In the first case, the solution is ( 10, 3, 28) , since , and . Other possible permutations of key yield messages ( 25, 6, 10) , ( 25, 3, 15) , ( 10, 21, 10) , ( 15, 21, 15) and ( 15, 6, 28) , which are all lexicographically larger than the solution.",
    "topics": [
      "data structures",
      "greedy",
      "strings",
      "trees"
    ]
  },
  {
    "title": "Radio Station",
    "url": "https://codeforces.com/problemset/problem/918/B",
    "history": "As the guys fried the radio station facilities, the school principal gave them tasks as a punishment. Dustin' s task was to add comments to nginx configuration for school' s website. The school has n servers. Each server has a name and an ip ( names aren' t necessarily unique, but ips are) . Dustin knows the ip and name of each server. For simplicity, we' ll assume that an nginx command is of form \" command ip; \" where command is a string consisting of English lowercase letter only, and ip is the ip of one of school servers. Each ip is of form \" a. b. c. d\" where a, b, c and d are non- negative integers less than or equal to 255 ( with no leading zeros) . The nginx configuration file Dustin has to add comments to has m commands. Nobody ever memorizes the ips of servers, so to understand the configuration better, Dustin has to comment the name of server that the ip belongs to at the end of each line ( after each command) . More formally, if a line is \" command ip; \" Dustin has to replace it with \" command ip; # name\" where name is the name of the server with ip equal to ip. Dustin doesn' t know anything about nginx, so he panicked again and his friends asked you to do his task for him.",
    "input": "The first line of input contains two integers n and m ( 1 \u2264 n, m \u2264 1000) . The next n lines contain the names and ips of the servers. Each line contains a string name, name of the server and a string ip, ip of the server, separated by space ( 1 \u2264 | name| \u2264 10, name only consists of English lowercase letters) . It is guaranteed that all ip are distinct. The next m lines contain the commands in the configuration file. Each line is of form \" command ip; \" ( 1 \u2264 | command| \u2264 10, command only consists of English lowercase letters) . It is guaranteed that ip belongs to one of the n school servers.",
    "output": "Print m lines, the commands in the configuration file after Dustin did his task.",
    "note": "",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Upside Down",
    "url": "https://codeforces.com/problemset/problem/917/E",
    "history": "As we all know, Eleven has special abilities. Thus, Hopper convinced her to close the gate to the Upside Down World with her mind. Upside down monsters like to move between the worlds, so they are going to attack Hopper and Eleven in order to make them stop. The monsters live in the vines. The vines form a tree with n vertices, numbered from 1 through n. There' s a lowercase English letter written in each tunnel ( edge) . Upside down is a magical world. There are m types of monsters in upside down, numbered from 1 through m. Each type of monster has a special word that gives them powers. The special word of type i is si. There are q monsters in upside down. Each one is at a junction ( vertex) and is going to some other junction. If monster of type k goes from junction i to junction j, the power it gains is the number of times it sees its special world ( sk) consecutively in the tunnels. More formally: If f( i, j) is the string we get when we concatenate the letters written in the tunnels on the shortest path from i to j, then the power the monster gains is the number of occurrences of sk in f( i, j) . Hopper and Eleven want to get prepared, so for each monster, they want to know the power the monster gains after moving.",
    "input": "The first line of input contains three integers, n, m and q ( 2 \u2264 n \u2264 105, 1 \u2264 m, q \u2264 105) . The next n - 1 lines contain the tunnels ( edges) . Each line contains two integers v and u ( 1 \u2264 v, u \u2264 n, v = \u0338 u) and a lowercase English letter c, meaning there' s a tunnel connecting junctions v and u written c in it. It is guaranteed that the given graph is a tree. The next m lines contain the special words. i- th line of them contains a single string si ( 1 \u2264 | si| \u2264 105) , consisting of lowercase English letters. It is guaranteed that | s1| + | s2| + . . . + | sm| \u2264 105) . The next q lines contain the monsters. Each line contains three integers i, j and k ( 1 \u2264 i, j \u2264 n, i = \u0338 j, 1 \u2264 k \u2264 m) , meaning a monster of type k is going from junction number i to junction number j.",
    "output": "Print q lines. i- th line should contain a single integer, the power the i- th monster gains after moving.",
    "note": "",
    "topics": [
      "data structures",
      "string suffix structures",
      "strings",
      "trees"
    ]
  },
  {
    "title": "Substrings in a String",
    "url": "https://codeforces.com/problemset/problem/914/F",
    "history": "Given a string s, process q queries, each having one of the following forms: 1 i c \u2014 Change the i- th character in the string to c. 2 l r y \u2014 Consider the substring of s starting at position l and ending at position r. Output the number of times y occurs as a substring in it.",
    "input": "The first line of the input contains the string s ( 1 \u2264 | s| \u2264 105) of lowercase English letters. The second line contains an integer q ( 1 \u2264 q \u2264 105) \u2014 the number of queries to process. The next q lines describe the queries and may have one of the following forms: 1 i c ( 1 \u2264 i \u2264 | s| ) 2 l r y ( 1 \u2264 l \u2264 r \u2264 | s| ) c is a lowercase English letter and y is a non- empty string consisting of only lowercase English letters. The sum of | y| over all queries of second type is at most 105. It is guaranteed that there is at least one query of second type. All strings are 1- indexed. | s| is the length of the string s.",
    "output": "For each query of type 2, output the required answer in a separate line.",
    "note": "Consider the first sample case. Initially, the string aba occurs 3 times in the range [ 1, 7] . Note that two occurrences may overlap. After the update, the string becomes ababcbaba and now aba occurs only once in the range [ 1, 7] .",
    "topics": [
      "bitmasks",
      "brute force",
      "data structures",
      "string suffix structures",
      "strings"
    ]
  },
  {
    "title": "Reverses",
    "url": "https://codeforces.com/problemset/problem/906/E",
    "history": "Hurricane came to Berland and to suburbs Stringsvill. You are going to it to check if it' s all right with you favorite string. Hurrinace broke it a bit by reversing some of its non- intersecting substrings. You have a photo of this string before hurricane and you want to restore it to original state using reversing minimum possible number of its substrings and find out which substrings you should reverse. You are given a string s \u2014 original state of your string and string t \u2014 state of the string after hurricane. You should select k non- intersecting substrings of t in such a way that after reverse of these substrings string will be equal s and k is minimum possible.",
    "input": "First line of input contains string s and second line contains string t. Both strings have same length and consist of lowercase English letters. 1 \u2264 | s| = | t| \u2264 5\u00b7105",
    "output": "In first line print k \u2014 minimum number of substrings you should reverse. Next output k lines. Each line should contain two integers li, ri meaning that you should reverse substring from symbol number li to symbol ri ( strings are 1- indexed) . These substrings shouldn' t intersect. If there are multiple answers print any. If it' s impossible to restore string output - 1.",
    "note": "",
    "topics": [
      "dp",
      "string suffix structures",
      "strings"
    ]
  },
  {
    "title": "Shockers",
    "url": "https://codeforces.com/problemset/problem/906/A",
    "history": "Valentin participates in a show called \" Shockers\" . The rules are quite easy: jury selects one letter which Valentin doesn' t know. He should make a small speech, but every time he pronounces a word that contains the selected letter, he receives an electric shock. He can make guesses which letter is selected, but for each incorrect guess he receives an electric shock too. The show ends when Valentin guesses the selected letter correctly. Valentin can' t keep in mind everything, so he could guess the selected letter much later than it can be uniquely determined and get excessive electric shocks. Excessive electric shocks are those which Valentin got after the moment the selected letter can be uniquely determined. You should find out the number of excessive electric shocks.",
    "input": "The first line contains a single integer n ( 1 \u2264 n \u2264 105) \u2014 the number of actions Valentin did. The next n lines contain descriptions of his actions, each line contains description of one action. Each action can be of one of three types: Valentin pronounced some word and didn' t get an electric shock. This action is described by the string \" . w\" ( without quotes) , in which \" . \" is a dot ( ASCII- code 46) , and w is the word that Valentin said. Valentin pronounced some word and got an electric shock. This action is described by the string \" ! w\" ( without quotes) , in which \" ! \" is an exclamation mark ( ASCII- code 33) , and w is the word that Valentin said. Valentin made a guess about the selected letter. This action is described by the string \" ? s\" ( without quotes) , in which \" ? \" is a question mark ( ASCII- code 63) , and s is the guess \u2014 a lowercase English letter. All words consist only of lowercase English letters. The total length of all words does not exceed 105. It is guaranteed that last action is a guess about the selected letter. Also, it is guaranteed that Valentin didn' t make correct guesses about the selected letter before the last action. Moreover, it' s guaranteed that if Valentin got an electric shock after pronouncing some word, then it contains the selected letter; and also if Valentin didn' t get an electric shock after pronouncing some word, then it does not contain the selected letter.",
    "output": "Output a single integer \u2014 the number of electric shocks that Valentin could have avoided if he had told the selected letter just after it became uniquely determined.",
    "note": "In the first test case after the first action it becomes clear that the selected letter is one of the following: a, b, c. After the second action we can note that the selected letter is not a. Valentin tells word \" b\" and doesn' t get a shock. After that it is clear that the selected letter is c, but Valentin pronounces the word cd and gets an excessive electric shock. In the second test case after the first two electric shocks we understand that the selected letter is e or o. Valentin tries some words consisting of these letters and after the second word it' s clear that the selected letter is e, but Valentin makes 3 more actions before he makes a correct hypothesis. In the third example the selected letter can be uniquely determined only when Valentin guesses it, so he didn' t get excessive electric shocks.",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Swapping Characters",
    "url": "https://codeforces.com/problemset/problem/903/E",
    "history": "We had a string s consisting of n lowercase Latin letters. We made k copies of this string, thus obtaining k identical strings s1, s2, . . . , sk. After that, in each of these strings we swapped exactly two characters ( the characters we swapped could be identical, but they had different indices in the string) . You are given k strings s1, s2, . . . , sk, and you have to restore any string s so that it is possible to obtain these strings by performing aforementioned operations. Note that the total length of the strings you are given doesn' t exceed 5000 ( that is, k\u00b7n \u2264 5000) .",
    "input": "The first line contains two integers k and n ( 1 \u2264 k \u2264 2500, 2 \u2264 n \u2264 5000, k \u00b7 n \u2264 5000) \u2014 the number of strings we obtained, and the length of each of these strings. Next k lines contain the strings s1, s2, . . . , sk, each consisting of exactly n lowercase Latin letters.",
    "output": "Print any suitable string s, or - 1 if such string doesn' t exist.",
    "note": "In the first example s1 is obtained by swapping the second and the fourth character in acab, s2 is obtained by swapping the first and the second character, and to get s3, we swap the third and the fourth character. In the second example s1 is obtained by swapping the third and the fourth character in kbub, s2 \u2014 by swapping the second and the fourth, and s3 \u2014 by swapping the first and the third. In the third example it' s impossible to obtain given strings by aforementioned operations.",
    "topics": [
      "brute force",
      "hashing",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Maximum Questions",
    "url": "https://codeforces.com/problemset/problem/900/E",
    "history": "Vasya wrote down two strings s of length n and t of length m consisting of small English letters ' a' and ' b' . What is more, he knows that string t has a form \" abab. . . \" , namely there are letters ' a' on odd positions and letters ' b' on even positions. Suddenly in the morning, Vasya found that somebody spoiled his string. Some letters of the string s were replaced by character ' ? ' . Let' s call a sequence of positions i, i + 1, . . . , i + m - 1 as occurrence of string t in s, if 1 \u2264 i \u2264 n - m + 1 and t1 = si, t2 = si + 1, . . . , tm = si + m - 1. The boy defines the beauty of the string s as maximum number of disjoint occurrences of string t in s. Vasya can replace some letters ' ? ' with ' a' or ' b' ( letters on different positions can be replaced with different letter) . Vasya wants to make some replacements in such a way that beauty of string s is maximum possible. From all such options, he wants to choose one with the minimum number of replacements. Find the number of replacements he should make.",
    "input": "The first line contains a single integer n ( 1 \u2264 n \u2264 105) \u2014 the length of s. The second line contains the string s of length n. It contains small English letters ' a' , ' b' and characters ' ? ' only. The third line contains a single integer m ( 1 \u2264 m \u2264 105) \u2014 the length of t. The string t contains letters ' a' on odd positions and ' b' on even positions.",
    "output": "Print the only integer \u2014 the minimum number of replacements Vasya has to perform to make the beauty of string s the maximum possible.",
    "note": "In the first sample string t has a form ' a' . The only optimal option is to replace all characters ' ? ' by ' a' . In the second sample using two replacements we can make string equal to \" aba? aba? ? \" . It is impossible to get more than two occurrences.",
    "topics": [
      "data structures",
      "dp",
      "strings"
    ]
  },
  {
    "title": "Letters Removing",
    "url": "https://codeforces.com/problemset/problem/899/F",
    "history": "Petya has a string of length n consisting of small and large English letters and digits. He performs m operations. Each operation is described with two integers l and r and a character c: Petya removes from the string all characters c on positions between l and r, inclusive. It' s obvious that the length of the string remains the same or decreases after each operation. Find how the string will look like after Petya performs all m operations.",
    "input": "The first string contains two integers n and m ( 1 \u2264 n, m \u2264 2\u00b7105) \u2014 the length of the string and the number of operations. The second line contains the string of length n, consisting of small and large English letters and digits. Positions in the string are enumerated from 1. Each of the next m lines contains two integers l and r ( 1 \u2264 l \u2264 r) , followed by a character c, which is a small or large English letter or a digit. This line describes one operation. It is guaranteed that r doesn' t exceed the length of the string s before current operation.",
    "output": "Print the string Petya will obtain after performing all m operations. If the strings becomes empty after all operations, print an empty line.",
    "note": "In the first example during the first operation both letters ' a' are removed, so the string becomes \" bc\" . During the second operation the letter ' c' ( on the second position) is removed, and the string becomes \" b\" . In the second example during the first operation Petya removes ' 0' from the second position. After that the string becomes \" Az\" . During the second operations the string doesn' t change.",
    "topics": [
      "data structures",
      "strings"
    ]
  },
  {
    "title": "Phone Numbers",
    "url": "https://codeforces.com/problemset/problem/898/C",
    "history": "Vasya has several phone books, in which he recorded the telephone numbers of his friends. Each of his friends can have one or several phone numbers. Vasya decided to organize information about the phone numbers of friends. You will be given n strings \u2014 all entries from Vasya' s phone books. Each entry starts with a friend' s name. Then follows the number of phone numbers in the current entry, and then the phone numbers themselves. It is possible that several identical phones are recorded in the same record. Vasya also believes that if the phone number a is a suffix of the phone number b ( that is, the number b ends up with a) , and both numbers are written by Vasya as the phone numbers of the same person, then a is recorded without the city code and it should not be taken into account. The task is to print organized information about the phone numbers of Vasya' s friends. It is possible that two different people have the same number. If one person has two numbers x and y, and x is a suffix of y ( that is, y ends in x) , then you shouldn' t print number x. If the number of a friend in the Vasya' s phone books is recorded several times in the same format, it is necessary to take it into account exactly once. Read the examples to understand statement and format of the output better.",
    "input": "First line contains the integer n ( 1 \u2264 n \u2264 20) \u2014 number of entries in Vasya' s phone books. The following n lines are followed by descriptions of the records in the format described in statement. Names of Vasya' s friends are non- empty strings whose length does not exceed 10. They consists only of lowercase English letters. Number of phone numbers in one entry is not less than 1 is not more than 10. The telephone numbers consist of digits only. If you represent a phone number as a string, then its length will be in range from 1 to 10. Phone numbers can contain leading zeros.",
    "output": "Print out the ordered information about the phone numbers of Vasya' s friends. First output m \u2014 number of friends that are found in Vasya' s phone books. The following m lines must contain entries in the following format \" name number_ of_ phone_ numbers phone_ numbers\" . Phone numbers should be separated by a space. Each record must contain all the phone numbers of current friend. Entries can be displayed in arbitrary order, phone numbers for one record can also be printed in arbitrary order.",
    "note": "",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "String Mark",
    "url": "https://codeforces.com/problemset/problem/895/D",
    "history": "At the Byteland State University marks are strings of the same length. Mark x is considered better than y if string y is lexicographically smaller than x. Recently at the BSU was an important test work on which Vasya recived the mark a. It is very hard for the teacher to remember the exact mark of every student, but he knows the mark b, such that every student recieved mark strictly smaller than b. Vasya isn' t satisfied with his mark so he decided to improve it. He can swap characters in the string corresponding to his mark as many times as he like. Now he want to know only the number of different ways to improve his mark so that his teacher didn' t notice something suspicious. More formally: you are given two strings a, b of the same length and you need to figure out the number of different strings c such that: 1) c can be obtained from a by swapping some characters, in other words c is a permutation of a. 2) String a is lexicographically smaller than c. 3) String c is lexicographically smaller than b. For two strings x and y of the same length it is true that x is lexicographically smaller than y if there exists such i, that x1 = y1, x2 = y2, . . . , xi - 1 = yi - 1, xi < yi. Since the answer can be very large, you need to find answer modulo 109 + 7.",
    "input": "First line contains string a, second line contains string b. Strings a, b consist of lowercase English letters. Their lengths are equal and don' t exceed 106. It is guaranteed that a is lexicographically smaller than b.",
    "output": "Print one integer \u2014 the number of different strings satisfying the condition of the problem modulo 109 + 7.",
    "note": "In first sample from string abc can be obtained strings acb, bac, bca, cab, cba, all of them are larger than abc, but smaller than ddd. So the answer is 5. In second sample any string obtained from abcdef is larger than abcdeg. So the answer is 0.",
    "topics": [
      "combinatorics",
      "math",
      "strings"
    ]
  },
  {
    "title": "Palindromic Cut",
    "url": "https://codeforces.com/problemset/problem/883/H",
    "history": "Kolya has a string s of length n consisting of lowercase and uppercase Latin letters and digits. He wants to rearrange the symbols in s and cut it into the minimum number of parts so that each part is a palindrome and all parts have the same lengths. A palindrome is a string which reads the same backward as forward, such as madam or racecar. Your task is to help Kolya and determine the minimum number of palindromes of equal lengths to cut s into, if it is allowed to rearrange letters in s before cuttings.",
    "input": "The first line contains an integer n ( 1 \u2264 n \u2264 4\u00b7105) \u2014 the length of string s. The second line contains a string s of length n consisting of lowercase and uppercase Latin letters and digits.",
    "output": "Print to the first line an integer k \u2014 minimum number of palindromes into which you can cut a given string. Print to the second line k strings \u2014 the palindromes themselves. Separate them by a space. You are allowed to print palindromes in arbitrary order. All of them should have the same length.",
    "note": "",
    "topics": [
      "brute force",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Field of Wonders",
    "url": "https://codeforces.com/problemset/problem/883/E",
    "history": "Polycarpus takes part in the \" Field of Wonders\" TV show. The participants of the show have to guess a hidden word as fast as possible. Initially all the letters of the word are hidden. The game consists of several turns. At each turn the participant tells a letter and the TV show host responds if there is such letter in the word or not. If there is such letter then the host reveals all such letters. For example, if the hidden word is \" abacaba\" and the player tells the letter \" a\" , the host will reveal letters at all positions, occupied by \" a\" : 1, 3, 5 and 7 ( positions are numbered from left to right starting from 1) . Polycarpus knows m words of exactly the same length as the hidden word. The hidden word is also known to him and appears as one of these m words. At current moment a number of turns have already been made and some letters ( possibly zero) of the hidden word are already revealed. Previously Polycarp has told exactly the letters which are currently revealed. It is Polycarpus' turn. He wants to tell a letter in such a way, that the TV show host will assuredly reveal at least one more letter. Polycarpus cannot tell the letters, which are already revealed. Your task is to help Polycarpus and find out the number of letters he can tell so that the show host will assuredly reveal at least one of the remaining letters.",
    "input": "The first line contains one integer n ( 1 \u2264 n \u2264 50) \u2014 the length of the hidden word. The following line describes already revealed letters. It contains the string of length n, which consists of lowercase Latin letters and symbols \" * \" . If there is a letter at some position, then this letter was already revealed. If the position contains symbol \" * \" , then the letter at this position has not been revealed yet. It is guaranteed, that at least one letter is still closed. The third line contains an integer m ( 1 \u2264 m \u2264 1000) \u2014 the number of words of length n, which Polycarpus knows. The following m lines contain the words themselves \u2014 n- letter strings of lowercase Latin letters. All words are distinct. It is guaranteed that the hidden word appears as one of the given m words. Before the current move Polycarp has told exactly the letters which are currently revealed.",
    "output": "Output the single integer \u2014 the number of letters Polycarpus can tell so that the TV show host definitely reveals at least one more letter. It is possible that this number is zero.",
    "note": "In the first example Polycarpus can tell letters \" b\" and \" c\" , which assuredly will be revealed. The second example contains no letters which can be told as it is not clear, which of the letters \" v\" or \" s\" is located at the third position of the hidden word. In the third example Polycarpus exactly knows that the hidden word is \" aba\" , because in case it was \" aaa\" , then the second letter \" a\" would have already been revealed in one of previous turns.",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Alex and broken contest",
    "url": "https://codeforces.com/problemset/problem/877/A",
    "history": "One day Alex was creating a contest about his friends, but accidentally deleted it. Fortunately, all the problems were saved, but now he needs to find them among other problems. But there are too many problems, to do it manually. Alex asks you to write a program, which will determine if a problem is from this contest by its name. It is known, that problem is from this contest if and only if its name contains one of Alex' s friends' name exactly once. His friends' names are \" Danil\" , \" Olya\" , \" Slava\" , \" Ann\" and \" Nikita\" . Names are case sensitive.",
    "input": "The only line contains string from lowercase and uppercase letters and \" _ \" symbols of length, not more than 100 \u2014 the name of the problem.",
    "output": "Print \" YES\" , if problem is from this contest, and \" NO\" otherwise.",
    "note": "",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Forbidden Indices",
    "url": "https://codeforces.com/problemset/problem/873/F",
    "history": "You are given a string s consisting of n lowercase Latin letters. Some indices in this string are marked as forbidden. You want to find a string a such that the value of | a| \u00b7f( a) is maximum possible, where f( a) is the number of occurences of a in s such that these occurences end in non- forbidden indices. So, for example, if s is aaaa, a is aa and index 3 is forbidden, then f( a) = 2 because there are three occurences of a in s ( starting in indices 1, 2 and 3) , but one of them ( starting in index 2) ends in a forbidden index. Calculate the maximum possible value of | a| \u00b7f( a) you can get.",
    "input": "The first line contains an integer number n ( 1 \u2264 n \u2264 200000) \u2014 the length of s. The second line contains a string s, consisting of n lowercase Latin letters. The third line contains a string t, consisting of n characters 0 and 1. If i- th character in t is 1, then i is a forbidden index ( otherwise i is not forbidden) .",
    "output": "Print the maximum possible value of | a| \u00b7f( a) .",
    "note": "",
    "topics": [
      "dsu",
      "string suffix structures",
      "strings"
    ]
  },
  {
    "title": "Huge Strings",
    "url": "https://codeforces.com/problemset/problem/868/D",
    "history": "You are given n strings s1, s2, . . . , sn consisting of characters 0 and 1. m operations are performed, on each of them you concatenate two existing strings into a new one. On the i- th operation the concatenation saisbi is saved into a new string sn + i ( the operations are numbered starting from 1) . After each operation you need to find the maximum positive integer k such that all possible strings consisting of 0 and 1 of length k ( there are 2k such strings) are substrings of the new string. If there is no such k, print 0.",
    "input": "The first line contains single integer n ( 1 \u2264 n \u2264 100) \u2014 the number of strings. The next n lines contain strings s1, s2, . . . , sn ( 1 \u2264 | si| \u2264 100) , one per line. The total length of strings is not greater than 100. The next line contains single integer m ( 1 \u2264 m \u2264 100) \u2014 the number of operations. m lines follow, each of them contains two integers ai abd bi ( 1 \u2264 ai, bi \u2264 n + i - 1) \u2014 the number of strings that are concatenated to form sn + i.",
    "output": "Print m lines, each should contain one integer \u2014 the answer to the question after the corresponding operation.",
    "note": "On the first operation, a new string \" 0110\" is created. For k = 1 the two possible binary strings of length k are \" 0\" and \" 1\" , they are substrings of the new string. For k = 2 and greater there exist strings of length k that do not appear in this string ( for k = 2 such string is \" 00\" ) . So the answer is 1. On the second operation the string \" 01100\" is created. Now all strings of length k = 2 are present. On the third operation the string \" 1111111111\" is created. There is no zero, so the answer is 0.",
    "topics": [
      "bitmasks",
      "brute force",
      "dp",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Bark to Unlock",
    "url": "https://codeforces.com/problemset/problem/868/A",
    "history": "As technologies develop, manufacturers are making the process of unlocking a phone as user- friendly as possible. To unlock its new phone, Arkady' s pet dog Mu- mu has to bark the password once. The phone represents a password as a string of two lowercase English letters. Mu- mu' s enemy Kashtanka wants to unlock Mu- mu' s phone to steal some sensible information, but it can only bark n distinct words, each of which can be represented as a string of two lowercase English letters. Kashtanka wants to bark several words ( not necessarily distinct) one after another to pronounce a string containing the password as a substring. Tell if it' s possible to unlock the phone in this way, or not.",
    "input": "The first line contains two lowercase English letters \u2014 the password on the phone. The second line contains single integer n ( 1 \u2264 n \u2264 100) \u2014 the number of words Kashtanka knows. The next n lines contain two lowercase English letters each, representing the words Kashtanka knows. The words are guaranteed to be distinct.",
    "output": "Print \" YES\" if Kashtanka can bark several words in a line forming a string containing the password, and \" NO\" otherwise. You can print each letter in arbitrary case ( upper or lower) .",
    "note": "In the first example the password is \" ya\" , and Kashtanka can bark \" oy\" and then \" ah\" , and then \" ha\" to form the string \" oyahha\" which contains the password. So, the answer is \" YES\" . In the second example Kashtanka can' t produce a string containing password as a substring. Note that it can bark \" ht\" and then \" tp\" producing \" http\" , but it doesn' t contain the password \" hp\" as a substring. In the third example the string \" hahahaha\" contains \" ah\" as a substring.",
    "topics": [
      "brute force",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Polycarp and Letters",
    "url": "https://codeforces.com/problemset/problem/864/B",
    "history": "Polycarp loves lowercase letters and dislikes uppercase ones. Once he got a string s consisting only of lowercase and uppercase Latin letters. Let A be a set of positions in the string. Let' s call it pretty if following conditions are met: letters on positions from A in the string are all distinct and lowercase; there are no uppercase letters in the string which are situated between positions from A ( i. e. there is no such j that s[ j] is an uppercase letter, and a1 < j < a2 for some a1 and a2 from A) . Write a program that will determine the maximum number of elements in a pretty set of positions.",
    "input": "The first line contains a single integer n ( 1 \u2264 n \u2264 200) \u2014 length of string s. The second line contains a string s consisting of lowercase and uppercase Latin letters.",
    "output": "Print maximum number of elements in pretty set of positions for string s.",
    "note": "In the first example the desired positions might be 6 and 8 or 7 and 8. Positions 6 and 7 contain letters ' a' , position 8 contains letter ' b' . The pair of positions 1 and 8 is not suitable because there is an uppercase letter ' B' between these position. In the second example desired positions can be 7, 8 and 11. There are other ways to choose pretty set consisting of three elements. In the third example the given string s does not contain any lowercase letters, so the answer is 0.",
    "topics": [
      "brute force",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Mahmoud and Ehab and the final stage",
    "url": "https://codeforces.com/problemset/problem/862/F",
    "history": "Mahmoud and Ehab solved Dr. Evil' s questions so he gave them the password of the door of the evil land. When they tried to open the door using it, the door gave them a final question to solve before they leave ( yes, the door is digital, Dr. Evil is modern) . If they don' t solve it, all the work will be useless and they won' t leave the evil land forever. Will you help them? Mahmoud and Ehab are given n strings s1, s2, . . . , sn numbered from 1 to n and q queries, Each query has one of the following forms: 1 a b ( 1 \u2264 a \u2264 b \u2264 n) , For all the intervals [ l; r] where ( a \u2264 l \u2264 r \u2264 b) find the maximum value of this expression: ( r - l + 1) * LCP( sl, sl + 1, . . . , sr - 1, sr) where LCP( str1, str2, str3, . . . ) is the length of the longest common prefix of the strings str1, str2, str3, . . . . 2 x y ( 1 \u2264 x \u2264 n) where y is a string, consisting of lowercase English letters. Change the string at position x to y.",
    "input": "The first line of input contains 2 integers n and q ( 1 \u2264 n \u2264 105, 1 \u2264 q \u2264 105) \u2013 The number of strings and the number of queries, respectively. The second line contains n strings stri consisting of lowercase English letters. The next q lines describe the queries and may have one of the 2 forms: 1 a b ( 1 \u2264 a \u2264 b \u2264 n) . 2 x y ( 1 \u2264 x \u2264 n) , where y is a string consisting of lowercase English letters. the total length of all strings in input won' t exceed 105",
    "output": "For each query of first type output its answer in a new line.",
    "note": "",
    "topics": [
      "data structures",
      "strings"
    ]
  },
  {
    "title": "Similar Words",
    "url": "https://codeforces.com/problemset/problem/856/B",
    "history": "Let us call a non- empty sequence of lowercase English letters a word. Prefix of a word x is a word y that can be obtained from x by removing zero or more last letters of x. Let us call two words similar, if one of them can be obtained from the other by removing its first letter. You are given a set S of words. Find the maximal possible size of set of non- empty words X such that they satisfy the following: each word of X is prefix of some word from S; X has no similar words.",
    "input": "Input data contains multiple test cases. The first line of the input data contains an integer t \u2014 the number of test cases. The descriptions of test cases follow. The first line of each description contains an integer n \u2014 the number of words in the set S ( 1 \u2264 n \u2264 106) . Each of the following n lines contains one non- empty word \u2014 elements of S. All words in S are different. It is guaranteed that the total length of all words in one input data doesn' t exceed 106.",
    "output": "For each test case print one line that contains one integer m \u2014 the maximal number of words that X can contain.",
    "note": "",
    "topics": [
      "dp",
      "hashing",
      "strings",
      "trees"
    ]
  },
  {
    "title": "Tom Riddle's Diary",
    "url": "https://codeforces.com/problemset/problem/855/A",
    "history": "Harry Potter is on a mission to destroy You- Know- Who' s Horcruxes. The first Horcrux that he encountered in the Chamber of Secrets is Tom Riddle' s diary. The diary was with Ginny and it forced her to open the Chamber of Secrets. Harry wants to know the different people who had ever possessed the diary to make sure they are not under its influence. He has names of n people who possessed the diary in order. You need to tell, for each person, if he/ she possessed the diary at some point before or not. Formally, for a name si in the i- th line, output \" YES\" ( without quotes) if there exists an index j such that si = sj and j < i, otherwise, output \" NO\" ( without quotes) .",
    "input": "First line of input contains an integer n ( 1 \u2264 n \u2264 100) \u2014 the number of names in the list. Next n lines each contain a string si, consisting of lowercase English letters. The length of each string is between 1 and 100.",
    "output": "Output n lines each containing either \" YES\" or \" NO\" ( without quotes) , depending on whether this string was already present in the stream or not. You can print each letter in any case ( upper or lower) .",
    "note": "In test case 1, for i = 5 there exists j = 3 such that si = sj and j < i, which means that answer for i = 5 is \" YES\" .",
    "topics": [
      "brute force",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Diversity",
    "url": "https://codeforces.com/problemset/problem/844/A",
    "history": "Calculate the minimum number of characters you need to change in the string s, so that it contains at least k different letters, or print that it is impossible. String s consists only of lowercase Latin letters, and it is allowed to change characters only to lowercase Latin letters too.",
    "input": "First line of input contains string s, consisting only of lowercase Latin letters ( 1 \u2264 | s| \u2264 1000, | s| denotes the length of s) . Second line of input contains integer k ( 1 \u2264 k \u2264 26) .",
    "output": "Print single line with a minimum number of necessary changes, or the word \u00abimpossible\u00bb ( without quotes) if it is impossible.",
    "note": "In the first test case string contains 6 different letters, so we don' t need to change anything. In the second test case string contains 4 different letters: ' a' , ' h' , ' o' , ' y' . To get 5 different letters it is necessary to change one occurrence of ' o' to some letter, which doesn' t occur in the string, for example, ' b' . In the third test case, it is impossible to make 7 different letters because the length of the string is 6.",
    "topics": [
      "greedy",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Palindromic characteristics",
    "url": "https://codeforces.com/problemset/problem/835/D",
    "history": "Palindromic characteristics of string s with length | s| is a sequence of | s| integers, where k- th number is the total number of non- empty substrings of s which are k- palindromes. A string is 1- palindrome if and only if it reads the same backward as forward. A string is k- palindrome ( k > 1) if and only if: Its left half equals to its right half. Its left and right halfs are non- empty ( k - 1) - palindromes. The left half of string t is its prefix of length \u230a| t| / 2\u230b, and right half \u2014 the suffix of the same length. \u230a| t| / 2\u230b denotes the length of string t divided by 2, rounded down. Note that each substring is counted as many times as it appears in the string. For example, in the string \" aaa\" the substring \" a\" appears 3 times.",
    "input": "The first line contains the string s ( 1 \u2264 | s| \u2264 5000) consisting of lowercase English letters.",
    "output": "Print | s| integers \u2014 palindromic characteristics of string s.",
    "note": "In the first example 1- palindromes are substring \u00aba\u00bb, \u00abb\u00bb, \u00abb\u00bb, \u00aba\u00bb, \u00abbb\u00bb, \u00ababba\u00bb, the substring \u00abbb\u00bb is 2- palindrome. There are no 3- and 4- palindromes here.",
    "topics": [
      "brute force",
      "dp",
      "hashing",
      "strings"
    ]
  },
  {
    "title": "Petya and Exam",
    "url": "https://codeforces.com/problemset/problem/832/B",
    "history": "It' s hard times now. Today Petya needs to score 100 points on Informatics exam. The tasks seem easy to Petya, but he thinks he lacks time to finish them all, so he asks you to help with one. . There is a glob pattern in the statements ( a string consisting of lowercase English letters, characters \" ? \" and \" * \" ) . It is known that character \" * \" occurs no more than once in the pattern. Also, n query strings are given, it is required to determine for each of them if the pattern matches it or not. Everything seemed easy to Petya, but then he discovered that the special pattern characters differ from their usual meaning. A pattern matches a string if it is possible to replace each character \" ? \" with one good lowercase English letter, and the character \" * \" ( if there is one) with any, including empty, string of bad lowercase English letters, so that the resulting string is the same as the given string. The good letters are given to Petya. All the others are bad.",
    "input": "The first line contains a string with length from 1 to 26 consisting of distinct lowercase English letters. These letters are good letters, all the others are bad. The second line contains the pattern \u2014 a string s of lowercase English letters, characters \" ? \" and \" * \" ( 1 \u2264 | s| \u2264 105) . It is guaranteed that character \" * \" occurs in s no more than once. The third line contains integer n ( 1 \u2264 n \u2264 105) \u2014 the number of query strings. n lines follow, each of them contains single non- empty string consisting of lowercase English letters \u2014 a query string. It is guaranteed that the total length of all query strings is not greater than 105.",
    "output": "Print n lines: in the i- th of them print \" YES\" if the pattern matches the i- th query string, and \" NO\" otherwise. You can choose the case ( lower or upper) for each letter arbitrary.",
    "note": "In the first example we can replace \" ? \" with good letters \" a\" and \" b\" , so we can see that the answer for the first query is \" YES\" , and the answer for the second query is \" NO\" , because we can' t match the third letter. Explanation of the second example. The first query: \" NO\" , because character \" * \" can be replaced with a string of bad letters only, but the only way to match the query string is to replace it with the string \" ba\" , in which both letters are good. The second query: \" YES\" , because characters \" ? \" can be replaced with corresponding good letters, and character \" * \" can be replaced with empty string, and the strings will coincide. The third query: \" NO\" , because characters \" ? \" can' t be replaced with bad letters. The fourth query: \" YES\" , because characters \" ? \" can be replaced with good letters \" a\" , and character \" * \" can be replaced with a string of bad letters \" x\" .",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Keyboard Layouts",
    "url": "https://codeforces.com/problemset/problem/831/B",
    "history": "There are two popular keyboard layouts in Berland, they differ only in letters positions. All the other keys are the same. In Berland they use alphabet with 26 letters which coincides with English alphabet. You are given two strings consisting of 26 distinct letters each: all keys of the first and the second layouts in the same order. You are also given some text consisting of small and capital English letters and digits. It is known that it was typed in the first layout, but the writer intended to type it in the second layout. Print the text if the same keys were pressed in the second layout. Since all keys but letters are the same in both layouts, the capitalization of the letters should remain the same, as well as all other characters.",
    "input": "The first line contains a string of length 26 consisting of distinct lowercase English letters. This is the first layout. The second line contains a string of length 26 consisting of distinct lowercase English letters. This is the second layout. The third line contains a non- empty string s consisting of lowercase and uppercase English letters and digits. This is the text typed in the first layout. The length of s does not exceed 1000.",
    "output": "Print the text if the same keys were pressed in the second layout.",
    "note": "",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Rusty String",
    "url": "https://codeforces.com/problemset/problem/827/E",
    "history": "Grigory loves strings. Recently he found a metal strip on a loft. The strip had length n and consisted of letters \" V\" and \" K\" . Unfortunately, rust has eaten some of the letters so that it' s now impossible to understand which letter was written. Grigory couldn' t understand for a long time what these letters remind him of, so he became interested in the following question: if we put a letter \" V\" or \" K\" on each unreadable position, which values can the period of the resulting string be equal to? A period of a string is such an integer d from 1 to the length of the string that if we put the string shifted by d positions to the right on itself, then all overlapping letters coincide. For example, 3 and 5 are periods of \" VKKVK\" .",
    "input": "There are several ( at least one) test cases in the input. The first line contains single integer \u2014 the number of test cases. There is an empty line before each test case. Each test case is described in two lines: the first line contains single integer n ( 1 \u2264 n \u2264 5\u00b7105) \u2014 the length of the string, the second line contains the string of length n, consisting of letters \" V\" , \" K\" and characters \" ? \" . The latter means the letter on its position is unreadable. It is guaranteed that the sum of lengths among all test cases doesn' t exceed 5\u00b7105. For hacks you can only use tests with one test case.",
    "output": "For each test case print two lines. In the first line print the number of possible periods after we replace each unreadable letter with \" V\" or \" K\" . In the next line print all these values in increasing order.",
    "note": "In the first test case from example we can obtain, for example, \" VKKVK\" , which has periods 3 and 5. In the second test case we can obtain \" VVVVVV\" which has all periods from 1 to 6. In the third test case string \" KVKV\" has periods 2 and 4, and string \" KVKK\" has periods 3 and 4.",
    "topics": [
      "fft",
      "math",
      "strings"
    ]
  },
  {
    "title": "DNA Evolution",
    "url": "https://codeforces.com/problemset/problem/827/C",
    "history": "Everyone knows that DNA strands consist of nucleotides. There are four types of nucleotides: \" A\" , \" T\" , \" G\" , \" C\" . A DNA strand is a sequence of nucleotides. Scientists decided to track evolution of a rare species, which DNA strand was string s initially. Evolution of the species is described as a sequence of changes in the DNA. Every change is a change of some nucleotide, for example, the following change can happen in DNA strand \" AAGC\" : the second nucleotide can change to \" T\" so that the resulting DNA strand is \" ATGC\" . Scientists know that some segments of the DNA strand can be affected by some unknown infections. They can represent an infection as a sequence of nucleotides. Scientists are interested if there are any changes caused by some infections. Thus they sometimes want to know the value of impact of some infection to some segment of the DNA. This value is computed as follows: Let the infection be represented as a string e, and let scientists be interested in DNA strand segment starting from position l to position r, inclusive. Prefix of the string eee. . . ( i. e. the string that consists of infinitely many repeats of string e) is written under the string s from position l to position r, inclusive. The value of impact is the number of positions where letter of string s coincided with the letter written under it. Being a developer, Innokenty is interested in bioinformatics also, so the scientists asked him for help. Innokenty is busy preparing VK Cup, so he decided to delegate the problem to the competitors. Help the scientists!",
    "input": "The first line contains the string s ( 1 \u2264 | s| \u2264 105) that describes the initial DNA strand. It consists only of capital English letters \" A\" , \" T\" , \" G\" and \" C\" . The next line contains single integer q ( 1 \u2264 q \u2264 105) \u2014 the number of events. After that, q lines follow, each describes one event. Each of the lines has one of two formats: 1 x c, where x is an integer ( 1 \u2264 x \u2264 | s| ) , and c is a letter \" A\" , \" T\" , \" G\" or \" C\" , which means that there is a change in the DNA: the nucleotide at position x is now c. 2 l r e, where l, r are integers ( 1 \u2264 l \u2264 r \u2264 | s| ) , and e is a string of letters \" A\" , \" T\" , \" G\" and \" C\" ( 1 \u2264 | e| \u2264 10) , which means that scientists are interested in the value of impact of infection e to the segment of DNA strand from position l to position r, inclusive.",
    "output": "For each scientists' query ( second type query) print a single integer in a new line \u2014 the value of impact of the infection on the DNA.",
    "note": "Consider the first example. In the first query of second type all characters coincide, so the answer is 8. In the second query we compare string \" TTTTT. . . \" and the substring \" TGCAT\" . There are two matches. In the third query, after the DNA change, we compare string \" TATAT. . . \" ' with substring \" TGTAT\" . There are 4 matches.",
    "topics": [
      "data structures",
      "strings"
    ]
  },
  {
    "title": "String Reconstruction",
    "url": "https://codeforces.com/problemset/problem/827/A",
    "history": "Ivan had string s consisting of small English letters. However, his friend Julia decided to make fun of him and hid the string s. Ivan preferred making a new string to finding the old one. Ivan knows some information about the string s. Namely, he remembers, that string ti occurs in string s at least ki times or more, he also remembers exactly ki positions where the string ti occurs in string s: these positions are xi, 1, xi, 2, . . . , xi, ki. He remembers n such strings ti. You are to reconstruct lexicographically minimal string s such that it fits all the information Ivan remembers. Strings ti and string s consist of small English letters only.",
    "input": "The first line contains single integer n ( 1 \u2264 n \u2264 105) \u2014 the number of strings Ivan remembers. The next n lines contain information about the strings. The i- th of these lines contains non- empty string ti, then positive integer ki, which equal to the number of times the string ti occurs in string s, and then ki distinct positive integers xi, 1, xi, 2, . . . , xi, ki in increasing order \u2014 positions, in which occurrences of the string ti in the string s start. It is guaranteed that the sum of lengths of strings ti doesn' t exceed 106, 1 \u2264 xi, j \u2264 106, 1 \u2264 ki \u2264 106, and the sum of all ki doesn' t exceed 106. The strings ti can coincide. It is guaranteed that the input data is not self- contradictory, and thus at least one answer always exists.",
    "output": "Print lexicographically minimal string that fits all the information Ivan remembers.",
    "note": "",
    "topics": [
      "data structures",
      "greedy",
      "sortings",
      "strings"
    ]
  },
  {
    "title": "String Compression",
    "url": "https://codeforces.com/problemset/problem/825/F",
    "history": "Ivan wants to write a letter to his friend. The letter is a string s consisting of lowercase Latin letters. Unfortunately, when Ivan started writing the letter, he realised that it is very long and writing the whole letter may take extremely long time. So he wants to write the compressed version of string s instead of the string itself. The compressed version of string s is a sequence of strings c1, s1, c2, s2, . . . , ck, sk, where ci is the decimal representation of number ai ( without any leading zeroes) and si is some string consisting of lowercase Latin letters. If Ivan writes string s1 exactly a1 times, then string s2 exactly a2 times, and so on, the result will be string s. The length of a compressed version is | c1| + | s1| + | c2| + | s2| . . . | ck| + | sk| . Among all compressed versions Ivan wants to choose a version such that its length is minimum possible. Help Ivan to determine minimum possible length.",
    "input": "The only line of input contains one string s consisting of lowercase Latin letters ( 1 \u2264 | s| \u2264 8000) .",
    "output": "Output one integer number \u2014 the minimum possible length of a compressed version of s.",
    "note": "In the first example Ivan will choose this compressed version: c1 is 10, s1 is a. In the second example Ivan will choose this compressed version: c1 is 1, s1 is abcab. In the third example Ivan will choose this compressed version: c1 is 2, s1 is c, c2 is 1, s2 is z, c3 is 4, s3 is ab.",
    "topics": [
      "dp",
      "hashing",
      "string suffix structures",
      "strings"
    ]
  },
  {
    "title": "Crossword solving",
    "url": "https://codeforces.com/problemset/problem/822/B",
    "history": "Erelong Leha was bored by calculating of the greatest common divisor of two factorials. Therefore he decided to solve some crosswords. It' s well known that it is a very interesting occupation though it can be very difficult from time to time. In the course of solving one of the crosswords, Leha had to solve a simple task. You are able to do it too, aren' t you? Leha has two strings s and t. The hacker wants to change the string s at such way, that it can be found in t as a substring. All the changes should be the following: Leha chooses one position in the string s and replaces the symbol in this position with the question mark \" ? \" . The hacker is sure that the question mark in comparison can play the role of an arbitrary symbol. For example, if he gets string s= \" ab? b\" as a result, it will appear in t= \" aabrbb\" as a substring. Guaranteed that the length of the string s doesn' t exceed the length of the string t. Help the hacker to replace in s as few symbols as possible so that the result of the replacements can be found in t as a substring. The symbol \" ? \" should be considered equal to any other symbol.",
    "input": "The first line contains two integers n and m ( 1 \u2264 n \u2264 m \u2264 1000) \u2014 the length of the string s and the length of the string t correspondingly. The second line contains n lowercase English letters \u2014 string s. The third line contains m lowercase English letters \u2014 string t.",
    "output": "In the first line print single integer k \u2014 the minimal number of symbols that need to be replaced. In the second line print k distinct integers denoting the positions of symbols in the string s which need to be replaced. Print the positions in any order. If there are several solutions print any of them. The numbering of the positions begins from one.",
    "note": "",
    "topics": [
      "brute force",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "An impassioned circulation of affection",
    "url": "https://codeforces.com/problemset/problem/814/C",
    "history": "Nadeko' s birthday is approaching! As she decorated the room for the party, a long garland of Dianthus- shaped paper pieces was placed on a prominent part of the wall. Brother Koyomi will like it! Still unsatisfied with the garland, Nadeko decided to polish it again. The garland has n pieces numbered from 1 to n from left to right, and the i- th piece has a colour si, denoted by a lowercase English letter. Nadeko will repaint at most m of the pieces to give each of them an arbitrary new colour ( still denoted by a lowercase English letter) . After this work, she finds out all subsegments of the garland containing pieces of only colour c \u2014 Brother Koyomi' s favourite one, and takes the length of the longest among them to be the Koyomity of the garland. For instance, let' s say the garland is represented by \" kooomo\" , and Brother Koyomi' s favourite colour is \" o\" . Among all subsegments containing pieces of \" o\" only, \" ooo\" is the longest, with a length of 3. Thus the Koyomity of this garland equals 3. But problem arises as Nadeko is unsure about Brother Koyomi' s favourite colour, and has swaying ideas on the amount of work to do. She has q plans on this, each of which can be expressed as a pair of an integer mi and a lowercase letter ci, meanings of which are explained above. You are to find out the maximum Koyomity achievable after repainting the garland according to each plan.",
    "input": "The first line of input contains a positive integer n ( 1 \u2264 n \u2264 1 500) \u2014 the length of the garland. The second line contains n lowercase English letters s1s2. . . sn as a string \u2014 the initial colours of paper pieces on the garland. The third line contains a positive integer q ( 1 \u2264 q \u2264 200 000) \u2014 the number of plans Nadeko has. The next q lines describe one plan each: the i- th among them contains an integer mi ( 1 \u2264 mi \u2264 n) \u2014 the maximum amount of pieces to repaint, followed by a space, then by a lowercase English letter ci \u2014 Koyomi' s possible favourite colour.",
    "output": "Output q lines: for each work plan, output one line containing an integer \u2014 the largest Koyomity achievable after repainting the garland according to it.",
    "note": "In the first sample, there are three plans: In the first plan, at most 1 piece can be repainted. Repainting the \" y\" piece to become \" o\" results in \" kooomi\" , whose Koyomity of 3 is the best achievable; In the second plan, at most 4 pieces can be repainted, and \" oooooo\" results in a Koyomity of 6; In the third plan, at most 4 pieces can be repainted, and \" mmmmmi\" and \" kmmmmm\" both result in a Koyomity of 5.",
    "topics": [
      "brute force",
      "dp",
      "strings",
      "two pointers"
    ]
  },
  {
    "title": "Anthem of Berland",
    "url": "https://codeforces.com/problemset/problem/808/G",
    "history": "Berland has a long and glorious history. To increase awareness about it among younger citizens, King of Berland decided to compose an anthem. Though there are lots and lots of victories in history of Berland, there is the one that stand out the most. King wants to mention it in the anthem as many times as possible. He has already composed major part of the anthem and now just needs to fill in some letters. King asked you to help him with this work. The anthem is the string s of no more than 105 small Latin letters and question marks. The most glorious victory is the string t of no more than 105 small Latin letters. You should replace all the question marks with small Latin letters in such a way that the number of occurrences of string t in string s is maximal. Note that the occurrences of string t in s can overlap. Check the third example for clarification.",
    "input": "The first line contains string of small Latin letters and question marks s ( 1 \u2264 | s| \u2264 105) . The second line contains string of small Latin letters t ( 1 \u2264 | t| \u2264 105) . Product of lengths of strings | s| \u00b7| t| won' t exceed 107.",
    "output": "Output the maximum number of occurrences of string t you can achieve by replacing all the question marks in string s with small Latin letters.",
    "note": "In the first example the resulting string s is \" winlosewinwinlwinwin\" In the second example the resulting string s is \" glorytoreorand\" . The last letter of the string can be arbitrary. In the third example occurrences of string t are overlapping. String s with maximal number of occurrences of t is \" abcabcab\" .",
    "topics": [
      "dp",
      "strings"
    ]
  },
  {
    "title": "Fake News (medium)",
    "url": "https://codeforces.com/problemset/problem/802/H",
    "history": "Thanks to your help, Heidi is confident that no one can fool her. She has now decided to post some fake news on the HC2 Facebook page. However, she wants to be able to communicate to the HC2 committee that the post is fake, using some secret phrase hidden in the post as a subsequence. To make this method foolproof, she wants the phrase to appear n times in the post. She is asking you to design a post ( string) s and a hidden phrase p such that p appears in s as a subsequence exactly n times.",
    "input": "The first and only line of input contains a single integer n ( 1 \u2264 n \u2264 1 000 000) .",
    "output": "The output should contain two nonempty strings s and p separated by a single space. Each string should be composed of letters ( a- z and A- Z: both lowercase and uppercase are allowed) and have length at most 200. The number of occurrences of p in s as a subsequence should be exactly n. If there are many possible solutions, output any of them. It is guaranteed that at least one solution exists.",
    "note": "An occurrence of p as a subsequence in s should be thought of as a set of positions in s such that the letters at these positions, in order, form p. The number of occurences is thus the number of such sets. For example, ab appears 6 times as a subsequence in aaabb, for the following sets of positions: 1, 4, 1, 5, 2, 4, 2, 5, 3, 4, 3, 5 ( that is, we should choose one of the a' s and one of the b' s) .",
    "topics": [
      "constructive algorithms",
      "strings"
    ]
  },
  {
    "title": "Fake News (easy)",
    "url": "https://codeforces.com/problemset/problem/802/G",
    "history": "As it' s the first of April, Heidi is suspecting that the news she reads today are fake, and she does not want to look silly in front of all the contestants. She knows that a newspiece is fake if it contains heidi as a subsequence. Help Heidi assess whether the given piece is true, but please be discreet about it. . .",
    "input": "The first and only line of input contains a single nonempty string s of length at most 1000 composed of lowercase letters ( a- z) .",
    "output": "Output YES if the string s contains heidi as a subsequence and NO otherwise.",
    "note": "A string s contains another string p as a subsequence if it is possible to delete some characters from s and obtain p.",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Valued Keys",
    "url": "https://codeforces.com/problemset/problem/801/B",
    "history": "You found a mysterious function f. The function takes two strings s1 and s2. These strings must consist only of lowercase English letters, and must be the same length. The output of the function f is another string of the same length. The i- th character of the output is equal to the minimum of the i- th character of s1 and the i- th character of s2. For example, f( \" ab\" , \" ba\" ) = \" aa\" , and f( \" nzwzl\" , \" zizez\" ) = \" niwel\" . You found two strings x and y of the same length and consisting of only lowercase English letters. Find any string z such that f( x, z) = y, or print - 1 if no such string z exists.",
    "input": "The first line of input contains the string x. The second line of input contains the string y. Both x and y consist only of lowercase English letters, x and y have same length and this length is between 1 and 100.",
    "output": "If there is no string z such that f( x, z) = y, print - 1. Otherwise, print a string z such that f( x, z) = y. If there are multiple possible answers, print any of them. The string z should be the same length as x and y and consist only of lowercase English letters.",
    "note": "The first case is from the statement. Another solution for the second case is \" zizez\" There is no solution for the third case. That is, there is no z such that f( \" ab\" , z) = \" ba\" .",
    "topics": [
      "constructive algorithms",
      "greedy",
      "strings"
    ]
  },
  {
    "title": "Mike and strings",
    "url": "https://codeforces.com/problemset/problem/798/B",
    "history": "Mike has n strings s1, s2, . . . , sn each consisting of lowercase English letters. In one move he can choose a string si, erase the first character and append it to the end of the string. For example, if he has the string \" coolmike\" , in one move he can transform it into the string \" oolmikec\" . Now Mike asks himself: what is minimal number of moves that he needs to do in order to make all the strings equal?",
    "input": "The first line contains integer n ( 1 \u2264 n \u2264 50) \u2014 the number of strings. This is followed by n lines which contain a string each. The i- th line corresponding to string si. Lengths of strings are equal. Lengths of each string is positive and don' t exceed 50.",
    "output": "Print the minimal number of moves Mike needs in order to make all the strings equal or print - 1 if there is no solution.",
    "note": "In the first sample testcase the optimal scenario is to perform operations in such a way as to transform all strings into \" zwoxz\" .",
    "topics": [
      "brute force",
      "dp",
      "strings"
    ]
  },
  {
    "title": "Mike and palindrome",
    "url": "https://codeforces.com/problemset/problem/798/A",
    "history": "Mike has a string s consisting of only lowercase English letters. He wants to change exactly one character from the string so that the resulting one is a palindrome. A palindrome is a string that reads the same backward as forward, for example strings \" z\" , \" aaa\" , \" aba\" , \" abccba\" are palindromes, but strings \" codeforces\" , \" reality\" , \" ab\" are not.",
    "input": "The first and single line contains string s ( 1 \u2264 | s| \u2264 15) .",
    "output": "Print \" YES\" ( without quotes) if Mike can change exactly one character so that the resulting string is palindrome or \" NO\" ( without quotes) otherwise.",
    "note": "",
    "topics": [
      "brute force",
      "constructive algorithms",
      "strings"
    ]
  },
  {
    "title": "Minimal string",
    "url": "https://codeforces.com/problemset/problem/797/C",
    "history": "Petya recieved a gift of a string s with length up to 105 characters for his birthday. He took two more empty strings t and u and decided to play a game. This game has two possible moves: Extract the first character of s and append t with this character. Extract the last character of t and append u with this character. Petya wants to get strings s and t empty and string u lexicographically minimal. You should write a program that will help Petya win the game.",
    "input": "First line contains non- empty string s ( 1 \u2264 | s| \u2264 105) , consisting of lowercase English letters.",
    "output": "Print resulting string u.",
    "note": "",
    "topics": [
      "data structures",
      "greedy",
      "strings"
    ]
  },
  {
    "title": "Rap God",
    "url": "https://codeforces.com/problemset/problem/786/D",
    "history": "Rick is in love with Unity. But Mr. Meeseeks also love Unity, so Rick and Mr. Meeseeks are \" love rivals\" . Unity loves rap, so it decided that they have to compete in a rap game ( battle) in order to choose the best. Rick is too nerds, so instead he' s gonna make his verse with running his original algorithm on lyrics \" Rap God\" song. His algorithm is a little bit complicated. He' s made a tree with n vertices numbered from 1 to n and there' s a lowercase english letter written on each edge. He denotes str( a, b) to be the string made by writing characters on edges on the shortest path from a to b one by one ( a string of length equal to distance of a to b) . Note that str( a, b) is reverse of str( b, a) and str( a, a) is empty. In order to make the best verse he can, he needs to answer some queries, but he' s not a computer scientist and is not able to answer those queries, so he asked you to help him. Each query is characterized by two vertices x and y ( x = \u0338 y) . Answer to this query is the number of vertices like z such that z = \u0338 x, z = \u0338 y and str( x, y) is lexicographically larger than str( x, z) . String x = x1x2. . . x| x| is lexicographically larger than string y = y1y2. . . y| y| , if either | x| > | y| and x1 = y1, x2 = y2, . . . , x| y| = y| y| , or exists such number r ( r < | x| , r < | y| ) , that x1 = y1, x2 = y2, . . . , xr = yr and xr + 1 > yr + 1. Characters are compared like their ASCII codes ( or alphabetic order) . Help Rick get the girl ( or whatever gender Unity has) .",
    "input": "The first line of input contain two integers n and q ( 2 \u2264 n \u2264 20000, 1 \u2264 q \u2264 20000) \u2014 number of vertices in tree and number of queries respectively. The next n - 1 lines contain the edges. Each line contains two integers v and u ( endpoints of the edge) followed by an English lowercase letter c ( 1 \u2264 v, u \u2264 n, v = \u0338 u) . The next q line contain the queries. Each line contains two integers x and y ( 1 \u2264 x, y \u2264 n, x = \u0338 y) .",
    "output": "Print the answer for each query in one line.",
    "note": "Here' s the tree of first sample testcase: Here' s the tree of second sample testcase: In this test: str( 8, 1) = poo str( 8, 2) = poe str( 8, 3) = po str( 8, 4) = pop str( 8, 5) = popd str( 8, 6) = popp str( 8, 7) = p So, for the first query, and for the third query is the answer.",
    "topics": [
      "data structures",
      "dfs and similar",
      "hashing",
      "strings",
      "trees"
    ]
  },
  {
    "title": "Anton and Polyhedrons",
    "url": "https://codeforces.com/problemset/problem/785/A",
    "history": "Anton' s favourite geometric figures are regular polyhedrons. Note that there are five kinds of regular polyhedrons: Tetrahedron. Tetrahedron has 4 triangular faces. Cube. Cube has 6 square faces. Octahedron. Octahedron has 8 triangular faces. Dodecahedron. Dodecahedron has 12 pentagonal faces. Icosahedron. Icosahedron has 20 triangular faces. All five kinds of polyhedrons are shown on the picture below: Anton has a collection of n polyhedrons. One day he decided to know, how many faces his polyhedrons have in total. Help Anton and find this number!",
    "input": "The first line of the input contains a single integer n ( 1 \u2264 n \u2264 200 000) \u2014 the number of polyhedrons in Anton' s collection. Each of the following n lines of the input contains a string si \u2014 the name of the i- th polyhedron in Anton' s collection. The string can look like this: \" Tetrahedron\" ( without quotes) , if the i- th polyhedron in Anton' s collection is a tetrahedron. \" Cube\" ( without quotes) , if the i- th polyhedron in Anton' s collection is a cube. \" Octahedron\" ( without quotes) , if the i- th polyhedron in Anton' s collection is an octahedron. \" Dodecahedron\" ( without quotes) , if the i- th polyhedron in Anton' s collection is a dodecahedron. \" Icosahedron\" ( without quotes) , if the i- th polyhedron in Anton' s collection is an icosahedron.",
    "output": "Output one number \u2014 the total number of faces in all the polyhedrons in Anton' s collection.",
    "note": "In the first sample Anton has one icosahedron, one cube, one tetrahedron and one dodecahedron. Icosahedron has 20 faces, cube has 6 faces, tetrahedron has 4 faces and dodecahedron has 12 faces. In total, they have 20 + 6 + 4 + 12 = 42 faces.",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Innokenty and a Football League",
    "url": "https://codeforces.com/problemset/problem/780/D",
    "history": "Innokenty is a president of a new football league in Byteland. The first task he should do is to assign short names to all clubs to be shown on TV next to the score. Of course, the short names should be distinct, and Innokenty wants that all short names consist of three letters. Each club' s full name consist of two words: the team' s name and the hometown' s name, for example, \" DINAMO BYTECITY\" . Innokenty doesn' t want to assign strange short names, so he wants to choose such short names for each club that: the short name is the same as three first letters of the team' s name, for example, for the mentioned club it is \" DIN\" , or, the first two letters of the short name should be the same as the first two letters of the team' s name, while the third letter is the same as the first letter in the hometown' s name. For the mentioned club it is \" DIB\" . Apart from this, there is a rule that if for some club x the second option of short name is chosen, then there should be no club, for which the first option is chosen which is the same as the first option for the club x. For example, if the above mentioned club has short name \" DIB\" , then no club for which the first option is chosen can have short name equal to \" DIN\" . However, it is possible that some club have short name \" DIN\" , where \" DI\" are the first two letters of the team' s name, and \" N\" is the first letter of hometown' s name. Of course, no two teams can have the same short name. Help Innokenty to choose a short name for each of the teams. If this is impossible, report that. If there are multiple answer, any of them will suit Innokenty. If for some team the two options of short name are equal, then Innokenty will formally think that only one of these options is chosen.",
    "input": "The first line contains a single integer n ( 1 \u2264 n \u2264 1000) \u2014 the number of clubs in the league. Each of the next n lines contains two words \u2014 the team' s name and the hometown' s name for some club. Both team' s name and hometown' s name consist of uppercase English letters and have length at least 3 and at most 20.",
    "output": "It it is not possible to choose short names and satisfy all constraints, print a single line \" NO\" . Otherwise, in the first line print \" YES\" . Then print n lines, in each line print the chosen short name for the corresponding club. Print the clubs in the same order as they appeared in input. If there are multiple answers, print any of them.",
    "note": "In the first sample Innokenty can choose first option for both clubs. In the second example it is not possible to choose short names, because it is not possible that one club has first option, and the other has second option if the first options are equal for both clubs. In the third example Innokenty can choose the second options for the first two clubs, and the first option for the third club. In the fourth example note that it is possible that the chosen short name for some club x is the same as the first option of another club y if the first options of x and y are different.",
    "topics": [
      "2-sat",
      "graphs",
      "greedy",
      "implementation",
      "shortest paths",
      "strings"
    ]
  },
  {
    "title": "Peterson Polyglot",
    "url": "https://codeforces.com/problemset/problem/778/C",
    "history": "Peterson loves to learn new languages, but his favorite hobby is making new ones. Language is a set of words, and word is a sequence of lowercase Latin letters. Peterson makes new language every morning. It is difficult task to store the whole language, so Peterson have invented new data structure for storing his languages which is called broom. Broom is rooted tree with edges marked with letters. Initially broom is represented by the only vertex \u2014 the root of the broom. When Peterson wants to add new word to the language he stands at the root and processes the letters of new word one by one. Consider that Peterson stands at the vertex u. If there is an edge from u marked with current letter, Peterson goes through this edge. Otherwise Peterson adds new edge from u to the new vertex v, marks it with the current letter and goes through the new edge. Size of broom is the number of vertices in it. In the evening after working day Peterson can' t understand the language he made this morning. It is too difficult for bored Peterson and he tries to make it simpler. Simplification of the language is the process of erasing some letters from some words of this language. Formally, Peterson takes some positive integer p and erases p- th letter from all the words of this language having length at least p. Letters in words are indexed starting by 1. Peterson considers that simplification should change at least one word, i. e. there has to be at least one word of length at least p. Peterson tries to make his language as simple as possible, so he wants to choose p such that the size of the broom for his simplified language is as small as possible. Peterson is pretty annoyed with this task so he asks you for help. Write a program to find the smallest possible size of the broom and integer p.",
    "input": "The first line of input contains integer n ( 2 \u2264 n \u2264 3\u00b7105) \u2014 the size of the broom. Next n - 1 lines describe the broom: i- th of them contains integers ui, vi and letter xi \u2014 describing the edge from ui to vi marked with letter xi. Vertices are numbered from 1 to n. All xi are lowercase latin letters. Vertex 1 is the root of the broom. Edges describe correct broom which is made from Peterson' s language.",
    "output": "The first line of output should contain the minimum possible size of the broom after its simplification. The second line of output should contain integer p to choose. If there are several suitable p values, print the smallest one.",
    "note": "Broom from the second sample test can be built using language \" piece\" , \" of\" , \" pie\" , \" pretty\" , \" prefix\" . Its simplification with p = 2 obtains the language of words \" pece\" , \" o\" , \" pe\" , \" petty\" , \" pefix\" . This language gives us the broom with minimum possible size.",
    "topics": [
      "brute force",
      "dfs and similar",
      "dsu",
      "hashing",
      "strings",
      "trees"
    ]
  },
  {
    "title": "String Game",
    "url": "https://codeforces.com/problemset/problem/778/A",
    "history": "Little Nastya has a hobby, she likes to remove some letters from word, to obtain another word. But it turns out to be pretty hard for her, because she is too young. Therefore, her brother Sergey always helps her. Sergey gives Nastya the word t and wants to get the word p out of it. Nastya removes letters in a certain order ( one after another, in this order strictly) , which is specified by permutation of letters' indices of the word t: a1. . . a| t| . We denote the length of word x as | x| . Note that after removing one letter, the indices of other letters don' t change. For example, if t = \" nastya\" and a = [ 4, 1, 5, 3, 2, 6] then removals make the following sequence of words \" nastya\" \" nastya\" \" nastya\" \" nastya\" \" nastya\" \" nastya\" \" nastya\" . Sergey knows this permutation. His goal is to stop his sister at some point and continue removing by himself to get the word p. Since Nastya likes this activity, Sergey wants to stop her as late as possible. Your task is to determine, how many letters Nastya can remove before she will be stopped by Sergey. It is guaranteed that the word p can be obtained by removing the letters from word t.",
    "input": "The first and second lines of the input contain the words t and p, respectively. Words are composed of lowercase letters of the Latin alphabet ( 1 \u2264 | p| < | t| \u2264 200 000) . It is guaranteed that the word p can be obtained by removing the letters from word t. Next line contains a permutation a1, a2, . . . , a| t| of letter indices that specifies the order in which Nastya removes letters of t ( 1 \u2264 ai \u2264 | t| , all ai are distinct) .",
    "output": "Print a single integer number, the maximum number of letters that Nastya can remove.",
    "note": "In the first sample test sequence of removing made by Nastya looks like this: \" ababcba\" \" ababcba\" \" ababcba\" \" ababcba\" Nastya can not continue, because it is impossible to get word \" abb\" from word \" ababcba\" . So, Nastya will remove only three letters.",
    "topics": [
      "binary search",
      "greedy",
      "strings"
    ]
  },
  {
    "title": "Cloud of Hashtags",
    "url": "https://codeforces.com/problemset/problem/777/D",
    "history": "Vasya is an administrator of a public page of organization \" Mouse and keyboard\" and his everyday duty is to publish news from the world of competitive programming. For each news he also creates a list of hashtags to make searching for a particular topic more comfortable. For the purpose of this problem we define hashtag as a string consisting of lowercase English letters and exactly one symbol ' # ' located at the beginning of the string. The length of the hashtag is defined as the number of symbols in it without the symbol ' # ' . The head administrator of the page told Vasya that hashtags should go in lexicographical order ( take a look at the notes section for the definition) . Vasya is lazy so he doesn' t want to actually change the order of hashtags in already published news. Instead, he decided to delete some suffixes ( consecutive characters at the end of the string) of some of the hashtags. He is allowed to delete any number of characters, even the whole string except for the symbol ' # ' . Vasya wants to pick such a way to delete suffixes that the total number of deleted symbols is minimum possible. If there are several optimal solutions, he is fine with any of them.",
    "input": "The first line of the input contains a single integer n ( 1 \u2264 n \u2264 500 000) \u2014 the number of hashtags being edited now. Each of the next n lines contains exactly one hashtag of positive length. It is guaranteed that the total length of all hashtags ( i. e. the total length of the string except for characters ' # ' ) won' t exceed 500 000.",
    "output": "Print the resulting hashtags in any of the optimal solutions.",
    "note": "Word a1, a2, . . . , am of length m is lexicographically not greater than word b1, b2, . . . , bk of length k, if one of two conditions hold: at first position i, such that ai = \u0338 bi, the character ai goes earlier in the alphabet than character bi, i. e. a has smaller character than b in the first position where they differ; if there is no such position i and m \u2264 k, i. e. the first word is a prefix of the second or two words are equal. The sequence of words is said to be sorted in lexicographical order if each word ( except the last one) is lexicographically not greater than the next word. For the words consisting of lowercase English letters the lexicographical order coincides with the alphabet word order in the dictionary. According to the above definition, if a hashtag consisting of one character ' # ' it is lexicographically not greater than any other valid hashtag. That' s why in the third sample we can' t keep first two hashtags unchanged and shorten the other two.",
    "topics": [
      "binary search",
      "greedy",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "A Serial Killer",
    "url": "https://codeforces.com/problemset/problem/776/A",
    "history": "Our beloved detective, Sherlock is currently trying to catch a serial killer who kills a person each day. Using his powers of deduction, he came to know that the killer has a strategy for selecting his next victim. The killer starts with two potential victims on his first day, selects one of these two, kills selected victim and replaces him with a new person. He repeats this procedure each day. This way, each day he has two potential victims to choose from. Sherlock knows the initial two potential victims. Also, he knows the murder that happened on a particular day and the new person who replaced this victim. You need to help him get all the pairs of potential victims at each day so that Sherlock can observe some pattern.",
    "input": "First line of input contains two names ( length of each of them doesn' t exceed 10) , the two initials potential victims. Next line contains integer n ( 1 \u2264 n \u2264 1000) , the number of days. Next n lines contains two names ( length of each of them doesn' t exceed 10) , first being the person murdered on this day and the second being the one who replaced that person. The input format is consistent, that is, a person murdered is guaranteed to be from the two potential victims at that time. Also, all the names are guaranteed to be distinct and consists of lowercase English letters.",
    "output": "Output n + 1 lines, the i- th line should contain the two persons from which the killer selects for the i- th murder. The ( n + 1) - th line should contain the two persons from which the next victim is selected. In each line, the two names can be printed in any order.",
    "note": "In first example, the killer starts with ross and rachel. After day 1, ross is killed and joey appears. After day 2, rachel is killed and phoebe appears. After day 3, phoebe is killed and monica appears. After day 4, monica is killed and chandler appears.",
    "topics": [
      "brute force",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Stepan and Vowels",
    "url": "https://codeforces.com/problemset/problem/774/K",
    "history": "Stepan likes to repeat vowel letters when he writes words. For example, instead of the word \" pobeda\" he can write \" pobeeeedaaaaa\" . Sergey does not like such behavior, so he wants to write a program to format the words written by Stepan. This program must combine all consecutive equal vowels to a single vowel. The vowel letters are \" a\" , \" e\" , \" i\" , \" o\" , \" u\" and \" y\" . There are exceptions: if letters \" e\" or \" o\" repeat in a row exactly 2 times, like in words \" feet\" and \" foot\" , the program must skip them and do not transform in one vowel. For example, the word \" iiiimpleeemeentatiioon\" must be converted to the word \" implemeentatioon\" . Sergey is very busy and asks you to help him and write the required program.",
    "input": "The first line contains the integer n ( 1 \u2264 n \u2264 100 000) \u2014 the number of letters in the word written by Stepan. The second line contains the string s which has length that equals to n and contains only lowercase English letters \u2014 the word written by Stepan.",
    "output": "Print the single string \u2014 the word written by Stepan converted according to the rules described in the statement.",
    "note": "",
    "topics": [
      "*special",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Mahmoud and a Message",
    "url": "https://codeforces.com/problemset/problem/766/C",
    "history": "Mahmoud wrote a message s of length n. He wants to send it as a birthday present to his friend Moaz who likes strings. He wrote it on a magical paper but he was surprised because some characters disappeared while writing the string. That' s because this magical paper doesn' t allow character number i in the English alphabet to be written on it in a string of length more than ai. For example, if a1 = 2 he can' t write character ' a' on this paper in a string of length 3 or more. String \" aa\" is allowed while string \" aaa\" is not. Mahmoud decided to split the message into some non- empty substrings so that he can write every substring on an independent magical paper and fulfill the condition. The sum of their lengths should be n and they shouldn' t overlap. For example, if a1 = 2 and he wants to send string \" aaa\" , he can split it into \" a\" and \" aa\" and use 2 magical papers, or into \" a\" , \" a\" and \" a\" and use 3 magical papers. He can' t split it into \" aa\" and \" aa\" because the sum of their lengths is greater than n. He can split the message into single string if it fulfills the conditions. A substring of string s is a string that consists of some consecutive characters from string s, strings \" ab\" , \" abc\" and \" b\" are substrings of string \" abc\" , while strings \" acb\" and \" ac\" are not. Any string is a substring of itself. While Mahmoud was thinking of how to split the message, Ehab told him that there are many ways to split it. After that Mahmoud asked you three questions: How many ways are there to split the string into substrings such that every substring fulfills the condition of the magical paper, the sum of their lengths is n and they don' t overlap? Compute the answer modulo 109 + 7. What is the maximum length of a substring that can appear in some valid splitting? What is the minimum number of substrings the message can be spit in? Two ways are considered different, if the sets of split positions differ. For example, splitting \" aa| a\" and \" a| aa\" are considered different splittings of message \" aaa\" .",
    "input": "The first line contains an integer n ( 1 \u2264 n \u2264 103) denoting the length of the message. The second line contains the message s of length n that consists of lowercase English letters. The third line contains 26 integers a1, a2, . . . , a26 ( 1 \u2264 ax \u2264 103) \u2014 the maximum lengths of substring each letter can appear in.",
    "output": "Print three lines. In the first line print the number of ways to split the message into substrings and fulfill the conditions mentioned in the problem modulo 109 + 7. In the second line print the length of the longest substring over all the ways. In the third line print the minimum number of substrings over all the ways.",
    "note": "In the first example the three ways to split the message are: a| a| b aa| b a| ab The longest substrings are \" aa\" and \" ab\" of length 2. The minimum number of substrings is 2 in \" a| ab\" or \" aa| b\" . Notice that \" aab\" is not a possible splitting because the letter ' a' appears in a substring of length 3, while a1 = 2.",
    "topics": [
      "brute force",
      "dp",
      "greedy",
      "strings"
    ]
  },
  {
    "title": "Mahmoud and Longest Uncommon Subsequence",
    "url": "https://codeforces.com/problemset/problem/766/A",
    "history": "While Mahmoud and Ehab were practicing for IOI, they found a problem which name was Longest common subsequence. They solved it, and then Ehab challenged Mahmoud with another problem. Given two strings a and b, find the length of their longest uncommon subsequence, which is the longest string that is a subsequence of one of them and not a subsequence of the other. A subsequence of some string is a sequence of characters that appears in the same order in the string, The appearances don' t have to be consecutive, for example, strings \" ac\" , \" bc\" , \" abc\" and \" a\" are subsequences of string \" abc\" while strings \" abbc\" and \" acb\" are not. The empty string is a subsequence of any string. Any string is a subsequence of itself.",
    "input": "The first line contains string a, and the second line \u2014 string b. Both of these strings are non- empty and consist of lowercase letters of English alphabet. The length of each string is not bigger than 105 characters.",
    "output": "If there' s no uncommon subsequence, print \" - 1\" . Otherwise print the length of the longest uncommon subsequence of a and b.",
    "note": "In the first example: you can choose \" defgh\" from string b as it is the longest subsequence of string b that doesn' t appear as a subsequence of string a.",
    "topics": [
      "constructive algorithms",
      "strings"
    ]
  },
  {
    "title": "Code obfuscation",
    "url": "https://codeforces.com/problemset/problem/765/B",
    "history": "Kostya likes Codeforces contests very much. However, he is very disappointed that his solutions are frequently hacked. That' s why he decided to obfuscate ( intentionally make less readable) his code before upcoming contest. To obfuscate the code, Kostya first looks at the first variable name used in his program and replaces all its occurrences with a single symbol a, then he looks at the second variable name that has not been replaced yet, and replaces all its occurrences with b, and so on. Kostya is well- mannered, so he doesn' t use any one- letter names before obfuscation. Moreover, there are at most 26 unique identifiers in his programs. You are given a list of identifiers of some program with removed spaces and line breaks. Check if this program can be a result of Kostya' s obfuscation.",
    "input": "In the only line of input there is a string S of lowercase English letters ( 1 \u2264 | S| \u2264 500) \u2014 the identifiers of a program with removed whitespace characters.",
    "output": "If this program can be a result of Kostya' s obfuscation, print \" YES\" ( without quotes) , otherwise print \" NO\" .",
    "note": "In the first sample case, one possible list of identifiers would be \" number string number character number string number\" . Here how Kostya would obfuscate the program: replace all occurences of number with a, the result would be \" a string a character a string a\" , replace all occurences of string with b, the result would be \" a b a character a b a\" , replace all occurences of character with c, the result would be \" a b a c a b a\" , all identifiers have been replaced, thus the obfuscation is finished.",
    "topics": [
      "greedy",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Two strings",
    "url": "https://codeforces.com/problemset/problem/762/C",
    "history": "You are given two strings a and b. You have to remove the minimum possible number of consecutive ( standing one after another) characters from string b in such a way that it becomes a subsequence of string a. It can happen that you will not need to remove any characters at all, or maybe you will have to remove all of the characters from b and make it empty. Subsequence of string s is any such string that can be obtained by erasing zero or more characters ( not necessarily consecutive) from string s.",
    "input": "The first line contains string a, and the second line \u2014 string b. Both of these strings are nonempty and consist of lowercase letters of English alphabet. The length of each string is no bigger than 105 characters.",
    "output": "On the first line output a subsequence of string a, obtained from b by erasing the minimum number of consecutive characters. If the answer consists of zero characters, output \u00ab- \u00bb ( a minus sign) .",
    "note": "In the first example strings a and b don' t share any symbols, so the longest string that you can get is empty. In the second example ac is a subsequence of a, and at the same time you can obtain it by erasing consecutive symbols cepted from string b.",
    "topics": [
      "binary search",
      "hashing",
      "strings",
      "two pointers"
    ]
  },
  {
    "title": "Ability To Convert",
    "url": "https://codeforces.com/problemset/problem/758/D",
    "history": "Alexander is learning how to convert numbers from the decimal system to any other, however, he doesn' t know English letters, so he writes any number only as a decimal number, it means that instead of the letter A he will write the number 10. Thus, by converting the number 475 from decimal to hexadecimal system, he gets 11311 ( 475 = 1\u00b7162 + 13\u00b7161 + 11\u00b7160) . Alexander lived calmly until he tried to convert the number back to the decimal number system. Alexander remembers that he worked with little numbers so he asks to find the minimum decimal number so that by converting it to the system with the base n he will get the number k.",
    "input": "The first line contains the integer n ( 2 \u2264 n \u2264 109) . The second line contains the integer k ( 0 \u2264 k < 1060) , it is guaranteed that the number k contains no more than 60 symbols. All digits in the second line are strictly less than n. Alexander guarantees that the answer exists and does not exceed 1018. The number k doesn' t contain leading zeros.",
    "output": "Print the number x ( 0 \u2264 x \u2264 1018) \u2014 the answer to the problem.",
    "note": "In the first example 12 could be obtained by converting two numbers to the system with base 13: 12 = 12\u00b7130 or 15 = 1\u00b7131 + 2\u00b7130.",
    "topics": [
      "constructive algorithms",
      "dp",
      "greedy",
      "math",
      "strings"
    ]
  },
  {
    "title": "Felicity is Coming!",
    "url": "https://codeforces.com/problemset/problem/757/C",
    "history": "It' s that time of the year, Felicity is around the corner and you can see people celebrating all around the Himalayan region. The Himalayan region has n gyms. The i- th gym has gi Pokemon in it. There are m distinct Pokemon types in the Himalayan region numbered from 1 to m. There is a special evolution camp set up in the fest which claims to evolve any Pokemon. The type of a Pokemon could change after evolving, subject to the constraint that if two Pokemon have the same type before evolving, they will have the same type after evolving. Also, if two Pokemon have different types before evolving, they will have different types after evolving. It is also possible that a Pokemon has the same type before and after evolving. Formally, an evolution plan is a permutation f of 1, 2, . . . , m, such that f( x) = y means that a Pokemon of type x evolves into a Pokemon of type y. The gym leaders are intrigued by the special evolution camp and all of them plan to evolve their Pokemons. The protocol of the mountain states that in each gym, for every type of Pokemon, the number of Pokemon of that type before evolving any Pokemon should be equal the number of Pokemon of that type after evolving all the Pokemons according to the evolution plan. They now want to find out how many distinct evolution plans exist which satisfy the protocol. Two evolution plans f1 and f2 are distinct, if they have at least one Pokemon type evolving into a different Pokemon type in the two plans, i. e. there exists an i such that f1( i) = \u0338 f2( i) . Your task is to find how many distinct evolution plans are possible such that if all Pokemon in all the gyms are evolved, the number of Pokemon of each type in each of the gyms remains the same. As the answer can be large, output it modulo 109 + 7.",
    "input": "The first line contains two integers n and m ( 1 \u2264 n \u2264 105, 1 \u2264 m \u2264 106) \u2014 the number of gyms and the number of Pokemon types. The next n lines contain the description of Pokemons in the gyms. The i- th of these lines begins with the integer gi ( 1 \u2264 gi \u2264 105) \u2014 the number of Pokemon in the i- th gym. After that gi integers follow, denoting types of the Pokemons in the i- th gym. Each of these integers is between 1 and m. The total number of Pokemons ( the sum of all gi) does not exceed 5\u00b7105.",
    "output": "Output the number of valid evolution plans modulo 109 + 7.",
    "note": "In the first case, the only possible evolution plan is: In the second case, any permutation of ( 1, 2, 3) is valid. In the third case, there are two possible plans: In the fourth case, the only possible evolution plan is:",
    "topics": [
      "data structures",
      "hashing",
      "sortings",
      "strings"
    ]
  },
  {
    "title": "PolandBall and Game",
    "url": "https://codeforces.com/problemset/problem/755/B",
    "history": "PolandBall is playing a game with EnemyBall. The rules are simple. Players have to say words in turns. You cannot say a word which was already said. PolandBall starts. The Ball which can' t say a new word loses. You' re given two lists of words familiar to PolandBall and EnemyBall. Can you determine who wins the game, if both play optimally?",
    "input": "The first input line contains two integers n and m ( 1 \u2264 n, m \u2264 103) \u2014 number of words PolandBall and EnemyBall know, respectively. Then n strings follow, one per line \u2014 words familiar to PolandBall. Then m strings follow, one per line \u2014 words familiar to EnemyBall. Note that one Ball cannot know a word more than once ( strings are unique) , but some words can be known by both players. Each word is non- empty and consists of no more than 500 lowercase English alphabet letters.",
    "output": "In a single line of print the answer \u2014 \" YES\" if PolandBall wins and \" NO\" otherwise. Both Balls play optimally.",
    "note": "In the first example PolandBall knows much more words and wins effortlessly. In the second example if PolandBall says kremowka first, then EnemyBall cannot use that word anymore. EnemyBall can only say wiedenska. PolandBall says wadowicka and wins.",
    "topics": [
      "binary search",
      "data structures",
      "games",
      "greedy",
      "sortings",
      "strings"
    ]
  },
  {
    "title": "Dasha and cyclic table",
    "url": "https://codeforces.com/problemset/problem/754/E",
    "history": "Dasha is fond of challenging puzzles: Rubik' s Cube 3 \u00d7 3 \u00d7 3, 4 \u00d7 4 \u00d7 4, 5 \u00d7 5 \u00d7 5 and so on. This time she has a cyclic table of size n \u00d7 m, and each cell of the table contains a lowercase English letter. Each cell has coordinates ( i, j) ( 0 \u2264 i < n, 0 \u2264 j < m) . The table is cyclic means that to the right of cell ( i, j) there is the cell , and to the down there is the cell . Dasha has a pattern as well. A pattern is a non- cyclic table of size r \u00d7 c. Each cell is either a lowercase English letter or a question mark. Each cell has coordinates ( i, j) ( 0 \u2264 i < r, 0 \u2264 j < c) . The goal of the puzzle is to find all the appearance positions of the pattern in the cyclic table. We say that the cell ( i, j) of cyclic table is an appearance position, if for every pair ( x, y) such that 0 \u2264 x < r and 0 \u2264 y < c one of the following conditions holds: There is a question mark in the cell ( x, y) of the pattern, or The cell of the cyclic table equals to the cell ( x, y) of the pattern. Dasha solved this puzzle in no time, as well as all the others she ever tried. Can you solve it? .",
    "input": "The first line contains two integers n and m ( 1 \u2264 n, m \u2264 400) \u2014 the cyclic table sizes. Each of the next n lines contains a string of m lowercase English characters \u2014 the description of the cyclic table. The next line contains two integers r and c ( 1 \u2264 r, c \u2264 400) \u2014 the sizes of the pattern. Each of the next r lines contains a string of c lowercase English letter and/ or characters ' ? ' \u2014 the description of the pattern.",
    "output": "Print n lines. Each of the n lines should contain m characters. Each of the characters should equal ' 0' or ' 1' . The j- th character of the i- th ( 0- indexed) line should be equal to ' 1' , in case the cell ( i, j) is an appearance position, otherwise it should be equal to ' 0' .",
    "note": "",
    "topics": [
      "bitmasks",
      "brute force",
      "fft",
      "strings",
      "trees"
    ]
  },
  {
    "title": "Vladik and chat",
    "url": "https://codeforces.com/problemset/problem/754/C",
    "history": "Recently Vladik discovered a new entertainment \u2014 coding bots for social networks. He would like to use machine learning in his bots so now he want to prepare some learning data for them. At first, he need to download t chats. Vladik coded a script which should have downloaded the chats, however, something went wrong. In particular, some of the messages have no information of their sender. It is known that if a person sends several messages in a row, they all are merged into a single message. It means that there could not be two or more messages in a row with the same sender. Moreover, a sender never mention himself in his messages. Vladik wants to recover senders of all the messages so that each two neighboring messages will have different senders and no sender will mention himself in his messages. He has no idea of how to do this, and asks you for help. Help Vladik to recover senders in each of the chats!",
    "input": "The first line contains single integer t ( 1 \u2264 t \u2264 10) \u2014 the number of chats. The t chats follow. Each chat is given in the following format. The first line of each chat description contains single integer n ( 1 \u2264 n \u2264 100) \u2014 the number of users in the chat. The next line contains n space- separated distinct usernames. Each username consists of lowercase and uppercase English letters and digits. The usernames can' t start with a digit. Two usernames are different even if they differ only with letters' case. The length of username is positive and doesn' t exceed 10 characters. The next line contains single integer m ( 1 \u2264 m \u2264 100) \u2014 the number of messages in the chat. The next m line contain the messages in the following formats, one per line: < username> : < text> \u2014 the format of a message with known sender. The username should appear in the list of usernames of the chat. < ? > : < text> \u2014 the format of a message with unknown sender. The text of a message can consist of lowercase and uppercase English letter, digits, characters ' . ' ( dot) , ' , ' ( comma) , ' ! ' ( exclamation mark) , ' ? ' ( question mark) and ' ' ( space) . The text doesn' t contain trailing spaces. The length of the text is positive and doesn' t exceed 100 characters. We say that a text mention a user if his username appears in the text as a word. In other words, the username appears in a such a position that the two characters before and after its appearance either do not exist or are not English letters or digits. For example, the text \" Vasya, masha13 and Kate! \" can mention users \" Vasya\" , \" masha13\" , \" and\" and \" Kate\" , but not \" masha\" . It is guaranteed that in each chat no known sender mention himself in his messages and there are no two neighboring messages with the same known sender.",
    "output": "Print the information about the t chats in the following format: If it is not possible to recover senders, print single line \" Impossible\" for this chat. Otherwise print m messages in the following format: < username> : < text> If there are multiple answers, print any of them.",
    "note": "",
    "topics": [
      "brute force",
      "constructive algorithms",
      "dp",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Santa Claus and Keyboard Check",
    "url": "https://codeforces.com/problemset/problem/748/B",
    "history": "Santa Claus decided to disassemble his keyboard to clean it. After he returned all the keys back, he suddenly realized that some pairs of keys took each other' s place! That is, Santa suspects that each key is either on its place, or on the place of another key, which is located exactly where the first key should be. In order to make sure that he' s right and restore the correct order of keys, Santa typed his favorite patter looking only to his keyboard. You are given the Santa' s favorite patter and the string he actually typed. Determine which pairs of keys could be mixed. Each key must occur in pairs at most once.",
    "input": "The input consists of only two strings s and t denoting the favorite Santa' s patter and the resulting string. s and t are not empty and have the same length, which is at most 1000. Both strings consist only of lowercase English letters.",
    "output": "If Santa is wrong, and there is no way to divide some of keys into pairs and swap keys in each pair so that the keyboard will be fixed, print \u00ab- 1\u00bb ( without quotes) . Otherwise, the first line of output should contain the only integer k ( k \u2265 0) \u2014 the number of pairs of keys that should be swapped. The following k lines should contain two space- separated letters each, denoting the keys which should be swapped. All printed letters must be distinct. If there are several possible answers, print any of them. You are free to choose the order of the pairs and the order of keys in a pair. Each letter must occur at most once. Santa considers the keyboard to be fixed if he can print his favorite patter without mistakes.",
    "note": "",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Comments",
    "url": "https://codeforces.com/problemset/problem/747/E",
    "history": "A rare article in the Internet is posted without a possibility to comment it. On a Polycarp' s website each article has comments feed. Each comment on Polycarp' s website is a non- empty string consisting of uppercase and lowercase letters of English alphabet. Comments have tree- like structure, that means each comment except root comments ( comments of the highest level) has exactly one parent comment. When Polycarp wants to save comments to his hard drive he uses the following format. Each comment he writes in the following format: at first, the text of the comment is written; after that the number of comments is written, for which this comment is a parent comment ( i. e. the number of the replies to this comments) ; after that the comments for which this comment is a parent comment are written ( the writing of these comments uses the same algorithm) . All elements in this format are separated by single comma. Similarly, the comments of the first level are separated by comma. For example, if the comments look like: then the first comment is written as \" hello, 2, ok, 0, bye, 0\" , the second is written as \" test, 0\" , the third comment is written as \" one, 1, two, 2, a, 0, b, 0\" . The whole comments feed is written as: \" hello, 2, ok, 0, bye, 0, test, 0, one, 1, two, 2, a, 0, b, 0\" . For a given comments feed in the format specified above print the comments in a different format: at first, print a integer d \u2014 the maximum depth of nesting comments; after that print d lines, the i- th of them corresponds to nesting level i; for the i- th row print comments of nesting level i in the order of their appearance in the Policarp' s comments feed, separated by space.",
    "input": "The first line contains non- empty comments feed in the described format. It consists of uppercase and lowercase letters of English alphabet, digits and commas. It is guaranteed that each comment is a non- empty string consisting of uppercase and lowercase English characters. Each of the number of comments is integer ( consisting of at least one digit) , and either equals 0 or does not contain leading zeros. The length of the whole string does not exceed 106. It is guaranteed that given structure of comments is valid.",
    "output": "Print comments in a format that is given in the statement. For each level of nesting, comments should be printed in the order they are given in the input.",
    "note": "The first example is explained in the statements.",
    "topics": [
      "dfs and similar",
      "expression parsing",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Mammoth's Genome Decoding",
    "url": "https://codeforces.com/problemset/problem/747/B",
    "history": "The process of mammoth' s genome decoding in Berland comes to its end! One of the few remaining tasks is to restore unrecognized nucleotides in a found chain s. Each nucleotide is coded with a capital letter of English alphabet: ' A' , ' C' , ' G' or ' T' . Unrecognized nucleotides are coded by a question mark ' ? ' . Thus, s is a string consisting of letters ' A' , ' C' , ' G' , ' T' and characters ' ? ' . It is known that the number of nucleotides of each of the four types in the decoded genome of mammoth in Berland should be equal. Your task is to decode the genome and replace each unrecognized nucleotide with one of the four types so that the number of nucleotides of each of the four types becomes equal.",
    "input": "The first line contains the integer n ( 4 \u2264 n \u2264 255) \u2014 the length of the genome. The second line contains the string s of length n \u2014 the coded genome. It consists of characters ' A' , ' C' , ' G' , ' T' and ' ? ' .",
    "output": "If it is possible to decode the genome, print it. If there are multiple answer, print any of them. If it is not possible, print three equals signs in a row: \" = = = \" ( without quotes) .",
    "note": "In the first example you can replace the first question mark with the letter ' A' , the second question mark with the letter ' G' , the third question mark with the letter ' T' , then each nucleotide in the genome would be presented twice. In the second example the genome is already decoded correctly and each nucleotide is exactly once in it. In the third and the fourth examples it is impossible to decode the genom.",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Decoding",
    "url": "https://codeforces.com/problemset/problem/746/B",
    "history": "Polycarp is mad about coding, that is why he writes Sveta encoded messages. He calls the median letter in a word the letter which is in the middle of the word. If the word' s length is even, the median letter is the left of the two middle letters. In the following examples, the median letter is highlighted: contest, info. If the word consists of single letter, then according to above definition this letter is the median letter. Polycarp encodes each word in the following way: he writes down the median letter of the word, then deletes it and repeats the process until there are no letters left. For example, he encodes the word volga as logva. You are given an encoding s of some word, your task is to decode it.",
    "input": "The first line contains a positive integer n ( 1 \u2264 n \u2264 2000) \u2014 the length of the encoded word. The second line contains the string s of length n consisting of lowercase English letters \u2014 the encoding.",
    "output": "Print the word that Polycarp encoded.",
    "note": "In the first example Polycarp encoded the word volga. At first, he wrote down the letter l from the position 3, after that his word looked like voga. After that Polycarp wrote down the letter o from the position 2, his word became vga. Then Polycarp wrote down the letter g which was at the second position, the word became va. Then he wrote down the letter v, then the letter a. Thus, the encoding looked like logva. In the second example Polycarp encoded the word no. He wrote down the letter n, the word became o, and he wrote down the letter o. Thus, in this example, the word and its encoding are the same. In the third example Polycarp encoded the word baba. At first, he wrote down the letter a, which was at the position 2, after that the word looked like bba. Then he wrote down the letter b, which was at the position 2, his word looked like ba. After that he wrote down the letter b, which was at the position 1, the word looked like a, and he wrote down that letter a. Thus, the encoding is abba.",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Hongcow Learns the Cyclic Shift",
    "url": "https://codeforces.com/problemset/problem/745/A",
    "history": "Hongcow is learning to spell! One day, his teacher gives him a word that he needs to learn to spell. Being a dutiful student, he immediately learns how to spell the word. Hongcow has decided to try to make new words from this one. He starts by taking the word he just learned how to spell, and moves the last character of the word to the beginning of the word. He calls this a cyclic shift. He can apply cyclic shift many times. For example, consecutively applying cyclic shift operation to the word \" abracadabra\" Hongcow will get words \" aabracadabr\" , \" raabracadab\" and so on. Hongcow is now wondering how many distinct words he can generate by doing the cyclic shift arbitrarily many times. The initial string is also counted.",
    "input": "The first line of input will be a single string s ( 1 \u2264 | s| \u2264 50) , the word Hongcow initially learns how to spell. The string s consists only of lowercase English letters ( ' a' \u2013' z' ) .",
    "output": "Output a single integer equal to the number of distinct strings that Hongcow can obtain by applying the cyclic shift arbitrarily many times to the given string.",
    "note": "For the first sample, the strings Hongcow can generate are \" abcd\" , \" dabc\" , \" cdab\" , and \" bcda\" . For the second sample, no matter how many times Hongcow does the cyclic shift, Hongcow can only generate \" bbb\" . For the third sample, the two strings Hongcow can generate are \" yzyz\" and \" zyzy\" .",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Hongcow Masters the Cyclic Shift",
    "url": "https://codeforces.com/problemset/problem/744/E",
    "history": "Hongcow' s teacher heard that Hongcow had learned about the cyclic shift, and decided to set the following problem for him. You are given a list of n strings s1, s2, . . . , sn contained in the list A. A list X of strings is called stable if the following condition holds. First, a message is defined as a concatenation of some elements of the list X. You can use an arbitrary element as many times as you want, and you may concatenate these elements in any arbitrary order. Let SX denote the set of of all messages you can construct from the list. Of course, this set has infinite size if your list is nonempty. Call a single message good if the following conditions hold: Suppose the message is the concatenation of k strings w1, w2, . . . , wk, where each wi is an element of X. Consider the | w1| + | w2| + . . . + | wk| cyclic shifts of the string. Let m be the number of these cyclic shifts of the string that are elements of SX. A message is good if and only if m is exactly equal to k. The list X is called stable if and only if every element of SX is good. Let f( L) be 1 if L is a stable list, and 0 otherwise. Find the sum of f( L) where L is a nonempty contiguous sublist of A ( there are contiguous sublists in total) .",
    "input": "The first line of input will contain a single integer n ( 1 \u2264 n \u2264 30) , denoting the number of strings in the list. The next n lines will each contain a string si ( ) .",
    "output": "Print a single integer, the number of nonempty contiguous sublists that are stable.",
    "note": "For the first sample, there are 10 sublists to consider. Sublists [ \" a\" , \" ab\" , \" b\" ] , [ \" ab\" , \" b\" , \" bba\" ] , and [ \" a\" , \" ab\" , \" b\" , \" bba\" ] are not stable. The other seven sublists are stable. For example, X = [ \" a\" , \" ab\" , \" b\" ] is not stable, since the message \" ab\" + \" ab\" = \" abab\" has four cyclic shifts [ \" abab\" , \" baba\" , \" abab\" , \" baba\" ] , which are all elements of SX.",
    "topics": [
      "strings",
      "two pointers"
    ]
  },
  {
    "title": "Ostap and Grasshopper",
    "url": "https://codeforces.com/problemset/problem/735/A",
    "history": "On the way to Rio de Janeiro Ostap kills time playing with a grasshopper he took with him in a special box. Ostap builds a line of length n such that some cells of this line are empty and some contain obstacles. Then, he places his grasshopper to one of the empty cells and a small insect in another empty cell. The grasshopper wants to eat the insect. Ostap knows that grasshopper is able to jump to any empty cell that is exactly k cells away from the current ( to the left or to the right) . Note that it doesn' t matter whether intermediate cells are empty or not as the grasshopper makes a jump over them. For example, if k = 1 the grasshopper can jump to a neighboring cell only, and if k = 2 the grasshopper can jump over a single cell. Your goal is to determine whether there is a sequence of jumps such that grasshopper will get from his initial position to the cell with an insect.",
    "input": "The first line of the input contains two integers n and k ( 2 \u2264 n \u2264 100, 1 \u2264 k \u2264 n - 1) \u2014 the number of cells in the line and the length of one grasshopper' s jump. The second line contains a string of length n consisting of characters ' . ' , ' # ' , ' G' and ' T' . Character ' . ' means that the corresponding cell is empty, character ' # ' means that the corresponding cell contains an obstacle and grasshopper can' t jump there. Character ' G' means that the grasshopper starts at this position and, finally, ' T' means that the target insect is located at this cell. It' s guaranteed that characters ' G' and ' T' appear in this line exactly once.",
    "output": "If there exists a sequence of jumps ( each jump of length k) , such that the grasshopper can get from his initial position to the cell with the insect, print \" YES\" ( without quotes) in the only line of the input. Otherwise, print \" NO\" ( without quotes) .",
    "note": "In the first sample, the grasshopper can make one jump to the right in order to get from cell 2 to cell 4. In the second sample, the grasshopper is only able to jump to neighboring cells but the way to the insect is free \u2014 he can get there by jumping left 5 times. In the third sample, the grasshopper can' t make a single jump. In the fourth sample, the grasshopper can only jump to the cells with odd indices, thus he won' t be able to reach the insect.",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Anton and Danik",
    "url": "https://codeforces.com/problemset/problem/734/A",
    "history": "Anton likes to play chess, and so does his friend Danik. Once they have played n games in a row. For each game it' s known who was the winner \u2014 Anton or Danik. None of the games ended with a tie. Now Anton wonders, who won more games, he or Danik? Help him determine this.",
    "input": "The first line of the input contains a single integer n ( 1 \u2264 n \u2264 100 000) \u2014 the number of games played. The second line contains a string s, consisting of n uppercase English letters ' A' and ' D' \u2014 the outcome of each of the games. The i- th character of the string is equal to ' A' if the Anton won the i- th game and ' D' if Danik won the i- th game.",
    "output": "If Anton won more games than Danik, print \" Anton\" ( without quotes) in the only line of the output. If Danik won more games than Anton, print \" Danik\" ( without quotes) in the only line of the output. If Anton and Danik won the same number of games, print \" Friendship\" ( without quotes) .",
    "note": "In the first sample, Anton won 6 games, while Danik \u2014 only 1. Hence, the answer is \" Anton\" . In the second sample, Anton won 3 games and Danik won 4 games, so the answer is \" Danik\" . In the third sample, both Anton and Danik won 3 games and the answer is \" Friendship\" .",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Night at the Museum",
    "url": "https://codeforces.com/problemset/problem/731/A",
    "history": "Grigoriy, like the hero of one famous comedy film, found a job as a night security guard at the museum. At first night he received embosser and was to take stock of the whole exposition. Embosser is a special devise that allows to \" print\" the text of a plastic tape. Text is printed sequentially, character by character. The device consists of a wheel with a lowercase English letters written in a circle, static pointer to the current letter and a button that print the chosen letter. At one move it' s allowed to rotate the alphabetic wheel one step clockwise or counterclockwise. Initially, static pointer points to letter ' a' . Other letters are located as shown on the picture: After Grigoriy add new item to the base he has to print its name on the plastic tape and attach it to the corresponding exhibit. It' s not required to return the wheel to its initial position with pointer on the letter ' a' . Our hero is afraid that some exhibits may become alive and start to attack him, so he wants to print the names as fast as possible. Help him, for the given string find the minimum number of rotations of the wheel required to print it.",
    "input": "The only line of input contains the name of some exhibit \u2014 the non- empty string consisting of no more than 100 characters. It' s guaranteed that the string consists of only lowercase English letters.",
    "output": "Print one integer \u2014 the minimum number of rotations of the wheel, required to print the name given in the input.",
    "note": "To print the string from the first sample it would be optimal to perform the following sequence of rotations: from ' a' to ' z' ( 1 rotation counterclockwise) , from ' z' to ' e' ( 5 clockwise rotations) , from ' e' to ' u' ( 10 rotations counterclockwise) , from ' u' to ' s' ( 2 counterclockwise rotations) . In total, 1 + 5 + 10 + 2 = 18 rotations are required.",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Interview with Oleg",
    "url": "https://codeforces.com/problemset/problem/729/A",
    "history": "Polycarp has interviewed Oleg and has written the interview down without punctuation marks and spaces to save time. Thus, the interview is now a string s consisting of n lowercase English letters. There is a filler word ogo in Oleg' s speech. All words that can be obtained from ogo by adding go several times to the end of it are also considered to be fillers. For example, the words ogo, ogogo, ogogogo are fillers, but the words go, og, ogog, ogogog and oggo are not fillers. The fillers have maximal size, for example, for ogogoo speech we can' t consider ogo a filler and goo as a normal phrase. We should consider ogogo as a filler here. To print the interview, Polycarp has to replace each of the fillers with three asterisks. Note that a filler word is replaced with exactly three asterisks regardless of its length. Polycarp has dealt with this problem in no time. Can you do the same? The clock is ticking!",
    "input": "The first line contains a positive integer n ( 1 \u2264 n \u2264 100) \u2014 the length of the interview. The second line contains the string s of length n, consisting of lowercase English letters.",
    "output": "Print the interview text after the replacement of each of the fillers with \" * * * \" . It is allowed for the substring \" * * * \" to have several consecutive occurences.",
    "note": "The first sample contains one filler word ogogo, so the interview for printing is \" a* * * b\" . The second sample contains two fillers ogo and ogogogo. Thus, the interview is transformed to \" * * * gmg* * * \" .",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Games on a CD",
    "url": "https://codeforces.com/problemset/problem/727/E",
    "history": "Several years ago Tolya had n computer games and at some point of time he decided to burn them to CD. After that he wrote down the names of the games one after another in a circle on the CD in clockwise order. The names were distinct, the length of each name was equal to k. The names didn' t overlap. Thus, there is a cyclic string of length n\u00b7k written on the CD. Several years have passed and now Tolya can' t remember which games he burned to his CD. He knows that there were g popular games that days. All of the games he burned were among these g games, and no game was burned more than once. You have to restore any valid list of games Tolya could burn to the CD several years ago.",
    "input": "The first line of the input contains two positive integers n and k ( 1 \u2264 n \u2264 105, 1 \u2264 k \u2264 105) \u2014 the amount of games Tolya burned to the CD, and the length of each of the names. The second line of the input contains one string consisting of lowercase English letters \u2014 the string Tolya wrote on the CD, split in arbitrary place. The length of the string is n\u00b7k. It is guaranteed that the length is not greater than 106. The third line of the input contains one positive integer g ( n \u2264 g \u2264 105) \u2014 the amount of popular games that could be written on the CD. It is guaranteed that the total length of names of all popular games is not greater than 2\u00b7106. Each of the next g lines contains a single string \u2014 the name of some popular game. Each name consists of lowercase English letters and has length k. It is guaranteed that the names are distinct.",
    "output": "If there is no answer, print \" NO\" ( without quotes) . Otherwise, print two lines. In the first line print \" YES\" ( without quotes) . In the second line, print n integers \u2014 the games which names were written on the CD. You should print games in the order they could have been written on the CD, it means, in clockwise order. You can print games starting from any position. Remember, that no game was burned to the CD more than once. If there are several possible answers, print any of them.",
    "note": "",
    "topics": [
      "data structures",
      "hashing",
      "string suffix structures",
      "strings"
    ]
  },
  {
    "title": "Bill Total Value",
    "url": "https://codeforces.com/problemset/problem/727/B",
    "history": "Vasily exited from a store and now he wants to recheck the total price of all purchases in his bill. The bill is a string in which the names of the purchases and their prices are printed in a row without any spaces. Check has the format \" name1price1name2price2. . . namenpricen\" , where namei ( name of the i- th purchase) is a non- empty string of length not more than 10, consisting of lowercase English letters, and pricei ( the price of the i- th purchase) is a non- empty string, consisting of digits and dots ( decimal points) . It is possible that purchases with equal names have different prices. The price of each purchase is written in the following format. If the price is an integer number of dollars then cents are not written. Otherwise, after the number of dollars a dot ( decimal point) is written followed by cents in a two- digit format ( if number of cents is between 1 and 9 inclusively, there is a leading zero) . Also, every three digits ( from less significant to the most) in dollars are separated by dot ( decimal point) . No extra leading zeroes are allowed. The price always starts with a digit and ends with a digit. For example: \" 234\" , \" 1. 544\" , \" 149. 431. 10\" , \" 0. 99\" and \" 123. 05\" are valid prices, \" . 333\" , \" 3. 33. 11\" , \" 12. 00\" , \" . 33\" , \" 0. 1234\" and \" 1. 2\" are not valid. Write a program that will find the total price of all purchases in the given bill.",
    "input": "The only line of the input contains a non- empty string s with length not greater than 1000 \u2014 the content of the bill. It is guaranteed that the bill meets the format described above. It is guaranteed that each price in the bill is not less than one cent and not greater than 106 dollars.",
    "output": "Print the total price exactly in the same format as prices given in the input.",
    "note": "",
    "topics": [
      "expression parsing",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Hidden Word",
    "url": "https://codeforces.com/problemset/problem/725/C",
    "history": "Let\u2019s define a grid to be a set of tiles with 2 rows and 13 columns. Each tile has an English letter written in it. The letters don' t have to be unique: there might be two or more tiles with the same letter written on them. Here is an example of a grid: ABCDEFGHIJKLMNOPQRSTUVWXYZ We say that two tiles are adjacent if they share a side or a corner. In the example grid above, the tile with the letter ' A' is adjacent only to the tiles with letters ' B' , ' N' , and ' O' . A tile is not adjacent to itself. A sequence of tiles is called a path if each tile in the sequence is adjacent to the tile which follows it ( except for the last tile in the sequence, which of course has no successor) . In this example, \" ABC\" is a path, and so is \" KXWIHIJK\" . \" MAB\" is not a path because ' M' is not adjacent to ' A' . A single tile can be used more than once by a path ( though the tile cannot occupy two consecutive places in the path because no tile is adjacent to itself) . You\u2019re given a string s which consists of 27 upper- case English letters. Each English letter occurs at least once in s. Find a grid that contains a path whose tiles, viewed in the order that the path visits them, form the string s. If there\u2019s no solution, print \" Impossible\" ( without the quotes) .",
    "input": "The only line of the input contains the string s, consisting of 27 upper- case English letters. Each English letter occurs at least once in s.",
    "output": "Output two lines, each consisting of 13 upper- case English characters, representing the rows of the grid. If there are multiple solutions, print any of them. If there is no solution print \" Impossible\" .",
    "note": "",
    "topics": [
      "brute force",
      "constructive algorithms",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Dense Subsequence",
    "url": "https://codeforces.com/problemset/problem/724/D",
    "history": "You are given a string s, consisting of lowercase English letters, and the integer m. One should choose some symbols from the given string so that any contiguous subsegment of length m has at least one selected symbol. Note that here we choose positions of symbols, not the symbols themselves. Then one uses the chosen symbols to form a new string. All symbols from the chosen position should be used, but we are allowed to rearrange them in any order. Formally, we choose a subsequence of indices 1 \u2264 i1 < i2 < . . . < it \u2264 | s| . The selected sequence must meet the following condition: for every j such that 1 \u2264 j \u2264 | s| - m + 1, there must be at least one selected index that belongs to the segment [ j, j + m - 1] , i. e. there should exist a k from 1 to t, such that j \u2264 ik \u2264 j + m - 1. Then we take any permutation p of the selected indices and form a new string sip1sip2. . . sipt. Find the lexicographically smallest string, that can be obtained using this procedure.",
    "input": "The first line of the input contains a single integer m ( 1 \u2264 m \u2264 100 000) . The second line contains the string s consisting of lowercase English letters. It is guaranteed that this string is non- empty and its length doesn' t exceed 100 000. It is also guaranteed that the number m doesn' t exceed the length of the string s.",
    "output": "Print the single line containing the lexicographically smallest string, that can be obtained using the procedure described above.",
    "note": "In the first sample, one can choose the subsequence 3 and form a string \" a\" . In the second sample, one can choose the subsequence 1, 2, 4 ( symbols on this positions are ' a' , ' b' and ' a' ) and rearrange the chosen symbols to form a string \" aab\" .",
    "topics": [
      "data structures",
      "greedy",
      "strings"
    ]
  },
  {
    "title": "Text Document Analysis",
    "url": "https://codeforces.com/problemset/problem/723/B",
    "history": "Modern text editors usually show some information regarding the document being edited. For example, the number of words, the number of pages, or the number of characters. In this problem you should implement the similar functionality. You are given a string which only consists of: uppercase and lowercase English letters, underscore symbols ( they are used as separators) , parentheses ( both opening and closing) . It is guaranteed that each opening parenthesis has a succeeding closing parenthesis. Similarly, each closing parentheses has a preceding opening parentheses matching it. For each pair of matching parentheses there are no other parenthesis between them. In other words, each parenthesis in the string belongs to a matching \" opening- closing\" pair, and such pairs can' t be nested. For example, the following string is valid: \" _ Hello_ Vasya( and_ Petya) _ _ bye_ ( and_ OK) \" . Word is a maximal sequence of consecutive letters, i. e. such sequence that the first character to the left and the first character to the right of it is an underscore, a parenthesis, or it just does not exist. For example, the string above consists of seven words: \" Hello\" , \" Vasya\" , \" and\" , \" Petya\" , \" bye\" , \" and\" and \" OK\" . Write a program that finds: the length of the longest word outside the parentheses ( print 0, if there is no word outside the parentheses) , the number of words inside the parentheses ( print 0, if there is no word inside the parentheses) .",
    "input": "The first line of the input contains a single integer n ( 1 \u2264 n \u2264 255) \u2014 the length of the given string. The second line contains the string consisting of only lowercase and uppercase English letters, parentheses and underscore symbols.",
    "output": "Print two space- separated integers: the length of the longest word outside the parentheses ( print 0, if there is no word outside the parentheses) , the number of words inside the parentheses ( print 0, if there is no word inside the parentheses) .",
    "note": "In the first sample, the words \" Hello\" , \" Vasya\" and \" bye\" are outside any of the parentheses, and the words \" and\" , \" Petya\" , \" and\" and \" OK\" are inside. Note, that the word \" and\" is given twice and you should count it twice in the answer.",
    "topics": [
      "expression parsing",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Generating Sets",
    "url": "https://codeforces.com/problemset/problem/722/D",
    "history": "You are given a set Y of n distinct positive integers y1, y2, . . . , yn. Set X of n distinct positive integers x1, x2, . . . , xn is said to generate set Y if one can transform X to Y by applying some number of the following two operation to integers in X: Take any integer xi and multiply it by two, i. e. replace xi with 2\u00b7xi. Take any integer xi, multiply it by two and add one, i. e. replace xi with 2\u00b7xi + 1. Note that integers in X are not required to be distinct after each operation. Two sets of distinct integers X and Y are equal if they are equal as sets. In other words, if we write elements of the sets in the array in the increasing order, these arrays would be equal. Note, that any set of integers ( or its permutation) generates itself. You are given a set Y and have to find a set X that generates Y and the maximum element of X is mininum possible.",
    "input": "The first line of the input contains a single integer n ( 1 \u2264 n \u2264 50 000) \u2014 the number of elements in Y. The second line contains n integers y1, . . . , yn ( 1 \u2264 yi \u2264 109) , that are guaranteed to be distinct.",
    "output": "Print n integers \u2014 set of distinct integers that generate Y and the maximum element of which is minimum possible. If there are several such sets, print any of them.",
    "note": "",
    "topics": [
      "binary search",
      "data structures",
      "dfs and similar",
      "greedy",
      "strings",
      "trees"
    ]
  },
  {
    "title": "Verse Pattern",
    "url": "https://codeforces.com/problemset/problem/722/B",
    "history": "You are given a text consisting of n lines. Each line contains some space- separated words, consisting of lowercase English letters. We define a syllable as a string that contains exactly one vowel and any arbitrary number ( possibly none) of consonants. In English alphabet following letters are considered to be vowels: ' a' , ' e' , ' i' , ' o' , ' u' and ' y' . Each word of the text that contains at least one vowel can be divided into syllables. Each character should be a part of exactly one syllable. For example, the word \" mamma\" can be divided into syllables as \" ma\" and \" mma\" , \" mam\" and \" ma\" , and \" mamm\" and \" a\" . Words that consist of only consonants should be ignored. The verse patterns for the given text is a sequence of n integers p1, p2, . . . , pn. Text matches the given verse pattern if for each i from 1 to n one can divide words of the i- th line in syllables in such a way that the total number of syllables is equal to pi. You are given the text and the verse pattern. Check, if the given text matches the given verse pattern.",
    "input": "The first line of the input contains a single integer n ( 1 \u2264 n \u2264 100) \u2014 the number of lines in the text. The second line contains integers p1, . . . , pn ( 0 \u2264 pi \u2264 100) \u2014 the verse pattern. Next n lines contain the text itself. Text consists of lowercase English letters and spaces. It' s guaranteed that all lines are non- empty, each line starts and ends with a letter and words are separated by exactly one space. The length of each line doesn' t exceed 100 characters.",
    "output": "If the given text matches the given verse pattern, then print \" YES\" ( without quotes) in the only line of the output. Otherwise, print \" NO\" ( without quotes) .",
    "note": "In the first sample, one can split words into syllables in the following way: in- telco- dech al- len- geSince the word \" ch\" in the third line doesn' t contain vowels, we can ignore it. As the result we get 2 syllabels in first two lines and 3 syllables in the third one.",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Passwords",
    "url": "https://codeforces.com/problemset/problem/721/B",
    "history": "Vanya is managed to enter his favourite site Codehorses. Vanya uses n distinct passwords for sites at all, however he can' t remember which one exactly he specified during Codehorses registration. Vanya will enter passwords in order of non- decreasing their lengths, and he will enter passwords of same length in arbitrary order. Just when Vanya will have entered the correct password, he is immediately authorized on the site. Vanya will not enter any password twice. Entering any passwords takes one second for Vanya. But if Vanya will enter wrong password k times, then he is able to make the next try only 5 seconds after that. Vanya makes each try immediately, that is, at each moment when Vanya is able to enter password, he is doing that. Determine how many seconds will Vanya need to enter Codehorses in the best case for him ( if he spends minimum possible number of second) and in the worst case ( if he spends maximum possible amount of seconds) .",
    "input": "The first line of the input contains two integers n and k ( 1 \u2264 n, k \u2264 100) \u2014 the number of Vanya' s passwords and the number of failed tries, after which the access to the site is blocked for 5 seconds. The next n lines contains passwords, one per line \u2014 pairwise distinct non- empty strings consisting of latin letters and digits. Each password length does not exceed 100 characters. The last line of the input contains the Vanya' s Codehorses password. It is guaranteed that the Vanya' s Codehorses password is equal to some of his n passwords.",
    "output": "Print two integers \u2014 time ( in seconds) , Vanya needs to be authorized to Codehorses in the best case for him and in the worst case respectively.",
    "note": "Consider the first sample case. As soon as all passwords have the same length, Vanya can enter the right password at the first try as well as at the last try. If he enters it at the first try, he spends exactly 1 second. Thus in the best case the answer is 1. If, at the other hand, he enters it at the last try, he enters another 4 passwords before. He spends 2 seconds to enter first 2 passwords, then he waits 5 seconds as soon as he made 2 wrong tries. Then he spends 2 more seconds to enter 2 wrong passwords, again waits 5 seconds and, finally, enters the correct password spending 1 more second. In summary in the worst case he is able to be authorized in 15 seconds. Consider the second sample case. There is no way of entering passwords and get the access to the site blocked. As soon as the required password has length of 2, Vanya enters all passwords of length 1 anyway, spending 2 seconds for that. Then, in the best case, he immediately enters the correct password and the answer for the best case is 3, but in the worst case he enters wrong password of length 2 and only then the right one, spending 4 seconds at all.",
    "topics": [
      "implementation",
      "math",
      "sortings",
      "strings"
    ]
  },
  {
    "title": "Memory and Trident",
    "url": "https://codeforces.com/problemset/problem/712/B",
    "history": "Memory is performing a walk on the two- dimensional plane, starting at the origin. He is given a string s with his directions for motion: An ' L' indicates he should move one unit left. An ' R' indicates he should move one unit right. A ' U' indicates he should move one unit up. A ' D' indicates he should move one unit down. But now Memory wants to end at the origin. To do this, he has a special trident. This trident can replace any character in s with any of ' L' , ' R' , ' U' , or ' D' . However, because he doesn' t want to wear out the trident, he wants to make the minimum number of edits possible. Please tell Memory what is the minimum number of changes he needs to make to produce a string that, when walked, will end at the origin, or if there is no such string.",
    "input": "The first and only line contains the string s ( 1 \u2264 | s| \u2264 100 000) \u2014 the instructions Memory is given.",
    "output": "If there is a string satisfying the conditions, output a single integer \u2014 the minimum number of edits required. In case it' s not possible to change the sequence in such a way that it will bring Memory to to the origin, output - 1.",
    "note": "In the first sample test, Memory is told to walk right, then right, then up. It is easy to see that it is impossible to edit these instructions to form a valid walk. In the second sample test, Memory is told to walk up, then down, then up, then right. One possible solution is to change s to \" LDUR\" . This string uses 1 edit, which is the minimum possible. It also ends at the origin.",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "String Set Queries",
    "url": "https://codeforces.com/problemset/problem/710/F",
    "history": "You should process m queries over a set D of strings. Each query is one of three kinds: Add a string s to the set D. It is guaranteed that the string s was not added before. Delete a string s from the set D. It is guaranteed that the string s is in the set D. For the given string s find the number of occurrences of the strings from the set D. If some string p from D has several occurrences in s you should count all of them. Note that you should solve the problem in online mode. It means that you can' t read the whole input at once. You can read each query only after writing the answer for the last query of the third type. Use functions fflush in C+ + and BufferedWriter. flush in Java languages after each writing in your program.",
    "input": "The first line contains integer m ( 1 \u2264 m \u2264 3\u00b7105) \u2014 the number of queries. Each of the next m lines contains integer t ( 1 \u2264 t \u2264 3) and nonempty string s \u2014 the kind of the query and the string to process. All strings consist of only lowercase English letters. The sum of lengths of all strings in the input will not exceed 3\u00b7105.",
    "output": "For each query of the third kind print the only integer c \u2014 the desired number of occurrences in the string s.",
    "note": "",
    "topics": [
      "brute force",
      "data structures",
      "hashing",
      "interactive",
      "string suffix structures",
      "strings"
    ]
  },
  {
    "title": "Letters Cyclic Shift",
    "url": "https://codeforces.com/problemset/problem/708/A",
    "history": "You are given a non- empty string s consisting of lowercase English letters. You have to pick exactly one non- empty substring of s and shift all its letters ' z' ' y' ' x' ' b' ' a' ' z' . In other words, each character is replaced with the previous character of English alphabet and ' a' is replaced with ' z' . What is the lexicographically minimum string that can be obtained from s by performing this shift exactly once?",
    "input": "The only line of the input contains the string s ( 1 \u2264 | s| \u2264 100 000) consisting of lowercase English letters.",
    "output": "Print the lexicographically minimum string that can be obtained from s by shifting letters of exactly one non- empty substring.",
    "note": "String s is lexicographically smaller than some other string t of the same length if there exists some 1 \u2264 i \u2264 | s| , such that s1 = t1, s2 = t2, . . . , si - 1 = ti - 1, and si < ti.",
    "topics": [
      "constructive algorithms",
      "greedy",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Hard problem",
    "url": "https://codeforces.com/problemset/problem/706/C",
    "history": "Vasiliy is fond of solving different tasks. Today he found one he wasn' t able to solve himself, so he asks you to help. Vasiliy is given n strings consisting of lowercase English letters. He wants them to be sorted in lexicographical order ( as in the dictionary) , but he is not allowed to swap any of them. The only operation he is allowed to do is to reverse any of them ( first character becomes last, second becomes one before last and so on) . To reverse the i- th string Vasiliy has to spent ci units of energy. He is interested in the minimum amount of energy he has to spent in order to have strings sorted in lexicographical order. String A is lexicographically smaller than string B if it is shorter than B ( | A| < | B| ) and is its prefix, or if none of them is a prefix of the other and at the first position where they differ character in A is smaller than the character in B. For the purpose of this problem, two equal strings nearby do not break the condition of sequence being sorted lexicographically.",
    "input": "The first line of the input contains a single integer n ( 2 \u2264 n \u2264 100 000) \u2014 the number of strings. The second line contains n integers ci ( 0 \u2264 ci \u2264 109) , the i- th of them is equal to the amount of energy Vasiliy has to spent in order to reverse the i- th string. Then follow n lines, each containing a string consisting of lowercase English letters. The total length of these strings doesn' t exceed 100 000.",
    "output": "If it is impossible to reverse some of the strings such that they will be located in lexicographical order, print - 1. Otherwise, print the minimum total amount of energy Vasiliy has to spent.",
    "note": "In the second sample one has to reverse string 2 or string 3. To amount of energy required to reverse the string 3 is smaller. In the third sample, both strings do not change after reverse and they go in the wrong order, so the answer is - 1. In the fourth sample, both strings consists of characters ' a' only, but in the sorted order string \" aa\" should go before string \" aaa\" , thus the answer is - 1.",
    "topics": [
      "dp",
      "strings"
    ]
  },
  {
    "title": "They Are Everywhere",
    "url": "https://codeforces.com/problemset/problem/701/C",
    "history": "Sergei B. , the young coach of Pokemons, has found the big house which consists of n flats ordered in a row from left to right. It is possible to enter each flat from the street. It is possible to go out from each flat. Also, each flat is connected with the flat to the left and the flat to the right. Flat number 1 is only connected with the flat number 2 and the flat number n is only connected with the flat number n - 1. There is exactly one Pokemon of some type in each of these flats. Sergei B. asked residents of the house to let him enter their flats in order to catch Pokemons. After consulting the residents of the house decided to let Sergei B. enter one flat from the street, visit several flats and then go out from some flat. But they won' t let him visit the same flat more than once. Sergei B. was very pleased, and now he wants to visit as few flats as possible in order to collect Pokemons of all types that appear in this house. Your task is to help him and determine this minimum number of flats he has to visit.",
    "input": "The first line contains the integer n ( 1 \u2264 n \u2264 100 000) \u2014 the number of flats in the house. The second line contains the row s with the length n, it consists of uppercase and lowercase letters of English alphabet, the i- th letter equals the type of Pokemon, which is in the flat number i.",
    "output": "Print the minimum number of flats which Sergei B. should visit in order to catch Pokemons of all types which there are in the house.",
    "note": "In the first test Sergei B. can begin, for example, from the flat number 1 and end in the flat number 2. In the second test Sergei B. can begin, for example, from the flat number 4 and end in the flat number 6. In the third test Sergei B. must begin from the flat number 2 and end in the flat number 6.",
    "topics": [
      "binary search",
      "strings",
      "two pointers"
    ]
  },
  {
    "title": "Cool Slogans",
    "url": "https://codeforces.com/problemset/problem/700/E",
    "history": "Bomboslav set up a branding agency and now helps companies to create new logos and advertising slogans. In term of this problems, slogan of the company should be a non- empty substring of its name. For example, if the company name is \" hornsandhoofs\" , then substrings \" sand\" and \" hor\" could be its slogans, while strings \" e\" and \" hornss\" can not. Sometimes the company performs rebranding and changes its slogan. Slogan A is considered to be cooler than slogan B if B appears in A as a substring at least twice ( this occurrences are allowed to overlap) . For example, slogan A = \" abacaba\" is cooler than slogan B = \" ba\" , slogan A = \" abcbcbe\" is cooler than slogan B = \" bcb\" , but slogan A = \" aaaaaa\" is not cooler than slogan B = \" aba\" . You are given the company name w and your task is to help Bomboslav determine the length of the longest sequence of slogans s1, s2, . . . , sk, such that any slogan in the sequence is cooler than the previous one.",
    "input": "The first line of the input contains a single integer n ( 1 \u2264 n \u2264 200 000) \u2014 the length of the company name that asks Bomboslav to help. The second line contains the string w of length n, that consists of lowercase English letters.",
    "output": "Print a single integer \u2014 the maximum possible length of the sequence of slogans of the company named w, such that any slogan in the sequence ( except the first one) is cooler than the previous",
    "note": "",
    "topics": [
      "string suffix structures",
      "strings"
    ]
  },
  {
    "title": "Barnicle",
    "url": "https://codeforces.com/problemset/problem/697/B",
    "history": "Barney is standing in a bar and starring at a pretty girl. He wants to shoot her with his heart arrow but he needs to know the distance between him and the girl to make his shot accurate. Barney asked the bar tender Carl about this distance value, but Carl was so busy talking to the customers so he wrote the distance value ( it' s a real number) on a napkin. The problem is that he wrote it in scientific notation. The scientific notation of some real number x is the notation of form AeB, where A is a real number and B is an integer and x = A \u00d7 10B is true. In our case A is between 0 and 9 and B is non- negative. Barney doesn' t know anything about scientific notation ( as well as anything scientific at all) . So he asked you to tell him the distance value in usual decimal representation with minimal number of digits after the decimal point ( and no decimal point if it is an integer) . See the output format for better understanding.",
    "input": "The first and only line of input contains a single string of form a. deb where a, d and b are integers and e is usual character ' e' ( 0 \u2264 a \u2264 9, 0 \u2264 d < 10100, 0 \u2264 b \u2264 100) \u2014 the scientific notation of the desired distance value. a and b contain no leading zeros and d contains no trailing zeros ( but may be equal to 0) . Also, b can not be non- zero if a is zero.",
    "output": "Print the only real number x ( the desired distance value) in the only line in its decimal notation. Thus if x is an integer, print it' s integer value without decimal part and decimal point and without leading zeroes. Otherwise print x in a form of p. q such that p is an integer that have no leading zeroes ( but may be equal to zero) , and q is an integer that have no trailing zeroes ( and may not be equal to zero) .",
    "note": "",
    "topics": [
      "brute force",
      "implementation",
      "math",
      "strings"
    ]
  },
  {
    "title": "Legen...",
    "url": "https://codeforces.com/problemset/problem/696/D",
    "history": "Barney was hanging out with Nora for a while and now he thinks he may have feelings for her. Barney wants to send her a cheesy text message and wants to make her as happy as possible. Initially, happiness level of Nora is 0. Nora loves some pickup lines like \" I' m falling for you\" and stuff. Totally, she knows n pickup lines, each consisting only of lowercase English letters, also some of them may be equal ( in writing, but different in pronouncing or meaning though) . Every time Nora sees i- th pickup line as a consecutive subsequence of Barney' s text message her happiness level increases by ai. These substrings may overlap, for example, Nora will see the pickup line aa twice and the pickup line ab once in text message aaab. Due to texting app limits, Barney' s text may have up to l characters. Barney asked you to help him make Nora as much happy as possible, it' s gonna be legen. . .",
    "input": "The first line of input contains two integers n and l ( 1 \u2264 n \u2264 200, 1 \u2264 l \u2264 1014) \u2014 the number of pickup lines and the maximum length of Barney' s text. The second line contains n integers a1, a2, . . . , an ( 1 \u2264 ai \u2264 100) , meaning that Nora' s happiness level increases by ai after every time seeing i- th pickup line. The next n lines contain the pickup lines. i- th of them contains a single string si consisting of only English lowercase letter. Summary length of all pickup lines does not exceed 200. All strings are not empty.",
    "output": "Print the only integer \u2014 the maximum possible value of Nora' s happiness level after reading Barney' s text.",
    "note": "An optimal answer for the first sample case is hearth containing each pickup line exactly once. An optimal answer for the second sample case is artart.",
    "topics": [
      "data structures",
      "dp",
      "matrices",
      "strings"
    ]
  },
  {
    "title": "Exponential notation",
    "url": "https://codeforces.com/problemset/problem/691/C",
    "history": "You are given a positive decimal number x. Your task is to convert it to the \" simple exponential notation\" . Let x = a\u00b710b, where 1 \u2264 a < 10, then in general case the \" simple exponential notation\" looks like \" aEb\" . If b equals to zero, the part \" Eb\" should be skipped. If a is an integer, it should be written without decimal point. Also there should not be extra zeroes in a and b.",
    "input": "The only line contains the positive decimal number x. The length of the line will not exceed 106. Note that you are given too large number, so you can' t use standard built- in data types \" float\" , \" double\" and other.",
    "output": "Print the only line \u2014 the \" simple exponential notation\" of the given number x.",
    "note": "",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "s-palindrome",
    "url": "https://codeforces.com/problemset/problem/691/B",
    "history": "Let' s call a string \" s- palindrome\" if it is symmetric about the middle of the string. For example, the string \" oHo\" is \" s- palindrome\" , but the string \" aa\" is not. The string \" aa\" is not \" s- palindrome\" , because the second half of it is not a mirror reflection of the first half. English alphabet You are given a string s. Check if the string is \" s- palindrome\" .",
    "input": "The only line contains the string s ( 1 \u2264 | s| \u2264 1000) which consists of only English letters.",
    "output": "Print \" TAK\" if the string s is \" s- palindrome\" and \" NIE\" otherwise.",
    "note": "",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Alyona and Strings",
    "url": "https://codeforces.com/problemset/problem/682/D",
    "history": "After returned from forest, Alyona started reading a book. She noticed strings s and t, lengths of which are n and m respectively. As usual, reading bored Alyona and she decided to pay her attention to strings s and t, which she considered very similar. Alyona has her favourite positive integer k and because she is too small, k does not exceed 10. The girl wants now to choose k disjoint non- empty substrings of string s such that these strings appear as disjoint substrings of string t and in the same order as they do in string s. She is also interested in that their length is maximum possible among all variants. Formally, Alyona wants to find a sequence of k non- empty strings p1, p2, p3, . . . , pk satisfying following conditions: s can be represented as concatenation a1p1a2p2. . . akpkak + 1, where a1, a2, . . . , ak + 1 is a sequence of arbitrary strings ( some of them may be possibly empty) ; t can be represented as concatenation b1p1b2p2. . . bkpkbk + 1, where b1, b2, . . . , bk + 1 is a sequence of arbitrary strings ( some of them may be possibly empty) ; sum of the lengths of strings in sequence is maximum possible. Please help Alyona solve this complicated problem and find at least the sum of the lengths of the strings in a desired sequence. A substring of a string is a subsequence of consecutive characters of the string.",
    "input": "In the first line of the input three integers n, m, k ( 1 \u2264 n, m \u2264 1000, 1 \u2264 k \u2264 10) are given \u2014 the length of the string s, the length of the string t and Alyona' s favourite number respectively. The second line of the input contains string s, consisting of lowercase English letters. The third line of the input contains string t, consisting of lowercase English letters.",
    "output": "In the only line print the only non- negative integer \u2014 the sum of the lengths of the strings in a desired sequence. It is guaranteed, that at least one desired sequence exists.",
    "note": "The following image describes the answer for the second sample case:",
    "topics": [
      "dp",
      "strings"
    ]
  },
  {
    "title": "Vanya and Label",
    "url": "https://codeforces.com/problemset/problem/677/C",
    "history": "While walking down the street Vanya saw a label \" Hide Seek\" . Because he is a programmer, he used as a bitwise AND for these two words represented as a integers in base 64 and got new word. Now Vanya thinks of some string s and wants to know the number of pairs of words of length | s| ( length of s) , such that their bitwise AND is equal to s. As this number can be large, output it modulo 109 + 7. To represent the string as a number in numeral system with base 64 Vanya uses the following rules: digits from ' 0' to ' 9' correspond to integers from 0 to 9; letters from ' A' to ' Z' correspond to integers from 10 to 35; letters from ' a' to ' z' correspond to integers from 36 to 61; letter ' - ' correspond to integer 62; letter ' _ ' correspond to integer 63.",
    "input": "The only line of the input contains a single word s ( 1 \u2264 | s| \u2264 100 000) , consisting of digits, lowercase and uppercase English letters, characters ' - ' and ' _ ' .",
    "output": "Print a single integer \u2014 the number of possible pairs of words, such that their bitwise AND is equal to string s modulo 109 + 7.",
    "note": "For a detailed definition of bitwise AND we recommend to take a look in the corresponding article in Wikipedia. In the first sample, there are 3 possible solutions: z _ = 61 63 = 61 = z _ z = 63 61 = 61 = z z z = 61 61 = 61 = z",
    "topics": [
      "bitmasks",
      "combinatorics",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Vasya and String",
    "url": "https://codeforces.com/problemset/problem/676/C",
    "history": "High school student Vasya got a string of length n as a birthday present. This string consists of letters ' a' and ' b' only. Vasya denotes beauty of the string as the maximum length of a substring ( consecutive subsequence) consisting of equal letters. Vasya can change no more than k characters of the original string. What is the maximum beauty of the string he can achieve?",
    "input": "The first line of the input contains two integers n and k ( 1 \u2264 n \u2264 100 000, 0 \u2264 k \u2264 n) \u2014 the length of the string and the maximum number of characters to change. The second line contains the string, consisting of letters ' a' and ' b' only.",
    "output": "Print the only integer \u2014 the maximum beauty of the string Vasya can achieve by changing no more than k characters.",
    "note": "In the first sample, Vasya can obtain both strings \" aaaa\" and \" bbbb\" . In the second sample, the optimal answer is obtained with the string \" aaaaabaa\" or with the string \" aabaaaaa\" .",
    "topics": [
      "binary search",
      "dp",
      "strings",
      "two pointers"
    ]
  },
  {
    "title": "Different is Good",
    "url": "https://codeforces.com/problemset/problem/672/B",
    "history": "A wise man told Kerem \" Different is good\" once, so Kerem wants all things in his life to be different. Kerem recently got a string s consisting of lowercase English letters. Since Kerem likes it when things are different, he wants all substrings of his string s to be distinct. Substring is a string formed by some number of consecutive characters of the string. For example, string \" aba\" has substrings \" \" ( empty substring) , \" a\" , \" b\" , \" a\" , \" ab\" , \" ba\" , \" aba\" . If string s has at least two equal substrings then Kerem will change characters at some positions to some other lowercase English letters. Changing characters is a very tiring job, so Kerem want to perform as few changes as possible. Your task is to find the minimum number of changes needed to make all the substrings of the given string distinct, or determine that it is impossible.",
    "input": "The first line of the input contains an integer n ( 1 \u2264 n \u2264 100 000) \u2014 the length of the string s. The second line contains the string s of length n consisting of only lowercase English letters.",
    "output": "If it' s impossible to change the string s such that all its substring are distinct print - 1. Otherwise print the minimum required number of changes.",
    "note": "In the first sample one of the possible solutions is to change the first character to ' b' . In the second sample, one may change the first character to ' a' and second character to ' b' , so the string becomes \" abko\" .",
    "topics": [
      "constructive algorithms",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Restore a Number",
    "url": "https://codeforces.com/problemset/problem/670/F",
    "history": "Vasya decided to pass a very large integer n to Kate. First, he wrote that number as a string, then he appended to the right integer k \u2014 the number of digits in n. Magically, all the numbers were shuffled in arbitrary order while this note was passed to Kate. The only thing that Vasya remembers, is a non- empty substring of n ( a substring of n is a sequence of consecutive digits of the number n) . Vasya knows that there may be more than one way to restore the number n. Your task is to find the smallest possible initial integer n. Note that decimal representation of number n contained no leading zeroes, except the case the integer n was equal to zero itself ( in this case a single digit 0 was used) .",
    "input": "The first line of the input contains the string received by Kate. The number of digits in this string does not exceed 1 000 000. The second line contains the substring of n which Vasya remembers. This string can contain leading zeroes. It is guaranteed that the input data is correct, and the answer always exists.",
    "output": "Print the smalles integer n which Vasya could pass to Kate.",
    "note": "",
    "topics": [
      "brute force",
      "constructive algorithms",
      "strings"
    ]
  },
  {
    "title": "Correct Bracket Sequence Editor",
    "url": "https://codeforces.com/problemset/problem/670/E",
    "history": "Recently Polycarp started to develop a text editor that works only with correct bracket sequences ( abbreviated as CBS) . Note that a bracket sequence is correct if it is possible to get a correct mathematical expression by adding \" + \" - s and \" 1\" - s to it. For example, sequences \" ( ( ) ) ( ) \" , \" ( ) \" and \" ( ( ) ( ( ) ) ) \" are correct, while \" ) ( \" , \" ( ( ) \" and \" ( ( ) ) ) ( \" are not. Each bracket in CBS has a pair. For example, in \" ( ( ) ( ( ) ) ) \" : 1st bracket is paired with 8th, 2d bracket is paired with 3d, 3d bracket is paired with 2d, 4th bracket is paired with 7th, 5th bracket is paired with 6th, 6th bracket is paired with 5th, 7th bracket is paired with 4th, 8th bracket is paired with 1st. Polycarp' s editor currently supports only three operations during the use of CBS. The cursor in the editor takes the whole position of one of the brackets ( not the position between the brackets! ) . There are three operations being supported: \u00abL\u00bb \u2014 move the cursor one position to the left, \u00abR\u00bb \u2014 move the cursor one position to the right, \u00abD\u00bb \u2014 delete the bracket in which the cursor is located, delete the bracket it' s paired to and all brackets between them ( that is, delete a substring between the bracket in which the cursor is located and the one it' s paired to) . After the operation \" D\" the cursor moves to the nearest bracket to the right ( of course, among the non- deleted) . If there is no such bracket ( that is, the suffix of the CBS was deleted) , then the cursor moves to the nearest bracket to the left ( of course, among the non- deleted) . There are pictures illustrated several usages of operation \" D\" below. All incorrect operations ( shift cursor over the end of CBS, delete the whole CBS, etc. ) are not supported by Polycarp' s editor. Polycarp is very proud of his development, can you implement the functionality of his editor?",
    "input": "The first line contains three positive integers n, m and p ( 2 \u2264 n \u2264 500 000, 1 \u2264 m \u2264 500 000, 1 \u2264 p \u2264 n) \u2014 the number of brackets in the correct bracket sequence, the number of operations and the initial position of cursor. Positions in the sequence are numbered from left to right, starting from one. It is guaranteed that n is even. It is followed by the string of n characters \" ( \" and \" ) \" forming the correct bracket sequence. Then follow a string of m characters \" L\" , \" R\" and \" D\" \u2014 a sequence of the operations. Operations are carried out one by one from the first to the last. It is guaranteed that the given operations never move the cursor outside the bracket sequence, as well as the fact that after all operations a bracket sequence will be non- empty.",
    "output": "Print the correct bracket sequence, obtained as a result of applying all operations to the initial sequence.",
    "note": "In the first sample the cursor is initially at position 5. Consider actions of the editor: command \" R\" \u2014 the cursor moves to the position 6 on the right; command \" D\" \u2014 the deletion of brackets from the position 5 to the position 6. After that CBS takes the form ( ( ) ) ( ) , the cursor is at the position 5; command \" L\" \u2014 the cursor moves to the position 4 on the left; command \" D\" \u2014 the deletion of brackets from the position 1 to the position 4. After that CBS takes the form ( ) , the cursor is at the position 1. Thus, the answer is equal to ( ) .",
    "topics": [
      "data structures",
      "dsu",
      "strings"
    ]
  },
  {
    "title": "Codeword",
    "url": "https://codeforces.com/problemset/problem/666/C",
    "history": "The famous sculptor Cicasso is a Reberlandian spy! These is breaking news in Berlandian papers today. And now the sculptor is hiding. This time you give the shelter to the maestro. You have a protected bunker and you provide it to your friend. You set the security system in such way that only you can open the bunker. To open it one should solve the problem which is hard for others but is simple for you. Every day the bunker generates a codeword s. Every time someone wants to enter the bunker, integer n appears on the screen. As the answer one should enter another integer \u2014 the residue modulo 109 + 7 of the number of strings of length n that consist only of lowercase English letters and contain the string s as the subsequence. The subsequence of string a is a string b that can be derived from the string a by removing some symbols from it ( maybe none or all of them) . In particular any string is the subsequence of itself. For example, the string \" cfo\" is the subsequence of the string \" codeforces\" . You haven' t implemented the algorithm that calculates the correct answers yet and you should do that ASAP.",
    "input": "The first line contains integer m ( 1 \u2264 m \u2264 105) \u2014 the number of the events in the test case. The second line contains nonempty string s \u2014 the string generated by the bunker for the current day. The next m lines contain the description of the events. The description starts from integer t \u2014 the type of the event. If t = 1 consider a new day has come and now a new string s is used. In that case the same line contains a new value of the string s. If t = 2 integer n is given ( 1 \u2264 n \u2264 105) . This event means that it' s needed to find the answer for the current string s and the value n. The sum of lengths of all generated strings doesn' t exceed 105. All of the given strings consist only of lowercase English letters.",
    "output": "For each query of the type 2 print the answer modulo 109 + 7 on the separate line.",
    "note": "In the first event words of the form \" a? \" and \" ? a\" are counted, where ? is an arbitrary symbol. There are 26 words of each of these types, but the word \" aa\" satisfies both patterns, so the answer is 51.",
    "topics": [
      "combinatorics",
      "strings"
    ]
  },
  {
    "title": "Reberland Linguistics",
    "url": "https://codeforces.com/problemset/problem/666/A",
    "history": "First- rate specialists graduate from Berland State Institute of Peace and Friendship. You are one of the most talented students in this university. The education is not easy because you need to have fundamental knowledge in different areas, which sometimes are not related to each other. For example, you should know linguistics very well. You learn a structure of Reberland language as foreign language. In this language words are constructed according to the following rules. First you need to choose the \" root\" of the word \u2014 some string which has more than 4 letters. Then several strings with the length 2 or 3 symbols are appended to this word. The only restriction \u2014 it is not allowed to append the same string twice in a row. All these strings are considered to be suffixes of the word ( this time we use word \" suffix\" to describe a morpheme but not the few last characters of the string as you may used to) . Here is one exercise that you have found in your task list. You are given the word s. Find all distinct strings with the length 2 or 3, which can be suffixes of this word according to the word constructing rules in Reberland language. Two strings are considered distinct if they have different length or there is a position in which corresponding characters do not match. Let' s look at the example: the word abacabaca is given. This word can be obtained in the following ways: , where the root of the word is overlined, and suffixes are marked by \" corners\" . Thus, the set of possible suffixes for this word is aca, ba, ca.",
    "input": "The only line contains a string s ( 5 \u2264 | s| \u2264 104) consisting of lowercase English letters.",
    "output": "On the first line print integer k \u2014 a number of distinct possible suffixes. On the next k lines print suffixes. Print suffixes in lexicographical ( alphabetical) order.",
    "note": "The first test was analysed in the problem statement. In the second example the length of the string equals 5. The length of the root equals 5, so no string can be used as a suffix.",
    "topics": [
      "dp",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Beautiful Subarrays",
    "url": "https://codeforces.com/problemset/problem/665/E",
    "history": "One day, ZS the Coder wrote down an array of integers a with elements a1, a2, . . . , an. A subarray of the array a is a sequence al, al + 1, . . . , ar for some integers ( l, r) such that 1 \u2264 l \u2264 r \u2264 n. ZS the Coder thinks that a subarray of a is beautiful if the bitwise xor of all the elements in the subarray is at least k. Help ZS the Coder find the number of beautiful subarrays of a!",
    "input": "The first line contains two integers n and k ( 1 \u2264 n \u2264 106, 1 \u2264 k \u2264 109) \u2014 the number of elements in the array a and the value of the parameter k. The second line contains n integers ai ( 0 \u2264 ai \u2264 109) \u2014 the elements of the array a.",
    "output": "Print the only integer c \u2014 the number of beautiful subarrays of the array a.",
    "note": "",
    "topics": [
      "data structures",
      "divide and conquer",
      "strings",
      "trees"
    ]
  },
  {
    "title": "Simple Strings",
    "url": "https://codeforces.com/problemset/problem/665/C",
    "history": "zscoder loves simple strings! A string t is called simple if every pair of adjacent characters are distinct. For example ab, aba, zscoder are simple whereas aa, add are not simple. zscoder is given a string s. He wants to change a minimum number of characters so that the string s becomes simple. Help him with this task!",
    "input": "The only line contains the string s ( 1 \u2264 | s| \u2264 2\u00b7105) \u2014 the string given to zscoder. The string s consists of only lowercase English letters.",
    "output": "Print the simple string s' \u2014 the string s after the minimal number of changes. If there are multiple solutions, you may output any of them. Note that the string s' should also consist of only lowercase English letters.",
    "note": "",
    "topics": [
      "dp",
      "greedy",
      "strings"
    ]
  },
  {
    "title": "Paper task",
    "url": "https://codeforces.com/problemset/problem/653/F",
    "history": "Alex was programming while Valentina ( his toddler daughter) got there and started asking many questions about the round brackets ( or parenthesis) in the code. He explained her a bit and when she got it he gave her a task in order to finish his code on time. For the purpose of this problem we consider only strings consisting of opening and closing round brackets, that is characters ' ( ' and ' ) ' . The sequence of brackets is called correct if: it' s empty; it' s a correct sequence of brackets, enclosed in a pair of opening and closing brackets; it' s a concatenation of two correct sequences of brackets. For example, the sequences \" ( ) ( ) \" and \" ( ( ( ) ) ) ( ( ) ) \" are correct, while \" ) ( ( ) \" , \" ( ( ( ( ( \" and \" ( ) ) \" are not. Alex took a piece of paper, wrote a string s consisting of brackets and asked Valentina to count the number of distinct non- empty substrings of s that are correct sequences of brackets. In other words, her task is to count the number of non- empty correct sequences of brackets that occur in a string s as a substring ( don' t mix up with subsequences) . When Valentina finished the task, Alex noticed he doesn' t know the answer. Help him don' t loose face in front of Valentina and solve the problem!",
    "input": "The first line of the input contains an integer n ( 1 \u2264 n \u2264 500 000) \u2014 the length of the string s. The second line contains a string s of length n consisting of only ' ( ' and ' ) ' .",
    "output": "Print the number of distinct non- empty correct sequences that occur in s as substring.",
    "note": "In the first sample, there are 5 distinct substrings we should count: \" ( ) \" , \" ( ) ( ) \" , \" ( ) ( ) ( ) \" , \" ( ) ( ) ( ) ( ) \" and \" ( ) ( ) ( ) ( ) ( ) \" . In the second sample, there are 3 distinct substrings we should count: \" ( ) \" , \" ( ( ) ) \" and \" ( ( ) ) ( ) \" .",
    "topics": [
      "data structures",
      "string suffix structures",
      "strings"
    ]
  },
  {
    "title": "Bear and Compressing",
    "url": "https://codeforces.com/problemset/problem/653/B",
    "history": "Limak is a little polar bear. Polar bears hate long strings and thus they like to compress them. You should also know that Limak is so young that he knows only first six letters of the English alphabet: ' a' , ' b' , ' c' , ' d' , ' e' and ' f' . You are given a set of q possible operations. Limak can perform them in any order, any operation may be applied any number of times. The i- th operation is described by a string ai of length two and a string bi of length one. No two of q possible operations have the same string ai. When Limak has a string s he can perform the i- th operation on s if the first two letters of s match a two- letter string ai. Performing the i- th operation removes first two letters of s and inserts there a string bi. See the notes section for further clarification. You may note that performing an operation decreases the length of a string s exactly by 1. Also, for some sets of operations there may be a string that cannot be compressed any further, because the first two letters don' t match any ai. Limak wants to start with a string of length n and perform n - 1 operations to finally get a one- letter string \" a\" . In how many ways can he choose the starting string to be able to get \" a\" ? Remember that Limak can use only letters he knows.",
    "input": "The first line contains two integers n and q ( 2 \u2264 n \u2264 6, 1 \u2264 q \u2264 36) \u2014 the length of the initial string and the number of available operations. The next q lines describe the possible operations. The i- th of them contains two strings ai and bi ( | ai| = 2, | bi| = 1) . It' s guaranteed that ai = \u0338 aj for i = \u0338 j and that all ai and bi consist of only first six lowercase English letters.",
    "output": "Print the number of strings of length n that Limak will be able to transform to string \" a\" by applying only operations given in the input.",
    "note": "In the first sample, we count initial strings of length 3 from which Limak can get a required string \" a\" . There are 4 such strings: \" abb\" , \" cab\" , \" cca\" , \" eea\" . The first one Limak can compress using operation 1 two times ( changing \" ab\" to a single \" a\" ) . The first operation would change \" abb\" to \" ab\" and the second operation would change \" ab\" to \" a\" . Other three strings may be compressed as follows: \" cab\" \" ab\" \" a\" \" cca\" \" ca\" \" a\" \" eea\" \" ca\" \" a\" In the second sample, the only correct initial string is \" eb\" because it can be immediately compressed to \" a\" .",
    "topics": [
      "brute force",
      "dfs and similar",
      "dp",
      "strings"
    ]
  },
  {
    "title": "Intellectual Inquiry",
    "url": "https://codeforces.com/problemset/problem/645/E",
    "history": "After getting kicked out of her reporting job for not knowing the alphabet, Bessie has decided to attend school at the Fillet and Eggs Eater Academy. She has been making good progress with her studies and now knows the first k English letters. Each morning, Bessie travels to school along a sidewalk consisting of m + n tiles. In order to help Bessie review, Mr. Moozing has labeled each of the first m sidewalk tiles with one of the first k lowercase English letters, spelling out a string t. Mr. Moozing, impressed by Bessie' s extensive knowledge of farm animals, plans to let her finish labeling the last n tiles of the sidewalk by herself. Consider the resulting string s ( | s| = m + n) consisting of letters labeled on tiles in order from home to school. For any sequence of indices p1 < p2 < . . . < pq we can define subsequence of the string s as string sp1sp2. . . spq. Two subsequences are considered to be distinct if they differ as strings. Bessie wants to label the remaining part of the sidewalk such that the number of distinct subsequences of tiles is maximum possible. However, since Bessie hasn' t even finished learning the alphabet, she needs your help! Note that empty subsequence also counts.",
    "input": "The first line of the input contains two integers n and k ( 0 \u2264 n \u2264 1 000 000, 1 \u2264 k \u2264 26) . The second line contains a string t ( | t| = m, 1 \u2264 m \u2264 1 000 000) consisting of only first k lowercase English letters.",
    "output": "Determine the maximum number of distinct subsequences Bessie can form after labeling the last n sidewalk tiles each with one of the first k lowercase English letters. Since this number can be rather large, you should print it modulo 109 + 7. Please note, that you are not asked to maximize the remainder modulo 109 + 7! The goal is to maximize the initial value and then print the remainder.",
    "note": "In the first sample, the optimal labeling gives 8 different subsequences: \" \" ( the empty string) , \" a\" , \" c\" , \" b\" , \" ac\" , \" ab\" , \" cb\" , and \" acb\" . In the second sample, the entire sidewalk is already labeled. The are 10 possible different subsequences: \" \" ( the empty string) , \" a\" , \" b\" , \" aa\" , \" ab\" , \" ba\" , \" aaa\" , \" aab\" , \" aba\" , and \" aaba\" . Note that some strings, including \" aa\" , can be obtained with multiple sequences of tiles, but are only counted once.",
    "topics": [
      "dp",
      "greedy",
      "strings"
    ]
  },
  {
    "title": "Hostname Aliases",
    "url": "https://codeforces.com/problemset/problem/644/C",
    "history": "There are some websites that are accessible through several different addresses. For example, for a long time Codeforces was accessible with two hostnames codeforces. com and codeforces. ru. You are given a list of page addresses being queried. For simplicity we consider all addresses to have the form http: / / < hostname> [ / < path> ] , where: < hostname> \u2014 server name ( consists of words and maybe some dots separating them) , / < path> \u2014 optional part, where < path> consists of words separated by slashes. We consider two < hostname> to correspond to one website if for each query to the first < hostname> there will be exactly the same query to the second one and vice versa \u2014 for each query to the second < hostname> there will be the same query to the first one. Take a look at the samples for further clarifications. Your goal is to determine the groups of server names that correspond to one website. Ignore groups consisting of the only server name. Please note, that according to the above definition queries http: / / < hostname> and http: / / < hostname> / are different.",
    "input": "The first line of the input contains a single integer n ( 1 \u2264 n \u2264 100 000) \u2014 the number of page queries. Then follow n lines each containing exactly one address. Each address is of the form http: / / < hostname> [ / < path> ] , where: < hostname> consists of lowercase English letters and dots, there are no two consecutive dots, < hostname> doesn' t start or finish with a dot. The length of < hostname> is positive and doesn' t exceed 20. < path> consists of lowercase English letters, dots and slashes. There are no two consecutive slashes, < path> doesn' t start with a slash and its length doesn' t exceed 20. Addresses are not guaranteed to be distinct.",
    "output": "First print k \u2014 the number of groups of server names that correspond to one website. You should count only groups of size greater than one. Next k lines should contain the description of groups, one group per line. For each group print all server names separated by a single space. You are allowed to print both groups and names inside any group in arbitrary order.",
    "note": "",
    "topics": [
      "*special",
      "binary search",
      "data structures",
      "implementation",
      "sortings",
      "strings"
    ]
  },
  {
    "title": "Making Genome in Berland",
    "url": "https://codeforces.com/problemset/problem/638/B",
    "history": "Berland scientists face a very important task - given the parts of short DNA fragments, restore the dinosaur DNA! The genome of a berland dinosaur has noting in common with the genome that we' ve used to: it can have 26 distinct nucleotide types, a nucleotide of each type can occur at most once. If we assign distinct English letters to all nucleotides, then the genome of a Berland dinosaur will represent a non- empty string consisting of small English letters, such that each letter occurs in it at most once. Scientists have n genome fragments that are represented as substrings ( non- empty sequences of consecutive nucleotides) of the sought genome. You face the following problem: help scientists restore the dinosaur genome. It is guaranteed that the input is not contradictory and at least one suitable line always exists. When the scientists found out that you are a strong programmer, they asked you in addition to choose the one with the minimum length. If there are multiple such strings, choose any string.",
    "input": "The first line of the input contains a positive integer n ( 1 \u2264 n \u2264 100) \u2014 the number of genome fragments. Each of the next lines contains one descriptions of a fragment. Each fragment is a non- empty string consisting of distinct small letters of the English alphabet. It is not guaranteed that the given fragments are distinct. Fragments could arbitrarily overlap and one fragment could be a substring of another one. It is guaranteed that there is such string of distinct letters that contains all the given fragments as substrings.",
    "output": "In the single line of the output print the genome of the minimum length that contains all the given parts. All the nucleotides in the genome must be distinct. If there are multiple suitable strings, print the string of the minimum length. If there also are multiple suitable strings, you can print any of them.",
    "note": "",
    "topics": [
      "*special",
      "dfs and similar",
      "strings"
    ]
  },
  {
    "title": "Spy Syndrome 2",
    "url": "https://codeforces.com/problemset/problem/633/C",
    "history": "After observing the results of Spy Syndrome, Yash realised the errors of his ways. He now believes that a super spy such as Siddhant can' t use a cipher as basic and ancient as Caesar cipher. After many weeks of observation of Siddhant\u2019s sentences, Yash determined a new cipher technique. For a given sentence, the cipher is processed as: Convert all letters of the sentence to lowercase. Reverse each of the words of the sentence individually. Remove all the spaces in the sentence. For example, when this cipher is applied to the sentenceKira is childish and he hates losingthe resulting string isariksihsidlihcdnaehsetahgnisolNow Yash is given some ciphered string and a list of words. Help him to find out any original sentence composed using only words from the list. Note, that any of the given words could be used in the sentence multiple times.",
    "input": "The first line of the input contains a single integer n ( 1 \u2264 n \u2264 10 000) \u2014 the length of the ciphered text. The second line consists of n lowercase English letters \u2014 the ciphered text t. The third line contains a single integer m ( 1 \u2264 m \u2264 100 000) \u2014 the number of words which will be considered while deciphering the text. Each of the next m lines contains a non- empty word wi ( | wi| \u2264 1 000) consisting of uppercase and lowercase English letters only. It' s guaranteed that the total length of all words doesn' t exceed 1 000 000.",
    "output": "Print one line \u2014 the original sentence. It is guaranteed that at least one solution exists. If there are multiple solutions, you may output any of those.",
    "note": "In sample case 2 there may be multiple accepted outputs, \" HI there HeLLo\" and \" HI there hello\" you may output any of them.",
    "topics": [
      "data structures",
      "dp",
      "hashing",
      "implementation",
      "sortings",
      "string suffix structures",
      "strings"
    ]
  },
  {
    "title": "The Smallest String Concatenation",
    "url": "https://codeforces.com/problemset/problem/632/C",
    "history": "You' re given a list of n strings a1, a2, . . . , an. You' d like to concatenate them together in some order such that the resulting string would be lexicographically smallest. Given the list of strings, output the lexicographically smallest concatenation.",
    "input": "The first line contains integer n \u2014 the number of strings ( 1 \u2264 n \u2264 5\u00b7104) . Each of the next n lines contains one string ai ( 1 \u2264 | ai| \u2264 50) consisting of only lowercase English letters. The sum of string lengths will not exceed 5\u00b7104.",
    "output": "Print the only string a \u2014 the lexicographically smallest string concatenation.",
    "note": "",
    "topics": [
      "sortings",
      "strings"
    ]
  },
  {
    "title": "Messenger",
    "url": "https://codeforces.com/problemset/problem/631/D",
    "history": "Each employee of the \" Blake Techologies\" company uses a special messaging app \" Blake Messenger\" . All the stuff likes this app and uses it constantly. However, some important futures are missing. For example, many users want to be able to search through the message history. It was already announced that the new feature will appear in the nearest update, when developers faced some troubles that only you may help them to solve. All the messages are represented as a strings consisting of only lowercase English letters. In order to reduce the network load strings are represented in the special compressed form. Compression algorithm works as follows: string is represented as a concatenation of n blocks, each block containing only equal characters. One block may be described as a pair ( li, ci) , where li is the length of the i- th block and ci is the corresponding letter. Thus, the string s may be written as the sequence of pairs . Your task is to write the program, that given two compressed string t and s finds all occurrences of s in t. Developers know that there may be many such occurrences, so they only ask you to find the number of them. Note that p is the starting position of some occurrence of s in t if and only if tptp + 1. . . tp + | s| - 1 = s, where ti is the i- th character of string t. Note that the way to represent the string in compressed form may not be unique. For example string \" aaaa\" may be given as , , . . .",
    "input": "The first line of the input contains two integers n and m ( 1 \u2264 n, m \u2264 200 000) \u2014 the number of blocks in the strings t and s, respectively. The second line contains the descriptions of n parts of string t in the format \" li- ci\" ( 1 \u2264 li \u2264 1 000 000) \u2014 the length of the i- th part and the corresponding lowercase English letter. The second line contains the descriptions of m parts of string s in the format \" li- ci\" ( 1 \u2264 li \u2264 1 000 000) \u2014 the length of the i- th part and the corresponding lowercase English letter.",
    "output": "Print a single integer \u2014 the number of occurrences of s in t.",
    "note": "In the first sample, t = \" aaabbccccaaacc\" , and string s = \" aabbc\" . The only occurrence of string s in string t starts at position p = 2. In the second sample, t = \" aaabbbbbbaaaaaaacccceeeeeeeeaa\" , and s = \" aaa\" . The occurrences of s in t start at positions p = 1, p = 10, p = 11, p = 12, p = 13 and p = 14.",
    "topics": [
      "data structures",
      "hashing",
      "implementation",
      "string suffix structures",
      "strings"
    ]
  },
  {
    "title": "Famil Door and Brackets",
    "url": "https://codeforces.com/problemset/problem/629/C",
    "history": "As Famil Door\u2019s birthday is coming, some of his friends ( like Gabi) decided to buy a present for him. His friends are going to buy a string consisted of round brackets since Famil Door loves string of brackets of length n more than any other strings! The sequence of round brackets is called valid if and only if: the total number of opening brackets is equal to the total number of closing brackets; for any prefix of the sequence, the number of opening brackets is greater or equal than the number of closing brackets. Gabi bought a string s of length m ( m \u2264 n) and want to complete it to obtain a valid sequence of brackets of length n. He is going to pick some strings p and q consisting of round brackets and merge them in a string p + s + q, that is add the string p at the beginning of the string s and string q at the end of the string s. Now he wonders, how many pairs of strings p and q exists, such that the string p + s + q is a valid sequence of round brackets. As this number may be pretty large, he wants to calculate it modulo 109 + 7.",
    "input": "First line contains n and m ( 1 \u2264 m \u2264 n \u2264 100 000, n - m \u2264 2000) \u2014 the desired length of the string and the length of the string bought by Gabi, respectively. The second line contains string s of length m consisting of characters ' ( ' and ' ) ' only.",
    "output": "Print the number of pairs of string p and q such that p + s + q is a valid sequence of round brackets modulo 109 + 7.",
    "note": "In the first sample there are four different valid pairs: p = \" ( \" , q = \" ) ) \" p = \" ( ) \" , q = \" ) \" p = \" \" , q = \" ( ) ) \" p = \" \" , q = \" ) ( ) \" In the second sample the only way to obtain a desired string is choose empty p and q. In the third sample there is no way to get a valid sequence of brackets.",
    "topics": [
      "dp",
      "strings"
    ]
  },
  {
    "title": "Bear and String Distance",
    "url": "https://codeforces.com/problemset/problem/628/C",
    "history": "Limak is a little polar bear. He likes nice strings \u2014 strings of length n, consisting of lowercase English letters only. The distance between two letters is defined as the difference between their positions in the alphabet. For example, , and . Also, the distance between two nice strings is defined as the sum of distances of corresponding letters. For example, , and . Limak gives you a nice string s and an integer k. He challenges you to find any nice string s' that . Find any s' satisfying the given conditions, or print \" - 1\" if it' s impossible to do so. As input/ output can reach huge size it is recommended to use fast input/ output methods: for example, prefer to use gets/ scanf/ printf instead of getline/ cin/ cout in C+ + , prefer to use BufferedReader/ PrintWriter instead of Scanner/ System. out in Java.",
    "input": "The first line contains two integers n and k ( 1 \u2264 n \u2264 105, 0 \u2264 k \u2264 106) . The second line contains a string s of length n, consisting of lowercase English letters.",
    "output": "If there is no string satisfying the given conditions then print \" - 1\" ( without the quotes) . Otherwise, print any nice string s' that .",
    "note": "",
    "topics": [
      "greedy",
      "strings"
    ]
  },
  {
    "title": "War of the Corporations",
    "url": "https://codeforces.com/problemset/problem/625/B",
    "history": "A long time ago, in a galaxy far far away two giant IT- corporations Pineapple and Gogol continue their fierce competition. Crucial moment is just around the corner: Gogol is ready to release it' s new tablet Lastus 3000. This new device is equipped with specially designed artificial intelligence ( AI) . Employees of Pineapple did their best to postpone the release of Lastus 3000 as long as possible. Finally, they found out, that the name of the new artificial intelligence is similar to the name of the phone, that Pineapple released 200 years ago. As all rights on its name belong to Pineapple, they stand on changing the name of Gogol' s artificial intelligence. Pineapple insists, that the name of their phone occurs in the name of AI as a substring. Because the name of technology was already printed on all devices, the Gogol' s director decided to replace some characters in AI name with \" # \" . As this operation is pretty expensive, you should find the minimum number of characters to replace with \" # \" , such that the name of AI doesn' t contain the name of the phone as a substring. Substring is a continuous subsequence of a string.",
    "input": "The first line of the input contains the name of AI designed by Gogol, its length doesn' t exceed 100 000 characters. Second line contains the name of the phone released by Pineapple 200 years ago, its length doesn' t exceed 30. Both string are non- empty and consist of only small English letters.",
    "output": "Print the minimum number of characters that must be replaced with \" # \" in order to obtain that the name of the phone doesn' t occur in the name of AI as a substring.",
    "note": "In the first sample AI' s name may be replaced with \" int# llect\" . In the second sample Gogol can just keep things as they are. In the third sample one of the new possible names of AI may be \" s# ris# ri\" .",
    "topics": [
      "constructive algorithms",
      "greedy",
      "strings"
    ]
  },
  {
    "title": "Xors on Segments",
    "url": "https://codeforces.com/problemset/problem/620/F",
    "history": "You are given an array with n integers ai and m queries. Each query is described by two integers ( lj, rj) . Let' s define the function . The function is defined for only u \u2264 v. For each query print the maximal value of the function f( ax, ay) over all lj \u2264 x, y \u2264 rj, ax \u2264 ay.",
    "input": "The first line contains two integers n, m ( 1 \u2264 n \u2264 5\u00b7104, 1 \u2264 m \u2264 5\u00b7103) \u2014 the size of the array and the number of the queries. The second line contains n integers ai ( 1 \u2264 ai \u2264 106) \u2014 the elements of the array a. Each of the next m lines contains two integers lj, rj ( 1 \u2264 lj \u2264 rj \u2264 n) \u2013 the parameters of the j- th query.",
    "output": "For each query print the value aj on a separate line \u2014 the maximal value of the function f( ax, ay) over all lj \u2264 x, y \u2264 rj, ax \u2264 ay.",
    "note": "",
    "topics": [
      "data structures",
      "strings",
      "trees"
    ]
  },
  {
    "title": "Expensive Strings",
    "url": "https://codeforces.com/problemset/problem/616/F",
    "history": "You are given n strings ti. Each string has cost ci. Let' s define the function of string , where ps, i is the number of occurrences of s in ti, | s| is the length of the string s. Find the maximal value of function f( s) over all strings. Note that the string s is not necessarily some string from t.",
    "input": "The first line contains the only integer n ( 1 \u2264 n \u2264 105) \u2014 the number of strings in t. Each of the next n lines contains contains a non- empty string ti. ti contains only lowercase English letters. It is guaranteed that the sum of lengths of all strings in t is not greater than 5\u00b7105. The last line contains n integers ci ( - 107 \u2264 ci \u2264 107) \u2014 the cost of the i- th string.",
    "output": "Print the only integer a \u2014 the maximal value of the function f( s) over all strings s. Note one more time that the string s is not necessarily from t.",
    "note": "",
    "topics": [
      "string suffix structures",
      "strings"
    ]
  },
  {
    "title": "Comparing Two Long Integers",
    "url": "https://codeforces.com/problemset/problem/616/A",
    "history": "You are given two very long integers a, b ( leading zeroes are allowed) . You should check what number a or b is greater or determine that they are equal. The input size is very large so don' t use the reading of symbols one by one. Instead of that use the reading of a whole line or token. As input/ output can reach huge size it is recommended to use fast input/ output methods: for example, prefer to use scanf/ printf instead of cin/ cout in C+ + , prefer to use BufferedReader/ PrintWriter instead of Scanner/ System. out in Java. Don' t use the function input( ) in Python2 instead of it use the function raw_ input( ) .",
    "input": "The first line contains a non- negative integer a. The second line contains a non- negative integer b. The numbers a, b may contain leading zeroes. Each of them contains no more than 106 digits.",
    "output": "Print the symbol \" < \" if a < b and the symbol \" > \" if a > b. If the numbers are equal print the symbol \" = \" .",
    "note": "",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Running Track",
    "url": "https://codeforces.com/problemset/problem/615/C",
    "history": "A boy named Ayrat lives on planet AMI- 1511. Each inhabitant of this planet has a talent. Specifically, Ayrat loves running, moreover, just running is not enough for him. He is dreaming of making running a real art. First, he wants to construct the running track with coating t. On planet AMI- 1511 the coating of the track is the sequence of colored blocks, where each block is denoted as the small English letter. Therefore, every coating can be treated as a string. Unfortunately, blocks aren' t freely sold to non- business customers, but Ayrat found an infinite number of coatings s. Also, he has scissors and glue. Ayrat is going to buy some coatings s, then cut out from each of them exactly one continuous piece ( substring) and glue it to the end of his track coating. Moreover, he may choose to flip this block before glueing it. Ayrat want' s to know the minimum number of coating s he needs to buy in order to get the coating t for his running track. Of course, he also want' s to know some way to achieve the answer.",
    "input": "First line of the input contains the string s \u2014 the coating that is present in the shop. Second line contains the string t \u2014 the coating Ayrat wants to obtain. Both strings are non- empty, consist of only small English letters and their length doesn' t exceed 2100.",
    "output": "The first line should contain the minimum needed number of coatings n or - 1 if it' s impossible to create the desired coating. If the answer is not - 1, then the following n lines should contain two integers xi and yi \u2014 numbers of ending blocks in the corresponding piece. If xi \u2264 yi then this piece is used in the regular order, and if xi > yi piece is used in the reversed order. Print the pieces in the order they should be glued to get the string t.",
    "note": "In the first sample string \" cbaabc\" = \" cba\" + \" abc\" . In the second sample: \" ayrat\" = \" a\" + \" yr\" + \" at\" .",
    "topics": [
      "dp",
      "greedy",
      "strings",
      "trees"
    ]
  },
  {
    "title": "Puzzle Lover",
    "url": "https://codeforces.com/problemset/problem/613/E",
    "history": "Oleg Petrov loves crossword puzzles and every Thursday he buys his favorite magazine with crosswords and other word puzzles. In the last magazine Oleg found a curious puzzle, and the magazine promised a valuable prize for it' s solution. We give a formal description of the problem below. The puzzle field consists of two rows, each row contains n cells. Each cell contains exactly one small English letter. You also are given a word w, which consists of k small English letters. A solution of the puzzle is a sequence of field cells c1, . . . , ck, such that: For all i from 1 to k the letter written in the cell ci matches the letter wi; All the cells in the sequence are pairwise distinct; For all i from 1 to k - 1 cells ci and ci + 1 have a common side. Oleg Petrov quickly found a solution for the puzzle. Now he wonders, how many distinct solutions are there for this puzzle. Oleg Petrov doesn' t like too large numbers, so calculate the answer modulo 109 + 7. Two solutions ci and c' i are considered distinct if the sequences of cells do not match in at least one position, that is there is such j in range from 1 to k, such that cj = \u0338 c' j.",
    "input": "The first two lines contain the state of the field for the puzzle. Each of these non- empty lines contains exactly n small English letters. The next line is left empty. The next line is non- empty and contains word w, consisting of small English letters. The length of each line doesn' t exceed 2 000.",
    "output": "Print a single integer \u2014 the number of distinct solutions for the puzzle modulo 109 + 7.",
    "note": "",
    "topics": [
      "dp",
      "hashing",
      "strings"
    ]
  },
  {
    "title": "The Text Splitting",
    "url": "https://codeforces.com/problemset/problem/612/A",
    "history": "You are given the string s of length n and the numbers p, q. Split the string s to pieces of length p and q. For example, the string \" Hello\" for p = 2, q = 3 can be split to the two strings \" Hel\" and \" lo\" or to the two strings \" He\" and \" llo\" . Note it is allowed to split the string s to the strings only of length p or to the strings only of length q ( see the second sample test) .",
    "input": "The first line contains three positive integers n, p, q ( 1 \u2264 p, q \u2264 n \u2264 100) . The second line contains the string s consists of lowercase and uppercase latin letters and digits.",
    "output": "If it' s impossible to split the string s to the strings of length p and q print the only number \" - 1\" . Otherwise in the first line print integer k \u2014 the number of strings in partition of s. Each of the next k lines should contain the strings in partition. Each string should be of the length p or q. The string should be in order of their appearing in string s \u2014 from left to right. If there are several solutions print any of them.",
    "note": "",
    "topics": [
      "brute force",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "New Year and Ancient Prophecy",
    "url": "https://codeforces.com/problemset/problem/611/D",
    "history": "Limak is a little polar bear. In the snow he found a scroll with the ancient prophecy. Limak doesn' t know any ancient languages and thus is unable to understand the prophecy. But he knows digits! One fragment of the prophecy is a sequence of n digits. The first digit isn' t zero. Limak thinks that it' s a list of some special years. It' s hard to see any commas or spaces, so maybe ancient people didn' t use them. Now Limak wonders what years are listed there. Limak assumes three things: Years are listed in the strictly increasing order; Every year is a positive integer number; There are no leading zeros. Limak is going to consider all possible ways to split a sequence into numbers ( years) , satisfying the conditions above. He will do it without any help. However, he asked you to tell him the number of ways to do so. Since this number may be very large, you are only asked to calculate it modulo 109 + 7.",
    "input": "The first line of the input contains a single integer n ( 1 \u2264 n \u2264 5000) \u2014 the number of digits. The second line contains a string of digits and has length equal to n. It' s guaranteed that the first digit is not ' 0' .",
    "output": "Print the number of ways to correctly split the given sequence modulo 109 + 7.",
    "note": "In the first sample there are 8 ways to split the sequence: \" 123434\" = \" 123434\" ( maybe the given sequence is just one big number) \" 123434\" = \" 1\" + \" 23434\" \" 123434\" = \" 12\" + \" 3434\" \" 123434\" = \" 123\" + \" 434\" \" 123434\" = \" 1\" + \" 23\" + \" 434\" \" 123434\" = \" 1\" + \" 2\" + \" 3434\" \" 123434\" = \" 1\" + \" 2\" + \" 3\" + \" 434\" \" 123434\" = \" 1\" + \" 2\" + \" 3\" + \" 4\" + \" 34\" Note that we don' t count a split \" 123434\" = \" 12\" + \" 34\" + \" 34\" because numbers have to be strictly increasing. In the second sample there are 4 ways: \" 20152016\" = \" 20152016\" \" 20152016\" = \" 20\" + \" 152016\" \" 20152016\" = \" 201\" + \" 52016\" \" 20152016\" = \" 2015\" + \" 2016\"",
    "topics": [
      "dp",
      "hashing",
      "strings"
    ]
  },
  {
    "title": "Alphabet Permutations",
    "url": "https://codeforces.com/problemset/problem/610/E",
    "history": "You are given a string s of length n, consisting of first k lowercase English letters. We define a c- repeat of some string q as a string, consisting of c copies of the string q. For example, string \" acbacbacbacb\" is a 4- repeat of the string \" acb\" . Let' s say that string a contains string b as a subsequence, if string b can be obtained from a by erasing some symbols. Let p be a string that represents some permutation of the first k lowercase English letters. We define function d( p) as the smallest integer such that a d( p) - repeat of the string p contains string s as a subsequence. There are m operations of one of two types that can be applied to string s: Replace all characters at positions from li to ri by a character ci. For the given p, that is a permutation of first k lowercase English letters, find the value of function d( p) . All operations are performed sequentially, in the order they appear in the input. Your task is to determine the values of function d( p) for all operations of the second type.",
    "input": "The first line contains three positive integers n, m and k ( 1 \u2264 n \u2264 200 000, 1 \u2264 m \u2264 20000, 1 \u2264 k \u2264 10) \u2014 the length of the string s, the number of operations and the size of the alphabet respectively. The second line contains the string s itself. Each of the following lines m contains a description of some operation: Operation of the first type starts with 1 followed by a triple li, ri and ci, that denotes replacement of all characters at positions from li to ri by character ci ( 1 \u2264 li \u2264 ri \u2264 n, ci is one of the first k lowercase English letters) . Operation of the second type starts with 2 followed by a permutation of the first k lowercase English letters.",
    "output": "For each query of the second type the value of function d( p) .",
    "note": "After the first operation the string s will be abbbbba. In the second operation the answer is 6- repeat of abc: ABcaBcaBcaBcaBcAbc. After the third operation the string s will be abbcbba. In the fourth operation the answer is 5- repeat of cba: cbAcBacBaCBacBA. Uppercase letters means the occurrences of symbols from the string s.",
    "topics": [
      "data structures",
      "strings"
    ]
  },
  {
    "title": "Hamming Distance Sum",
    "url": "https://codeforces.com/problemset/problem/608/B",
    "history": "Genos needs your help. He was asked to solve the following programming problem by Saitama: The length of some string s is denoted | s| . The Hamming distance between two strings s and t of equal length is defined as , where si is the i- th character of s and ti is the i- th character of t. For example, the Hamming distance between string \" 0011\" and string \" 0110\" is | 0 - 0| + | 0 - 1| + | 1 - 1| + | 1 - 0| = 0 + 1 + 0 + 1 = 2. Given two binary strings a and b, find the sum of the Hamming distances between a and all contiguous substrings of b of length | a| .",
    "input": "The first line of the input contains binary string a ( 1 \u2264 | a| \u2264 200 000) . The second line of the input contains binary string b ( | a| \u2264 | b| \u2264 200 000) . Both strings are guaranteed to consist of characters ' 0' and ' 1' only.",
    "output": "Print a single integer \u2014 the sum of Hamming distances between a and all contiguous substrings of b of length | a| .",
    "note": "For the first sample case, there are four contiguous substrings of b of length | a| : \" 00\" , \" 01\" , \" 11\" , and \" 11\" . The distance between \" 01\" and \" 00\" is | 0 - 0| + | 1 - 0| = 1. The distance between \" 01\" and \" 01\" is | 0 - 0| + | 1 - 1| = 0. The distance between \" 01\" and \" 11\" is | 0 - 1| + | 1 - 1| = 1. Last distance counts twice, as there are two occurrences of string \" 11\" . The sum of these edit distances is 1 + 0 + 1 + 1 = 3. The second sample case is described in the statement.",
    "topics": [
      "combinatorics",
      "strings"
    ]
  },
  {
    "title": "Marbles",
    "url": "https://codeforces.com/problemset/problem/607/C",
    "history": "In the spirit of the holidays, Saitama has given Genos two grid paths of length n ( a weird gift even by Saitama' s standards) . A grid path is an ordered sequence of neighbouring squares in an infinite grid. Two squares are neighbouring if they share a side. One example of a grid path is ( 0, 0) \u2192 ( 0, 1) \u2192 ( 0, 2) \u2192 ( 1, 2) \u2192 ( 1, 1) \u2192 ( 0, 1) \u2192 ( - 1, 1) . Note that squares in this sequence might be repeated, i. e. path has self intersections. Movement within a grid path is restricted to adjacent squares within the sequence. That is, from the i- th square, one can only move to the ( i - 1) - th or ( i + 1) - th squares of this path. Note that there is only a single valid move from the first and last squares of a grid path. Also note, that even if there is some j- th square of the path that coincides with the i- th square, only moves to ( i - 1) - th and ( i + 1) - th squares are available. For example, from the second square in the above sequence, one can only move to either the first or third squares. To ensure that movement is not ambiguous, the two grid paths will not have an alternating sequence of three squares. For example, a contiguous subsequence ( 0, 0) \u2192 ( 0, 1) \u2192 ( 0, 0) cannot occur in a valid grid path. One marble is placed on the first square of each grid path. Genos wants to get both marbles to the last square of each grid path. However, there is a catch. Whenever he moves one marble, the other marble will copy its movement if possible. For instance, if one marble moves east, then the other marble will try and move east as well. By try, we mean if moving east is a valid move, then the marble will move east. Moving north increases the second coordinate by 1, while moving south decreases it by 1. Similarly, moving east increases first coordinate by 1, while moving west decreases it. Given these two valid grid paths, Genos wants to know if it is possible to move both marbles to the ends of their respective paths. That is, if it is possible to move the marbles such that both marbles rest on the last square of their respective paths.",
    "input": "The first line of the input contains a single integer n ( 2 \u2264 n \u2264 1 000 000) \u2014 the length of the paths. The second line of the input contains a string consisting of n - 1 characters ( each of which is either ' N' , ' E' , ' S' , or ' W' ) \u2014 the first grid path. The characters can be thought of as the sequence of moves needed to traverse the grid path. For example, the example path in the problem statement can be expressed by the string \" NNESWW\" . The third line of the input contains a string of n - 1 characters ( each of which is either ' N' , ' E' , ' S' , or ' W' ) \u2014 the second grid path.",
    "output": "Print \" YES\" ( without quotes) if it is possible for both marbles to be at the end position at the same time. Print \" NO\" ( without quotes) otherwise. In both cases, the answer is case- insensitive.",
    "note": "In the first sample, the first grid path is the one described in the statement. Moreover, the following sequence of moves will get both marbles to the end: NNESWWSWSW. In the second sample, no sequence of moves can get both marbles to the end.",
    "topics": [
      "hashing",
      "strings"
    ]
  },
  {
    "title": "Acyclic Organic Compounds",
    "url": "https://codeforces.com/problemset/problem/601/D",
    "history": "You are given a tree T with n vertices ( numbered 1 through n) and a letter in each vertex. The tree is rooted at vertex 1. Let' s look at the subtree Tv of some vertex v. It is possible to read a string along each simple path starting at v and ending at some vertex in Tv ( possibly v itself) . Let' s denote the number of distinct strings which can be read this way as . Also, there' s a number cv assigned to each vertex v. We are interested in vertices with the maximum value of . You should compute two statistics: the maximum value of and the number of vertices v with the maximum .",
    "input": "The first line of the input contains one integer n ( 1 \u2264 n \u2264 300 000) \u2014 the number of vertices of the tree. The second line contains n space- separated integers ci ( 0 \u2264 ci \u2264 109) . The third line contains a string s consisting of n lowercase English letters \u2014 the i- th character of this string is the letter in vertex i. The following n - 1 lines describe the tree T. Each of them contains two space- separated integers u and v ( 1 \u2264 u, v \u2264 n) indicating an edge between vertices u and v. It' s guaranteed that the input will describe a tree.",
    "output": "Print two lines. On the first line, print over all 1 \u2264 i \u2264 n. On the second line, print the number of vertices v for which .",
    "note": "In the first sample, the tree looks like this: The sets of strings that can be read from individual vertices are: Finally, the values of are: In the second sample, the values of are ( 5, 4, 2, 1, 1, 1) . The distinct strings read in T2 are ; note that can be read down to vertices 3 or 4.",
    "topics": [
      "data structures",
      "dfs and similar",
      "dsu",
      "hashing",
      "strings",
      "trees"
    ]
  },
  {
    "title": "Make Palindrome",
    "url": "https://codeforces.com/problemset/problem/600/C",
    "history": "A string is called palindrome if it reads the same from left to right and from right to left. For example \" kazak\" , \" oo\" , \" r\" and \" mikhailrubinchikkihcniburliahkim\" are palindroms, but strings \" abb\" and \" ij\" are not. You are given string s consisting of lowercase Latin letters. At once you can choose any position in the string and change letter in that position to any other lowercase letter. So after each changing the length of the string doesn' t change. At first you can change some letters in s. Then you can permute the order of letters as you want. Permutation doesn' t count as changes. You should obtain palindrome with the minimal number of changes. If there are several ways to do that you should get the lexicographically ( alphabetically) smallest palindrome. So firstly you should minimize the number of changes and then minimize the palindrome lexicographically.",
    "input": "The only line contains string s ( 1 \u2264 | s| \u2264 2\u00b7105) consisting of only lowercase Latin letters.",
    "output": "Print the lexicographically smallest palindrome that can be obtained with the minimal number of changes.",
    "note": "",
    "topics": [
      "constructive algorithms",
      "greedy",
      "strings"
    ]
  },
  {
    "title": "Extract Numbers",
    "url": "https://codeforces.com/problemset/problem/600/A",
    "history": "You are given string s. Let' s call word any largest sequence of consecutive symbols without symbols ' , ' ( comma) and ' ; ' ( semicolon) . For example, there are four words in string \" aba, 123; 1a; 0\" : \" aba\" , \" 123\" , \" 1a\" , \" 0\" . A word can be empty: for example, the string s= \" ; ; \" contains three empty words separated by ' ; ' . You should find all words in the given string that are nonnegative INTEGER numbers without leading zeroes and build by them new string a. String a should contain all words that are numbers separating them by ' , ' ( the order of numbers should remain the same as in the string s) . By all other words you should build string b in the same way ( the order of numbers should remain the same as in the string s) . Here strings \" 101\" , \" 0\" are INTEGER numbers, but \" 01\" and \" 1. 0\" are not. For example, for the string aba, 123; 1a; 0 the string a would be equal to \" 123, 0\" and string b would be equal to \" aba, 1a\" .",
    "input": "The only line of input contains the string s ( 1 \u2264 | s| \u2264 105) . The string contains only symbols ' . ' ( ASCII 46) , ' , ' ( ASCII 44) , ' ; ' ( ASCII 59) , digits, lowercase and uppercase latin letters.",
    "output": "Print the string a to the first line and string b to the second line. Each string should be surrounded by quotes ( ASCII 34) . If there are no words that are numbers print dash ( ASCII 45) on the first line. If all words are numbers print dash on the second line.",
    "note": "In the second example the string s contains five words: \" 1\" , \" \" , \" 01\" , \" a0\" , \" \" .",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Queries on a String",
    "url": "https://codeforces.com/problemset/problem/598/B",
    "history": "You are given a string s and should process m queries. Each query is described by two 1- based indices li, ri and integer ki. It means that you should cyclically shift the substring s[ li. . . ri] ki times. The queries should be processed one after another in the order they are given. One operation of a cyclic shift ( rotation) is equivalent to moving the last character to the position of the first character and shifting all other characters one position to the right. For example, if the string s is abacaba and the query is l1 = 3, r1 = 6, k1 = 1 then the answer is abbacaa. If after that we would process the query l2 = 1, r2 = 4, k2 = 2 then we would get the string baabcaa.",
    "input": "The first line of the input contains the string s ( 1 \u2264 | s| \u2264 10 000) in its initial state, where | s| stands for the length of s. It contains only lowercase English letters. Second line contains a single integer m ( 1 \u2264 m \u2264 300) \u2014 the number of queries. The i- th of the next m lines contains three integers li, ri and ki ( 1 \u2264 li \u2264 ri \u2264 | s| , 1 \u2264 ki \u2264 1 000 000) \u2014 the description of the i- th query.",
    "output": "Print the resulting string s after processing all m queries.",
    "note": "The sample is described in problem statement.",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Wilbur and Strings",
    "url": "https://codeforces.com/problemset/problem/596/E",
    "history": "Wilbur the pig now wants to play with strings. He has found an n by m table consisting only of the digits from 0 to 9 where the rows are numbered 1 to n and the columns are numbered 1 to m. Wilbur starts at some square and makes certain moves. If he is at square ( x, y) and the digit d ( 0 \u2264 d \u2264 9) is written at position ( x, y) , then he must move to the square ( x + ad, y + bd) , if that square lies within the table, and he stays in the square ( x, y) otherwise. Before Wilbur makes a move, he can choose whether or not to write the digit written in this square on the white board. All digits written on the whiteboard form some string. Every time a new digit is written, it goes to the end of the current string. Wilbur has q strings that he is worried about. For each string si, Wilbur wants to know whether there exists a starting position ( x, y) so that by making finitely many moves, Wilbur can end up with the string si written on the white board.",
    "input": "The first line of the input consists of three integers n, m, and q ( 1 \u2264 n, m, q \u2264 200) \u2014 the dimensions of the table and the number of strings to process, respectively. Each of the next n lines contains m digits from 0 and 9 giving the table itself. Then follow 10 lines. The i- th of them contains the values ai - 1 and bi - 1 ( - 200 \u2264 ai, bi \u2264 200) , i. e. the vector that Wilbur uses to make a move from the square with a digit i - 1 in it. There are q lines that follow. The i- th of them will contain a string si consisting only of digits from 0 to 9. It is guaranteed that the total length of these q strings won' t exceed 1 000 000.",
    "output": "For each of the q strings, print \" YES\" if Wilbur can choose x and y in order to finish with this string after some finite number of moves. If it' s impossible, than print \" NO\" for the corresponding string.",
    "note": "In the first sample, there is a 1 by 1 table consisting of the only digit 0. The only move that can be made is staying on the square. The first string can be written on the white board by writing 0 repeatedly. The second string cannot be written as there is no 2 on the table.",
    "topics": [
      "dfs and similar",
      "dp",
      "graphs",
      "strings"
    ]
  },
  {
    "title": "Cutting the Line",
    "url": "https://codeforces.com/problemset/problem/594/E",
    "history": "You are given a non- empty line s and an integer k. The following operation is performed with this line exactly once: A line is split into at most k non- empty substrings, i. e. string s is represented as a concatenation of a set of strings s = t1 + t2 + . . . + tm, 1 \u2264 m \u2264 k. Some of strings ti are replaced by strings tir, that is, their record from right to left. The lines are concatenated back in the same order, we get string s' = t' 1t' 2. . . t' m, where t' i equals ti or tir. Your task is to determine the lexicographically smallest string that could be the result of applying the given operation to the string s.",
    "input": "The first line of the input contains string s ( 1 \u2264 | s| \u2264 5 000 000) , consisting of lowercase English letters. The second line contains integer k ( 1 \u2264 k \u2264 | s| ) \u2014 the maximum number of parts in the partition.",
    "output": "In the single line print the lexicographically minimum string s' which can be obtained as a result of performing the described operation.",
    "note": "",
    "topics": [
      "string suffix structures",
      "strings"
    ]
  },
  {
    "title": "Rebranding",
    "url": "https://codeforces.com/problemset/problem/591/B",
    "history": "The name of one small but proud corporation consists of n lowercase English letters. The Corporation has decided to try rebranding \u2014 an active marketing strategy, that includes a set of measures to change either the brand ( both for the company and the goods it produces) or its components: the name, the logo, the slogan. They decided to start with the name. For this purpose the corporation has consecutively hired m designers. Once a company hires the i- th designer, he immediately contributes to the creation of a new corporation name as follows: he takes the newest version of the name and replaces all the letters xi by yi, and all the letters yi by xi. This results in the new version. It is possible that some of these letters do no occur in the string. It may also happen that xi coincides with yi. The version of the name received after the work of the last designer becomes the new name of the corporation. Manager Arkady has recently got a job in this company, but is already soaked in the spirit of teamwork and is very worried about the success of the rebranding. Naturally, he can' t wait to find out what is the new name the Corporation will receive. Satisfy Arkady' s curiosity and tell him the final version of the name.",
    "input": "The first line of the input contains two integers n and m ( 1 \u2264 n, m \u2264 200 000) \u2014 the length of the initial name and the number of designers hired, respectively. The second line consists of n lowercase English letters and represents the original name of the corporation. Next m lines contain the descriptions of the designers' actions: the i- th of them contains two space- separated lowercase English letters xi and yi.",
    "output": "Print the new name of the corporation.",
    "note": "In the second sample the name of the corporation consecutively changes as follows:",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Birthday",
    "url": "https://codeforces.com/problemset/problem/590/E",
    "history": "Today is birthday of a Little Dasha \u2014 she is now 8 years old! On this occasion, each of her n friends and relatives gave her a ribbon with a greeting written on it, and, as it turned out, all the greetings are different. Dasha gathered all the ribbons and decided to throw away some of them in order to make the remaining set stylish. The birthday girl considers a set of ribbons stylish if no greeting written on some ribbon is a substring of another greeting written on some other ribbon. Let us recall that the substring of the string s is a continuous segment of s. Help Dasha to keep as many ribbons as possible, so that she could brag about them to all of her friends. Dasha cannot rotate or flip ribbons, that is, each greeting can be read in a single way given in the input.",
    "input": "The first line of the input contains integer n ( 1 \u2264 n \u2264 750) \u2014 the number of Dasha' s relatives and friends. Each of the next n lines contains exactly one greeting. Each greeting consists of characters ' a' and ' b' only. The total length of all greetings won' t exceed 10 000 000 characters.",
    "output": "In the first line print the maximum size of the stylish set. In the second line print the numbers of ribbons involved in it, assuming that they are numbered from 1 to n in the order they appear in the input. If there are several stylish sets of the maximum size, print any of them.",
    "note": "In the sample, the answer that keeps ribbons 3 and 4 is also considered correct.",
    "topics": [
      "graph matchings",
      "strings"
    ]
  },
  {
    "title": "Duff is Mad",
    "url": "https://codeforces.com/problemset/problem/587/F",
    "history": "Duff is mad at her friends. That' s why she sometimes makes Malek to take candy from one of her friends for no reason! She has n friends. Her i- th friend' s name is si ( their names are not necessarily unique) . q times, she asks Malek to take candy from her friends. She' s angry, but also she acts with rules. When she wants to ask Malek to take candy from one of her friends, like k, she chooses two numbers l and r and tells Malek to take exactly candies from him/ her, where occur( t, s) is the number of occurrences of string t in s. Malek is not able to calculate how many candies to take in each request from Duff. That' s why she asked for your help. Please tell him how many candies to take in each request.",
    "input": "The first line of input contains two integers n and q ( 1 \u2264 n, q \u2264 105) . The next n lines contain the names. i- th of them contains an string si, consisting of lowercase English letters ( ) . The next q lines contain the requests. Each of them contains three integers, l, r and k ( says that Malek should take candies from Duff' s k- th friend) .",
    "output": "Print the answer to each request in one line.",
    "note": "",
    "topics": [
      "data structures",
      "strings"
    ]
  },
  {
    "title": "Digits of Number Pi",
    "url": "https://codeforces.com/problemset/problem/585/F",
    "history": "Vasily has recently learned about the amazing properties of number \u03c0. In one of the articles it has been hypothesized that, whatever the sequence of numbers we have, in some position, this sequence is found among the digits of number \u03c0. Thus, if you take, for example, the epic novel \" War and Peace\" of famous Russian author Leo Tolstoy, and encode it with numbers, then we will find the novel among the characters of number \u03c0. Vasily was absolutely delighted with this, because it means that all the books, songs and programs have already been written and encoded in the digits of \u03c0. Vasily is, of course, a bit wary that this is only a hypothesis and it hasn' t been proved, so he decided to check it out. To do this, Vasily downloaded from the Internet the archive with the sequence of digits of number \u03c0, starting with a certain position, and began to check the different strings of digits on the presence in the downloaded archive. Vasily quickly found short strings of digits, but each time he took a longer string, it turned out that it is not in the archive. Vasily came up with a definition that a string of length d is a half- occurrence if it contains a substring of length of at least , which occurs in the archive. To complete the investigation, Vasily took 2 large numbers x, y ( x \u2264 y) with the same number of digits and now he wants to find the number of numbers in the interval from x to y, which are half- occurrences in the archive. Help Vasily calculate this value modulo 109 + 7.",
    "input": "The first line contains string s consisting of decimal digits ( 1 \u2264 | s| \u2264 1000) that Vasily will use to search substrings in. According to hypothesis, this sequence of digis indeed occurs in the decimal representation of \u03c0, although we can' t guarantee that. The second and third lines contain two positive integers x, y of the same length d ( x \u2264 y, 2 \u2264 d \u2264 50) . Numbers x, y do not contain leading zeroes.",
    "output": "Print how many numbers in the segment from x to y that are half- occurrences in s modulo 109 + 7.",
    "note": "",
    "topics": [
      "dp",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Marina and Vasya",
    "url": "https://codeforces.com/problemset/problem/584/C",
    "history": "Marina loves strings of the same length and Vasya loves when there is a third string, different from them in exactly t characters. Help Vasya find at least one such string. More formally, you are given two strings s1, s2 of length n and number t. Let' s denote as f( a, b) the number of characters in which strings a and b are different. Then your task will be to find any string s3 of length n, such that f( s1, s3) = f( s2, s3) = t. If there is no such string, print - 1.",
    "input": "The first line contains two integers n and t ( 1 \u2264 n \u2264 105, 0 \u2264 t \u2264 n) . The second line contains string s1 of length n, consisting of lowercase English letters. The third line contain string s2 of length n, consisting of lowercase English letters.",
    "output": "Print a string of length n, differing from string s1 and from s2 in exactly t characters. Your string should consist only from lowercase English letters. If such string doesn' t exist, print - 1.",
    "note": "",
    "topics": [
      "constructive algorithms",
      "greedy",
      "strings"
    ]
  },
  {
    "title": "Kefa and Watch",
    "url": "https://codeforces.com/problemset/problem/580/E",
    "history": "One day Kefa the parrot was walking down the street as he was on the way home from the restaurant when he saw something glittering by the road. As he came nearer he understood that it was a watch. He decided to take it to the pawnbroker to earn some money. The pawnbroker said that each watch contains a serial number represented by a string of digits from 0 to 9, and the more quality checks this number passes, the higher is the value of the watch. The check is defined by three positive integers l, r and d. The watches pass a check if a substring of the serial number from l to r has period d. Sometimes the pawnbroker gets distracted and Kefa changes in some substring of the serial number all digits to c in order to increase profit from the watch. The seller has a lot of things to do to begin with and with Kefa messing about, he gave you a task: to write a program that determines the value of the watch. Let us remind you that number x is called a period of string s ( 1 \u2264 x \u2264 | s| ) , if si = si + x for all i from 1 to | s| - x.",
    "input": "The first line of the input contains three positive integers n, m and k ( 1 \u2264 n \u2264 105, 1 \u2264 m + k \u2264 105) \u2014 the length of the serial number, the number of change made by Kefa and the number of quality checks. The second line contains a serial number consisting of n digits. Then m + k lines follow, containing either checks or changes. The changes are given as 1 l r c ( 1 \u2264 l \u2264 r \u2264 n, 0 \u2264 c \u2264 9) . That means that Kefa changed all the digits from the l- th to the r- th to be c. The checks are given as 2 l r d ( 1 \u2264 l \u2264 r \u2264 n, 1 \u2264 d \u2264 r - l + 1) .",
    "output": "For each check on a single line print \" YES\" if the watch passed it, otherwise print \" NO\" .",
    "note": "In the first sample test two checks will be made. In the first one substring \" 12\" is checked on whether or not it has period 1, so the answer is \" NO\" . In the second one substring \" 88\" , is checked on whether or not it has period 1, and it has this period, so the answer is \" YES\" . In the second statement test three checks will be made. The first check processes substring \" 3493\" , which doesn' t have period 2. Before the second check the string looks as \" 334334\" , so the answer to it is \" YES\" . And finally, the third check processes substring \" 8334\" , which does not have period 1.",
    "topics": [
      "data structures",
      "hashing",
      "strings"
    ]
  },
  {
    "title": "Matching Names",
    "url": "https://codeforces.com/problemset/problem/566/A",
    "history": "Teachers of one programming summer school decided to make a surprise for the students by giving them names in the style of the \" Hobbit\" movie. Each student must get a pseudonym maximally similar to his own name. The pseudonym must be a name of some character of the popular saga and now the teachers are busy matching pseudonyms to student names. There are n students in a summer school. Teachers chose exactly n pseudonyms for them. Each student must get exactly one pseudonym corresponding to him. Let us determine the relevance of a pseudonym b to a student with name a as the length of the largest common prefix a and b. We will represent such value as . Then we can determine the quality of matching of the pseudonyms to students as a sum of relevances of all pseudonyms to the corresponding students. Find the matching between students and pseudonyms with the maximum quality.",
    "input": "The first line contains number n ( 1 \u2264 n \u2264 100 000) \u2014 the number of students in the summer school. Next n lines contain the name of the students. Each name is a non- empty word consisting of lowercase English letters. Some names can be repeating. The last n lines contain the given pseudonyms. Each pseudonym is a non- empty word consisting of small English letters. Some pseudonyms can be repeating. The total length of all the names and pseudonyms doesn' t exceed 800 000 characters.",
    "output": "In the first line print the maximum possible quality of matching pseudonyms to students. In the next n lines describe the optimal matching. Each line must have the form a b ( 1 \u2264 a, b \u2264 n) , that means that the student who was number a in the input, must match to the pseudonym number b in the input. The matching should be a one- to- one correspondence, that is, each student and each pseudonym should occur exactly once in your output. If there are several optimal answers, output any.",
    "note": "The first test from the statement the match looks as follows: bill \u2192 bilbo ( lcp = 3) galya \u2192 galadriel ( lcp = 3) gennady \u2192 gendalf ( lcp = 3) toshik \u2192 torin ( lcp = 2) boris \u2192 smaug ( lcp = 0)",
    "topics": [
      "dfs and similar",
      "strings",
      "trees"
    ]
  },
  {
    "title": "Equivalent Strings",
    "url": "https://codeforces.com/problemset/problem/559/B",
    "history": "Today on a lecture about strings Gerald learned a new definition of string equivalency. Two strings a and b of equal length are called equivalent in one of the two cases: They are equal. If we split string a into two halves of the same size a1 and a2, and string b into two halves of the same size b1 and b2, then one of the following is correct: a1 is equivalent to b1, and a2 is equivalent to b2 a1 is equivalent to b2, and a2 is equivalent to b1 As a home task, the teacher gave two strings to his students and asked to determine if they are equivalent. Gerald has already completed this home task. Now it' s your turn!",
    "input": "The first two lines of the input contain two strings given by the teacher. Each of them has the length from 1 to 200 000 and consists of lowercase English letters. The strings have the same length.",
    "output": "Print \" YES\" ( without the quotes) , if these two strings are equivalent, and \" NO\" ( without the quotes) otherwise.",
    "note": "In the first sample you should split the first string into strings \" aa\" and \" ba\" , the second one \u2014 into strings \" ab\" and \" aa\" . \" aa\" is equivalent to \" aa\" ; \" ab\" is equivalent to \" ba\" as \" ab\" = \" a\" + \" b\" , \" ba\" = \" b\" + \" a\" . In the second sample the first string can be splitted into strings \" aa\" and \" bb\" , that are equivalent only to themselves. That' s why string \" aabb\" is equivalent only to itself and to string \" bbaa\" .",
    "topics": [
      "divide and conquer",
      "hashing",
      "sortings",
      "strings"
    ]
  },
  {
    "title": "A Simple Task",
    "url": "https://codeforces.com/problemset/problem/558/E",
    "history": "This task is very simple. Given a string S of length n and q queries each query is on the format i j k which means sort the substring consisting of the characters from i to j in non- decreasing order if k = 1 or in non- increasing order if k = 0. Output the final string after applying the queries.",
    "input": "The first line will contain two integers n, q ( 1 \u2264 n \u2264 105, 0 \u2264 q \u2264 50 000) , the length of the string and the number of queries respectively. Next line contains a string S itself. It contains only lowercase English letters. Next q lines will contain three integers each i, j, k ( 1 \u2264 i \u2264 j \u2264 n, ) .",
    "output": "Output one line, the string S after applying the queries.",
    "note": "First sample test explanation:",
    "topics": [
      "data structures",
      "sortings",
      "strings"
    ]
  },
  {
    "title": "Ann and Half-Palindrome",
    "url": "https://codeforces.com/problemset/problem/557/E",
    "history": "Tomorrow Ann takes the hardest exam of programming where she should get an excellent mark. On the last theoretical class the teacher introduced the notion of a half- palindrome. String t is a half- palindrome, if for all the odd positions i ( ) the following condition is held: ti = t| t| - i + 1, where | t| is the length of string t if positions are indexed from 1. For example, strings \" abaa\" , \" a\" , \" bb\" , \" abbbaa\" are half- palindromes and strings \" ab\" , \" bba\" and \" aaabaa\" are not. Ann knows that on the exam she will get string s, consisting only of letters a and b, and number k. To get an excellent mark she has to find the k- th in the lexicographical order string among all substrings of s that are half- palyndromes. Note that each substring in this order is considered as many times as many times it occurs in s. The teachers guarantees that the given number k doesn' t exceed the number of substrings of the given string that are half- palindromes. Can you cope with this problem?",
    "input": "The first line of the input contains string s ( 1 \u2264 | s| \u2264 5000) , consisting only of characters ' a' and ' b' , where | s| is the length of string s. The second line contains a positive integer k \u2014 the lexicographical number of the requested string among all the half- palindrome substrings of the given string s. The strings are numbered starting from one. It is guaranteed that number k doesn' t exceed the number of substrings of the given string that are half- palindromes.",
    "output": "Print a substring of the given string that is the k- th in the lexicographical order of all substrings of the given string that are half- palindromes.",
    "note": "By definition, string a = a1a2. . . an is lexicographically less than string b = b1b2. . . bm, if either a is a prefix of b and doesn' t coincide with b, or there exists such i, that a1 = b1, a2 = b2, . . . ai - 1 = bi - 1, ai < bi. In the first sample half- palindrome substrings are the following strings \u2014 a, a, a, a, aa, aba, abaa, abba, abbabaa, b, b, b, b, baab, bab, bb, bbab, bbabaab ( the list is given in the lexicographical order) .",
    "topics": [
      "data structures",
      "dp",
      "graphs",
      "string suffix structures",
      "strings",
      "trees"
    ]
  },
  {
    "title": "Ohana Cleans Up",
    "url": "https://codeforces.com/problemset/problem/554/B",
    "history": "Ohana Matsumae is trying to clean a room, which is divided up into an n by n grid of squares. Each square is initially either clean or dirty. Ohana can sweep her broom over columns of the grid. Her broom is very strange: if she sweeps over a clean square, it will become dirty, and if she sweeps over a dirty square, it will become clean. She wants to sweep some columns of the room to maximize the number of rows that are completely clean. It is not allowed to sweep over the part of the column, Ohana can only sweep the whole column. Return the maximum number of rows that she can make completely clean.",
    "input": "The first line of input will be a single integer n ( 1 \u2264 n \u2264 100) . The next n lines will describe the state of the room. The i- th line will contain a binary string with n characters denoting the state of the i- th row of the room. The j- th character on this line is ' 1' if the j- th square in the i- th row is clean, and ' 0' if it is dirty.",
    "output": "The output should be a single line containing an integer equal to a maximum possible number of rows that are completely clean.",
    "note": "In the first sample, Ohana can sweep the 1st and 3rd columns. This will make the 1st and 4th row be completely clean. In the second sample, everything is already clean, so Ohana doesn' t need to do anything.",
    "topics": [
      "brute force",
      "greedy",
      "strings"
    ]
  },
  {
    "title": "Kyoya and Photobooks",
    "url": "https://codeforces.com/problemset/problem/554/A",
    "history": "Kyoya Ootori is selling photobooks of the Ouran High School Host Club. He has 26 photos, labeled \" a\" to \" z\" , and he has compiled them into a photo booklet with some photos in some order ( possibly with some photos being duplicated) . A photo booklet can be described as a string of lowercase letters, consisting of the photos in the booklet in order. He now wants to sell some \" special edition\" photobooks, each with one extra photo inserted anywhere in the book. He wants to make as many distinct photobooks as possible, so he can make more money. He asks Haruhi, how many distinct photobooks can he make by inserting one extra photo into the photobook he already has? Please help Haruhi solve this problem.",
    "input": "The first line of input will be a single string s ( 1 \u2264 | s| \u2264 20) . String s consists only of lowercase English letters.",
    "output": "Output a single integer equal to the number of distinct photobooks Kyoya Ootori can make.",
    "note": "In the first case, we can make ' ab' , ' ac' , . . . , ' az' , ' ba' , ' ca' , . . . , ' za' , and ' aa' , producing a total of 51 distinct photo booklets.",
    "topics": [
      "brute force",
      "math",
      "strings"
    ]
  },
  {
    "title": "Vanya and Brackets",
    "url": "https://codeforces.com/problemset/problem/552/E",
    "history": "Vanya is doing his maths homework. He has an expression of form , where x1, x2, . . . , xn are digits from 1 to 9, and sign represents either a plus ' + ' or the multiplication sign ' * ' . Vanya needs to add one pair of brackets in this expression so that to maximize the value of the resulting expression.",
    "input": "The first line contains expression s ( 1 \u2264 | s| \u2264 5001, | s| is odd) , its odd positions only contain digits from 1 to 9, and even positions only contain signs + and * . The number of signs * doesn' t exceed 15.",
    "output": "In the first line print the maximum possible value of an expression.",
    "note": "Note to the first sample test. 3 + 5 * ( 7 + 8) * 4 = 303. Note to the second sample test. ( 2 + 3) * 5 = 25. Note to the third sample test. ( 3 * 4) * 5 = 60 ( also many other variants are valid, for instance, ( 3) * 4 * 5 = 60) .",
    "topics": [
      "brute force",
      "dp",
      "expression parsing",
      "greedy",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "ZgukistringZ",
    "url": "https://codeforces.com/problemset/problem/551/B",
    "history": "Professor GukiZ doesn' t accept string as they are. He likes to swap some letters in string to obtain a new one. GukiZ has strings a, b, and c. He wants to obtain string k by swapping some letters in a, so that k should contain as many non- overlapping substrings equal either to b or c as possible. Substring of string x is a string formed by consecutive segment of characters from x. Two substrings of string x overlap if there is position i in string x occupied by both of them. GukiZ was disappointed because none of his students managed to solve the problem. Can you help them and find one of possible strings k?",
    "input": "The first line contains string a, the second line contains string b, and the third line contains string c ( 1 \u2264 | a| , | b| , | c| \u2264 105, where | s| denotes the length of string s) . All three strings consist only of lowercase English letters. It is possible that b and c coincide.",
    "output": "Find one of possible strings k, as described in the problem statement. If there are multiple possible answers, print any of them.",
    "note": "In the third sample, this optimal solutions has three non- overlaping substrings equal to either b or c on positions 1 \u2013 2 ( ab) , 3 \u2013 4 ( ab) , 5 \u2013 7 ( aca) . In this sample, there exist many other optimal solutions, one of them would be acaababbcc.",
    "topics": [
      "brute force",
      "constructive algorithms",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Two Substrings",
    "url": "https://codeforces.com/problemset/problem/550/A",
    "history": "You are given string s. Your task is to determine if the given string s contains two non- overlapping substrings \" AB\" and \" BA\" ( the substrings can go in any order) .",
    "input": "The only line of input contains a string s of length between 1 and 105 consisting of uppercase Latin letters.",
    "output": "Print \" YES\" ( without the quotes) , if string s contains two non- overlapping substrings \" AB\" and \" BA\" , and \" NO\" otherwise.",
    "note": "In the first sample test, despite the fact that there are substrings \" AB\" and \" BA\" , their occurrences overlap, so the answer is \" NO\" . In the second sample test there are the following occurrences of the substrings: BACFAB. In the third sample test there is no substring \" AB\" nor substring \" BA\" .",
    "topics": [
      "brute force",
      "dp",
      "greedy",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Face Detection",
    "url": "https://codeforces.com/problemset/problem/549/A",
    "history": "The developers of Looksery have to write an efficient algorithm that detects faces on a picture. Unfortunately, they are currently busy preparing a contest for you, so you will have to do it for them. In this problem an image is a rectangular table that consists of lowercase Latin letters. A face on the image is a 2 \u00d7 2 square, such that from the four letters of this square you can make word \" face\" . You need to write a program that determines the number of faces on the image. The squares that correspond to the faces can overlap.",
    "input": "The first line contains two space- separated integers, n and m ( 1 \u2264 n, m \u2264 50) \u2014 the height and the width of the image, respectively. Next n lines define the image. Each line contains m lowercase Latin letters.",
    "output": "In the single line print the number of faces on the image.",
    "note": "In the first sample the image contains a single face, located in a square with the upper left corner at the second line and the second column: In the second sample the image also contains exactly one face, its upper left corner is at the second row and the first column. In the third sample two faces are shown: In the fourth sample the image has no faces on it.",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Mike and Fax",
    "url": "https://codeforces.com/problemset/problem/548/A",
    "history": "While Mike was walking in the subway, all the stuff in his back- bag dropped on the ground. There were several fax messages among them. He concatenated these strings in some order and now he has string s. He is not sure if this is his own back- bag or someone else' s. He remembered that there were exactly k messages in his own bag, each was a palindrome string and all those strings had the same length. He asked you to help him and tell him if he has worn his own back- bag. Check if the given string s is a concatenation of k palindromes of the same length.",
    "input": "The first line of input contains string s containing lowercase English letters ( 1 \u2264 | s| \u2264 1000) . The second line contains integer k ( 1 \u2264 k \u2264 1000) .",
    "output": "Print \" YES\" ( without quotes) if he has worn his own back- bag or \" NO\" ( without quotes) otherwise.",
    "note": "Palindrome is a string reading the same forward and backward. In the second sample, the faxes in his back- bag can be \" saddas\" and \" tavvat\" .",
    "topics": [
      "brute force",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Mike and Friends",
    "url": "https://codeforces.com/problemset/problem/547/E",
    "history": "What- The- Fatherland is a strange country! All phone numbers there are strings consisting of lowercase English letters. What is double strange that a phone number can be associated with several bears! In that country there is a rock band called CF consisting of n bears ( including Mike) numbered from 1 to n. Phone number of i- th member of CF is si. May 17th is a holiday named Phone Calls day. In the last Phone Calls day, everyone called all the numbers that are substrings of his/ her number ( one may call some number several times) . In particular, everyone called himself ( that was really strange country) . Denote as call( i, j) the number of times that i- th member of CF called the j- th member of CF. The geek Mike has q questions that he wants to ask you. In each question he gives you numbers l, r and k and you should tell him the number",
    "input": "The first line of input contains integers n and q ( 1 \u2264 n \u2264 2 \u00d7 105 and 1 \u2264 q \u2264 5 \u00d7 105) . The next n lines contain the phone numbers, i- th line contains a string si consisting of lowercase English letters ( ) . The next q lines contain the information about the questions, each of them contains integers l, r and k ( 1 \u2264 l \u2264 r \u2264 n and 1 \u2264 k \u2264 n) .",
    "output": "Print the answer for each question in a separate line.",
    "note": "",
    "topics": [
      "data structures",
      "string suffix structures",
      "strings",
      "trees"
    ]
  },
  {
    "title": "Set of Strings",
    "url": "https://codeforces.com/problemset/problem/544/A",
    "history": "You are given a string q. A sequence of k strings s1, s2, . . . , sk is called beautiful, if the concatenation of these strings is string q ( formally, s1 + s2 + . . . + sk = q) and the first characters of these strings are distinct. Find any beautiful sequence of strings or determine that the beautiful sequence doesn' t exist.",
    "input": "The first line contains a positive integer k ( 1 \u2264 k \u2264 26) \u2014 the number of strings that should be in a beautiful sequence. The second line contains string q, consisting of lowercase Latin letters. The length of the string is within range from 1 to 100, inclusive.",
    "output": "If such sequence doesn' t exist, then print in a single line \" NO\" ( without the quotes) . Otherwise, print in the first line \" YES\" ( without the quotes) and in the next k lines print the beautiful sequence of strings s1, s2, . . . , sk. If there are multiple possible answers, print any of them.",
    "note": "In the second sample there are two possible answers: \" aaaca\" , \" s\" and \" aaa\" , \" cas\" .",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Tavas and Malekas",
    "url": "https://codeforces.com/problemset/problem/535/D",
    "history": "Tavas is a strange creature. Usually \" zzz\" comes out of people' s mouth while sleeping, but string s of length n comes out from Tavas' mouth instead. Today Tavas fell asleep in Malekas' place. While he was sleeping, Malekas did a little process on s. Malekas has a favorite string p. He determined all positions x1 < x2 < . . . < xk where p matches s. More formally, for each xi ( 1 \u2264 i \u2264 k) he condition sxisxi + 1. . . sxi + | p| - 1 = p is fullfilled. Then Malekas wrote down one of subsequences of x1, x2, . . . xk ( possibly, he didn' t write anything) on a piece of paper. Here a sequence b is a subsequence of sequence a if and only if we can turn a into b by removing some of its elements ( maybe no one of them or all) . After Tavas woke up, Malekas told him everything. He couldn' t remember string s, but he knew that both p and s only contains lowercase English letters and also he had the subsequence he had written on that piece of paper. Tavas wonders, what is the number of possible values of s? He asked SaDDas, but he wasn' t smart enough to solve this. So, Tavas asked you to calculate this number for him. Answer can be very large, so Tavas wants you to print the answer modulo 109 + 7.",
    "input": "The first line contains two integers n and m, the length of s and the length of the subsequence Malekas wrote down ( 1 \u2264 n \u2264 106 and 0 \u2264 m \u2264 n - | p| + 1) . The second line contains string p ( 1 \u2264 | p| \u2264 n) . The next line contains m space separated integers y1, y2, . . . , ym, Malekas' subsequence ( 1 \u2264 y1 < y2 < . . . < ym \u2264 n - | p| + 1) .",
    "output": "In a single line print the answer modulo 1000 000 007.",
    "note": "In the first sample test all strings of form \" ioioi? \" where the question mark replaces arbitrary English letter satisfy. Here | x| denotes the length of string x. Please note that it' s possible that there is no such string ( answer is 0) .",
    "topics": [
      "greedy",
      "hashing",
      "string suffix structures",
      "strings"
    ]
  },
  {
    "title": "Encoding",
    "url": "https://codeforces.com/problemset/problem/533/F",
    "history": "Polycarp invented a new way to encode strings. Let' s assume that we have string T, consisting of lowercase English letters. Let' s choose several pairs of letters of the English alphabet in such a way that each letter occurs in at most one pair. Then let' s replace each letter in T with its pair letter if there is a pair letter for it. For example, if you chose pairs ( l, r) , ( p, q) and ( a, o) , then word \" parallelogram\" according to the given encoding principle transforms to word \" qolorreraglom\" . Polycarpus already has two strings, S and T. He suspects that string T was obtained after applying the given encoding method from some substring of string S. Find all positions mi in S ( 1 \u2264 mi \u2264 | S| - | T| + 1) , such that T can be obtained fro substring SmiSmi + 1. . . Smi + | T| - 1 by applying the described encoding operation by using some set of pairs of English alphabet letters",
    "input": "The first line of the input contains two integers, | S| and | T| ( 1 \u2264 | T| \u2264 | S| \u2264 2\u00b7105) \u2014 the lengths of string S and string T, respectively. The second and third line of the input contain strings S and T, respectively. Both strings consist only of lowercase English letters.",
    "output": "Print number k \u2014 the number of suitable positions in string S. In the next line print k integers m1, m2, . . . , mk \u2014 the numbers of the suitable positions in the increasing order.",
    "note": "",
    "topics": [
      "hashing",
      "string suffix structures",
      "strings"
    ]
  },
  {
    "title": "Correcting Mistakes",
    "url": "https://codeforces.com/problemset/problem/533/E",
    "history": "Analyzing the mistakes people make while typing search queries is a complex and an interesting work. As there is no guaranteed way to determine what the user originally meant by typing some query, we have to use different sorts of heuristics. Polycarp needed to write a code that could, given two words, check whether they could have been obtained from the same word as a result of typos. Polycarpus suggested that the most common typo is skipping exactly one letter as you type a word. Implement a program that can, given two distinct words S and T of the same length n determine how many words W of length n + 1 are there with such property that you can transform W into both S, and T by deleting exactly one character. Words S and T consist of lowercase English letters. Word W also should consist of lowercase English letters.",
    "input": "The first line contains integer n ( 1 \u2264 n \u2264 100 000) \u2014 the length of words S and T. The second line contains word S. The third line contains word T. Words S and T consist of lowercase English letters. It is guaranteed that S and T are distinct words.",
    "output": "Print a single integer \u2014 the number of distinct words W that can be transformed to S and T due to a typo.",
    "note": "In the first sample test the two given words could be obtained only from word \" treading\" ( the deleted letters are marked in bold) . In the second sample test the two given words couldn' t be obtained from the same word by removing one letter. In the third sample test the two given words could be obtained from either word \" tory\" or word \" troy\" .",
    "topics": [
      "constructive algorithms",
      "dp",
      "greedy",
      "hashing",
      "strings",
      "two pointers"
    ]
  },
  {
    "title": "Work Group",
    "url": "https://codeforces.com/problemset/problem/533/B",
    "history": "One Big Software Company has n employees numbered from 1 to n. The director is assigned number 1. Every employee of the company except the director has exactly one immediate superior. The director, of course, doesn' t have a superior. We will call person a a subordinates of another person b, if either b is an immediate supervisor of a, or the immediate supervisor of a is a subordinate to person b. In particular, subordinates of the head are all other employees of the company. To solve achieve an Important Goal we need to form a workgroup. Every person has some efficiency, expressed by a positive integer ai, where i is the person' s number. The efficiency of the workgroup is defined as the total efficiency of all the people included in it. The employees of the big software company are obsessed with modern ways of work process organization. Today pair programming is at the peak of popularity, so the workgroup should be formed with the following condition. Each person entering the workgroup should be able to sort all of his subordinates who are also in the workgroup into pairs. In other words, for each of the members of the workgroup the number of his subordinates within the workgroup should be even. Your task is to determine the maximum possible efficiency of the workgroup formed at observing the given condition. Any person including the director of company can enter the workgroup.",
    "input": "The first line contains integer n ( 1 \u2264 n \u2264 2\u00b7105) \u2014 the number of workers of the Big Software Company. Then n lines follow, describing the company employees. The i- th line contains two integers pi, ai ( 1 \u2264 ai \u2264 105) \u2014 the number of the person who is the i- th employee' s immediate superior and i- th employee' s efficiency. For the director p1 = - 1, for all other people the condition 1 \u2264 pi < i is fulfilled.",
    "output": "Print a single integer \u2014 the maximum possible efficiency of the workgroup.",
    "note": "In the sample test the most effective way is to make a workgroup from employees number 1, 2, 4, 5, 6.",
    "topics": [
      "dfs and similar",
      "dp",
      "graphs",
      "strings",
      "trees"
    ]
  },
  {
    "title": "Om Nom and Necklace",
    "url": "https://codeforces.com/problemset/problem/526/D",
    "history": "One day Om Nom found a thread with n beads of different colors. He decided to cut the first several beads from this thread to make a bead necklace and present it to his girlfriend Om Nelly. Om Nom knows that his girlfriend loves beautiful patterns. That' s why he wants the beads on the necklace to form a regular pattern. A sequence of beads S is regular if it can be represented as S = A + B + A + B + A + . . . + A + B + A, where A and B are some bead sequences, \" + \" is the concatenation of sequences, there are exactly 2k + 1 summands in this sum, among which there are k + 1 \" A\" summands and k \" B\" summands that follow in alternating order. Om Nelly knows that her friend is an eager mathematician, so she doesn' t mind if A or B is an empty sequence. Help Om Nom determine in which ways he can cut off the first several beads from the found thread ( at least one; probably, all) so that they form a regular pattern. When Om Nom cuts off the beads, he doesn' t change their order.",
    "input": "The first line contains two integers n, k ( 1 \u2264 n, k \u2264 1 000 000) \u2014 the number of beads on the thread that Om Nom found and number k from the definition of the regular sequence above. The second line contains the sequence of n lowercase Latin letters that represent the colors of the beads. Each color corresponds to a single letter.",
    "output": "Print a string consisting of n zeroes and ones. Position i ( 1 \u2264 i \u2264 n) must contain either number one if the first i beads on the thread form a regular sequence, or a zero otherwise.",
    "note": "In the first sample test a regular sequence is both a sequence of the first 6 beads ( we can take A = \" \" , B = \" bca\" ) , and a sequence of the first 7 beads ( we can take A = \" b\" , B = \" ca\" ) . In the second sample test, for example, a sequence of the first 13 beads is regular, if we take A = \" aba\" , B = \" ba\" .",
    "topics": [
      "hashing",
      "string suffix structures",
      "strings"
    ]
  },
  {
    "title": "Pasha and String",
    "url": "https://codeforces.com/problemset/problem/525/B",
    "history": "Pasha got a very beautiful string s for his birthday, the string consists of lowercase Latin letters. The letters in the string are numbered from 1 to | s| from left to right, where | s| is the length of the given string. Pasha didn' t like his present very much so he decided to change it. After his birthday Pasha spent m days performing the following transformations on his string \u2014 each day he chose integer ai and reversed a piece of string ( a segment) from position ai to position | s| - ai + 1. It is guaranteed that 2\u00b7ai \u2264 | s| . You face the following task: determine what Pasha' s string will look like after m days.",
    "input": "The first line of the input contains Pasha' s string s of length from 2 to 2\u00b7105 characters, consisting of lowercase Latin letters. The second line contains a single integer m ( 1 \u2264 m \u2264 105) \u2014 the number of days when Pasha changed his string. The third line contains m space- separated elements ai ( 1 \u2264 ai; 2\u00b7ai \u2264 | s| ) \u2014 the position from which Pasha started transforming the string on the i- th day.",
    "output": "In the first line of the output print what Pasha' s string s will look like after m days.",
    "note": "",
    "topics": [
      "constructive algorithms",
      "greedy",
      "math",
      "strings"
    ]
  },
  {
    "title": "Vitaliy and Pie",
    "url": "https://codeforces.com/problemset/problem/525/A",
    "history": "After a hard day Vitaly got very hungry and he wants to eat his favorite potato pie. But it' s not that simple. Vitaly is in the first room of the house with n room located in a line and numbered starting from one from left to right. You can go from the first room to the second room, from the second room to the third room and so on \u2014 you can go from the ( n - 1) - th room to the n- th room. Thus, you can go to room x only from room x - 1. The potato pie is located in the n- th room and Vitaly needs to go there. Each pair of consecutive rooms has a door between them. In order to go to room x from room x - 1, you need to open the door between the rooms with the corresponding key. In total the house has several types of doors ( represented by uppercase Latin letters) and several types of keys ( represented by lowercase Latin letters) . The key of type t can open the door of type T if and only if t and T are the same letter, written in different cases. For example, key f can open door F. Each of the first n - 1 rooms contains exactly one key of some type that Vitaly can use to get to next rooms. Once the door is open with some key, Vitaly won' t get the key from the keyhole but he will immediately run into the next room. In other words, each key can open no more than one door. Vitaly realizes that he may end up in some room without the key that opens the door to the next room. Before the start his run for the potato pie Vitaly can buy any number of keys of any type that is guaranteed to get to room n. Given the plan of the house, Vitaly wants to know what is the minimum number of keys he needs to buy to surely get to the room n, which has a delicious potato pie. Write a program that will help Vitaly find out this number.",
    "input": "The first line of the input contains a positive integer n ( 2 \u2264 n \u2264 105) \u2014 the number of rooms in the house. The second line of the input contains string s of length 2\u00b7n - 2. Let' s number the elements of the string from left to right, starting from one. The odd positions in the given string s contain lowercase Latin letters \u2014 the types of the keys that lie in the corresponding rooms. Thus, each odd position i of the given string s contains a lowercase Latin letter \u2014 the type of the key that lies in room number ( i + 1) / 2. The even positions in the given string contain uppercase Latin letters \u2014 the types of doors between the rooms. Thus, each even position i of the given string s contains an uppercase letter \u2014 the type of the door that leads from room i / 2 to room i / 2 + 1.",
    "output": "Print the only integer \u2014 the minimum number of keys that Vitaly needs to buy to surely get from room one to room n.",
    "note": "",
    "topics": [
      "greedy",
      "hashing",
      "strings"
    ]
  },
  {
    "title": "And Yet Another Bracket Sequence",
    "url": "https://codeforces.com/problemset/problem/524/F",
    "history": "Polycarpus has a finite sequence of opening and closing brackets. In order not to fall asleep in a lecture, Polycarpus is having fun with his sequence. He is able to perform two operations: adding any bracket in any position ( in the beginning, the end, or between any two existing brackets) ; cyclic shift \u2014 moving the last bracket from the end of the sequence to the beginning. Polycarpus can apply any number of operations to his sequence and adding a cyclic shift in any order. As a result, he wants to get the correct bracket sequence of the minimum possible length. If there are several such sequences, Polycarpus is interested in the lexicographically smallest one. Help him find such a sequence. Acorrect bracket sequence is a sequence of opening and closing brackets, from which you can get a correct arithmetic expression by adding characters \" 1\" and \" + \" . Each opening bracket must correspond to a closed one. For example, the sequences \" ( ( ) ) ( ) \" , \" ( ) \" , \" ( ( ) ( ( ) ) ) \" are correct and \" ) ( \" , \" ( ( ) \" and \" ( ( ) ) ) ( \" are not. The sequence a1 a2. . . an is lexicographically smaller than sequence b1 b2. . . bn, if there is such number i from 1 to n, thatak = bk for 1 \u2264 k < i and ai < bi. Consider that \" ( \" < \" ) \" .",
    "input": "The first line contains Polycarpus' s sequence consisting of characters \" ( \" and \" ) \" . The length of a line is from 1 to 1 000 000.",
    "output": "Print a correct bracket sequence of the minimum length that Polycarpus can obtain by his operations. If there are multiple such sequences, print the lexicographically minimum one.",
    "note": "The sequence in the first example is already correct, but to get the lexicographically minimum answer, you need to perform four cyclic shift operations. In the second example you need to add a closing parenthesis between the second and third brackets and make a cyclic shift. You can first make the shift, and then add the bracket at the end.",
    "topics": [
      "data structures",
      "greedy",
      "hashing",
      "string suffix structures",
      "strings"
    ]
  },
  {
    "title": "DNA Alignment",
    "url": "https://codeforces.com/problemset/problem/520/C",
    "history": "Vasya became interested in bioinformatics. He' s going to write an article about similar cyclic DNA sequences, so he invented a new method for determining the similarity of cyclic sequences. Let' s assume that strings s and t have the same length n, then the function h( s, t) is defined as the number of positions in which the respective symbols of s and t are the same. Function h( s, t) can be used to define the function of Vasya distance \u03c1( s, t) : where is obtained from string s, by applying left circular shift i times. For example, \u03c1( \" AGC\" , \" CGT\" ) = h( \" AGC\" , \" CGT\" ) + h( \" AGC\" , \" GTC\" ) + h( \" AGC\" , \" TCG\" ) + h( \" GCA\" , \" CGT\" ) + h( \" GCA\" , \" GTC\" ) + h( \" GCA\" , \" TCG\" ) + h( \" CAG\" , \" CGT\" ) + h( \" CAG\" , \" GTC\" ) + h( \" CAG\" , \" TCG\" ) = 1 + 1 + 0 + 0 + 1 + 1 + 1 + 0 + 1 = 6Vasya found a string s of length n on the Internet. Now he wants to count how many strings t there are such that the Vasya distance from the string s attains maximum possible value. Formally speaking, t must satisfy the equation: . Vasya could not try all possible strings to find an answer, so he needs your help. As the answer may be very large, count the number of such strings modulo 109 + 7.",
    "input": "The first line of the input contains a single integer n ( 1 \u2264 n \u2264 105) . The second line of the input contains a single string of length n, consisting of characters \" ACGT\" .",
    "output": "Print a single number \u2014 the answer modulo 109 + 7.",
    "note": "Please note that if for two distinct strings t1 and t2 values \u03c1( s, t1) \u0438 \u03c1( s, t2) are maximum among all possible t, then both strings must be taken into account in the answer even if one of them can be obtained by a circular shift of another one. In the first sample, there is \u03c1( \" C\" , \" C\" ) = 1, for the remaining strings t of length 1 the value of \u03c1( s, t) is 0. In the second sample, \u03c1( \" AG\" , \" AG\" ) = \u03c1( \" AG\" , \" GA\" ) = \u03c1( \" AG\" , \" AA\" ) = \u03c1( \" AG\" , \" GG\" ) = 4. In the third sample, \u03c1( \" TTT\" , \" TTT\" ) = 27",
    "topics": [
      "math",
      "strings"
    ]
  },
  {
    "title": "Pangram",
    "url": "https://codeforces.com/problemset/problem/520/A",
    "history": "A word or a sentence in some language is called a pangram if all the characters of the alphabet of this language appear in it at least once. Pangrams are often used to demonstrate fonts in printing or test the output devices. You are given a string consisting of lowercase and uppercase Latin letters. Check whether this string is a pangram. We say that the string contains a letter of the Latin alphabet if this letter occurs in the string in uppercase or lowercase.",
    "input": "The first line contains a single integer n ( 1 \u2264 n \u2264 100) \u2014 the number of characters in the string. The second line contains the string. The string consists only of uppercase and lowercase Latin letters.",
    "output": "Output \" YES\" , if the string is a pangram and \" NO\" otherwise.",
    "note": "",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Tanya and Postcard",
    "url": "https://codeforces.com/problemset/problem/518/B",
    "history": "Little Tanya decided to present her dad a postcard on his Birthday. She has already created a message \u2014 string s of length n, consisting of uppercase and lowercase English letters. Tanya can' t write yet, so she found a newspaper and decided to cut out the letters and glue them into the postcard to achieve string s. The newspaper contains string t, consisting of uppercase and lowercase English letters. We know that the length of string t greater or equal to the length of the string s. The newspaper may possibly have too few of some letters needed to make the text and too many of some other letters. That' s why Tanya wants to cut some n letters out of the newspaper and make a message of length exactly n, so that it looked as much as possible like s. If the letter in some position has correct value and correct letter case ( in the string s and in the string that Tanya will make) , then she shouts joyfully \" YAY! \" , and if the letter in the given position has only the correct value but it is in the wrong case, then the girl says \" WHOOPS\" . Tanya wants to make such message that lets her shout \" YAY! \" as much as possible. If there are multiple ways to do this, then her second priority is to maximize the number of times she says \" WHOOPS\" . Your task is to help Tanya make the message.",
    "input": "The first line contains line s ( 1 \u2264 | s| \u2264 2\u00b7105) , consisting of uppercase and lowercase English letters \u2014 the text of Tanya' s message. The second line contains line t ( | s| \u2264 | t| \u2264 2\u00b7105) , consisting of uppercase and lowercase English letters \u2014 the text written in the newspaper. Here | a| means the length of the string a.",
    "output": "Print two integers separated by a space: the first number is the number of times Tanya shouts \" YAY! \" while making the message, the second number is the number of times Tanya says \" WHOOPS\" while making the message.",
    "note": "",
    "topics": [
      "greedy",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Vitaly and Strings",
    "url": "https://codeforces.com/problemset/problem/518/A",
    "history": "Vitaly is a diligent student who never missed a lesson in his five years of studying in the university. He always does his homework on time and passes his exams in time. During the last lesson the teacher has provided two strings s and t to Vitaly. The strings have the same length, they consist of lowercase English letters, string s is lexicographically smaller than string t. Vitaly wondered if there is such string that is lexicographically larger than string s and at the same is lexicographically smaller than string t. This string should also consist of lowercase English letters and have the length equal to the lengths of strings s and t. Let' s help Vitaly solve this easy problem!",
    "input": "The first line contains string s ( 1 \u2264 | s| \u2264 100) , consisting of lowercase English letters. Here, | s| denotes the length of the string. The second line contains string t ( | t| = | s| ) , consisting of lowercase English letters. It is guaranteed that the lengths of strings s and t are the same and string s is lexicographically less than string t.",
    "output": "If the string that meets the given requirements doesn' t exist, print a single string \" No such string\" ( without the quotes) . If such string exists, print it. If there are multiple valid strings, you may print any of them.",
    "note": "String s = s1s2. . . sn is said to be lexicographically smaller than t = t1t2. . . tn, if there exists such i, that s1 = t1, s2 = t2, . . . si - 1 = ti - 1, si < ti.",
    "topics": [
      "constructive algorithms",
      "strings"
    ]
  },
  {
    "title": "Watto and Mechanism",
    "url": "https://codeforces.com/problemset/problem/514/C",
    "history": "Watto, the owner of a spare parts store, has recently got an order for the mechanism that can process strings in a certain way. Initially the memory of the mechanism is filled with n strings. Then the mechanism should be able to process queries of the following type: \" Given string s, determine if the memory of the mechanism contains string t that consists of the same number of characters as s and differs from s in exactly one position\" . Watto has already compiled the mechanism, all that' s left is to write a program for it and check it on the data consisting of n initial lines and m queries. He decided to entrust this job to you.",
    "input": "The first line contains two non- negative numbers n and m ( 0 \u2264 n \u2264 3\u00b7105, 0 \u2264 m \u2264 3\u00b7105) \u2014 the number of the initial strings and the number of queries, respectively. Next follow n non- empty strings that are uploaded to the memory of the mechanism. Next follow m non- empty strings that are the queries to the mechanism. The total length of lines in the input doesn' t exceed 6\u00b7105. Each line consists only of letters ' a' , ' b' , ' c' .",
    "output": "For each query print on a single line \" YES\" ( without the quotes) , if the memory of the mechanism contains the required string, otherwise print \" NO\" ( without the quotes) .",
    "note": "",
    "topics": [
      "binary search",
      "data structures",
      "hashing",
      "string suffix structures",
      "strings"
    ]
  },
  {
    "title": "Pretty Song",
    "url": "https://codeforces.com/problemset/problem/509/E",
    "history": "When Sasha was studying in the seventh grade, he started listening to music a lot. In order to evaluate which songs he likes more, he introduced the notion of the song' s prettiness. The title of the song is a word consisting of uppercase Latin letters. The prettiness of the song is the prettiness of its title. Let' s define the simple prettiness of a word as the ratio of the number of vowels in the word to the number of all letters in the word. Let' s define the prettiness of a word as the sum of simple prettiness of all the substrings of the word. More formally, let' s define the function vowel( c) which is equal to 1, if c is a vowel, and to 0 otherwise. Let si be the i- th character of string s, and si. . j be the substring of word s, staring at the i- th character and ending at the j- th character ( sisi + 1. . . sj, i \u2264 j) . Then the simple prettiness of s is defined by the formula: The prettiness of s equals Find the prettiness of the given song title. We assume that the vowels are I, E, A, O, U, Y.",
    "input": "The input contains a single string s ( 1 \u2264 | s| \u2264 5\u00b7105) \u2014 the title of the song.",
    "output": "Print the prettiness of the song with the absolute or relative error of at most 10 - 6.",
    "note": "In the first sample all letters are vowels. The simple prettiness of each substring is 1. The word of length 7 has 28 substrings. So, the prettiness of the song equals to 28.",
    "topics": [
      "math",
      "strings"
    ]
  },
  {
    "title": "Anton and currency you all know",
    "url": "https://codeforces.com/problemset/problem/508/B",
    "history": "Berland, 2016. The exchange rate of currency you all know against the burle has increased so much that to simplify the calculations, its fractional part was neglected and the exchange rate is now assumed to be an integer. Reliable sources have informed the financier Anton of some information about the exchange rate of currency you all know against the burle for tomorrow. Now Anton knows that tomorrow the exchange rate will be an even number, which can be obtained from the present rate by swapping exactly two distinct digits in it. Of all the possible values that meet these conditions, the exchange rate for tomorrow will be the maximum possible. It is guaranteed that today the exchange rate is an odd positive integer n. Help Anton to determine the exchange rate of currency you all know for tomorrow!",
    "input": "The first line contains an odd positive integer n \u2014 the exchange rate of currency you all know for today. The length of number n' s representation is within range from 2 to 105, inclusive. The representation of n doesn' t contain any leading zeroes.",
    "output": "If the information about tomorrow' s exchange rate is inconsistent, that is, there is no integer that meets the condition, print - 1. Otherwise, print the exchange rate of currency you all know against the burle for tomorrow. This should be the maximum possible number of those that are even and that are obtained from today' s exchange rate by swapping exactly two digits. Exchange rate representation should not contain leading zeroes.",
    "note": "",
    "topics": [
      "greedy",
      "math",
      "strings"
    ]
  },
  {
    "title": "Mr. Kitayuta's Gift",
    "url": "https://codeforces.com/problemset/problem/506/E",
    "history": "Mr. Kitayuta has kindly given you a string s consisting of lowercase English letters. You are asked to insert exactly n lowercase English letters into s to make it a palindrome. ( A palindrome is a string that reads the same forward and backward. For example, \" noon\" , \" testset\" and \" a\" are all palindromes, while \" test\" and \" kitayuta\" are not. ) You can choose any n lowercase English letters, and insert each of them to any position of s, possibly to the beginning or the end of s. You have to insert exactly n letters even if it is possible to turn s into a palindrome by inserting less than n letters. Find the number of the palindromes that can be obtained in this way, modulo 10007.",
    "input": "The first line contains a string s ( 1 \u2264 | s| \u2264 200) . Each character in s is a lowercase English letter. The second line contains an integer n ( 1 \u2264 n \u2264 109) .",
    "output": "Print the number of the palindromes that can be obtained, modulo 10007.",
    "note": "For the first sample, you can obtain the palindrome \" reviver\" by inserting ' r' to the end of \" revive\" . For the second sample, the following 28 palindromes can be obtained: \" adada\" , \" adbda\" , . . . , \" adzda\" , \" dadad\" and \" ddadd\" .",
    "topics": [
      "combinatorics",
      "dp",
      "matrices",
      "strings"
    ]
  },
  {
    "title": "Mr. Kitayuta's Gift",
    "url": "https://codeforces.com/problemset/problem/505/A",
    "history": "Mr. Kitayuta has kindly given you a string s consisting of lowercase English letters. You are asked to insert exactly one lowercase English letter into s to make it a palindrome. A palindrome is a string that reads the same forward and backward. For example, \" noon\" , \" testset\" and \" a\" are all palindromes, while \" test\" and \" kitayuta\" are not. You can choose any lowercase English letter, and insert it to any position of s, possibly to the beginning or the end of s. You have to insert a letter even if the given string is already a palindrome. If it is possible to insert one lowercase English letter into s so that the resulting string will be a palindrome, print the string after the insertion. Otherwise, print \" NA\" ( without quotes, case- sensitive) . In case there is more than one palindrome that can be obtained, you are allowed to print any of them.",
    "input": "The only line of the input contains a string s ( 1 \u2264 | s| \u2264 10) . Each character in s is a lowercase English letter.",
    "output": "If it is possible to turn s into a palindrome by inserting one lowercase English letter, print the resulting string in a single line. Otherwise, print \" NA\" ( without quotes, case- sensitive) . In case there is more than one solution, any of them will be accepted.",
    "note": "For the first sample, insert ' r' to the end of \" revive\" to obtain a palindrome \" reviver\" . For the second sample, there is more than one solution. For example, \" eve\" will also be accepted. For the third sample, it is not possible to turn \" kitayuta\" into a palindrome by just inserting one letter.",
    "topics": [
      "brute force",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Misha and Changing Handles",
    "url": "https://codeforces.com/problemset/problem/501/B",
    "history": "Misha hacked the Codeforces site. Then he decided to let all the users change their handles. A user can now change his handle any number of times. But each new handle must not be equal to any handle that is already used or that was used at some point. Misha has a list of handle change requests. After completing the requests he wants to understand the relation between the original and the new handles of the users. Help him to do that.",
    "input": "The first line contains integer q ( 1 \u2264 q \u2264 1000) , the number of handle change requests. Next q lines contain the descriptions of the requests, one per line. Each query consists of two non- empty strings old and new, separated by a space. The strings consist of lowercase and uppercase Latin letters and digits. Strings old and new are distinct. The lengths of the strings do not exceed 20. The requests are given chronologically. In other words, by the moment of a query there is a single person with handle old, and handle new is not used and has not been used by anyone.",
    "output": "In the first line output the integer n \u2014 the number of users that changed their handles at least once. In the next n lines print the mapping between the old and the new handles of the users. Each of them must contain two strings, old and new, separated by a space, meaning that before the user had handle old, and after all the requests are completed, his handle is new. You may output lines in any order. Each user who changes the handle must occur exactly once in this description.",
    "note": "",
    "topics": [
      "data structures",
      "dsu",
      "strings"
    ]
  },
  {
    "title": "Lecture",
    "url": "https://codeforces.com/problemset/problem/499/B",
    "history": "You have a new professor of graph theory and he speaks very quickly. You come up with the following plan to keep up with his lecture and make notes. You know two languages, and the professor is giving the lecture in the first one. The words in both languages consist of lowercase English characters, each language consists of several words. For each language, all words are distinct, i. e. they are spelled differently. Moreover, the words of these languages have a one- to- one correspondence, that is, for each word in each language, there exists exactly one word in the other language having has the same meaning. You can write down every word the professor says in either the first language or the second language. Of course, during the lecture you write down each word in the language in which the word is shorter. In case of equal lengths of the corresponding words you prefer the word of the first language. You are given the text of the lecture the professor is going to read. Find out how the lecture will be recorded in your notes.",
    "input": "The first line contains two integers, n and m ( 1 \u2264 n \u2264 3000, 1 \u2264 m \u2264 3000) \u2014 the number of words in the professor' s lecture and the number of words in each of these languages. The following m lines contain the words. The i- th line contains two strings ai, bi meaning that the word ai belongs to the first language, the word bi belongs to the second language, and these two words have the same meaning. It is guaranteed that no word occurs in both languages, and each word occurs in its language exactly once. The next line contains n space- separated strings c1, c2, . . . , cn \u2014 the text of the lecture. It is guaranteed that each of the strings ci belongs to the set of strings a1, a2, . . . am. All the strings in the input are non- empty, each consisting of no more than 10 lowercase English letters.",
    "output": "Output exactly n words: how you will record the lecture in your notebook. Output the words of the lecture in the same order as in the input.",
    "note": "",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Obsessive String",
    "url": "https://codeforces.com/problemset/problem/494/B",
    "history": "Hamed has recently found a string t and suddenly became quite fond of it. He spent several days trying to find all occurrences of t in other strings he had. Finally he became tired and started thinking about the following problem. Given a string s how many ways are there to extract k \u2265 1 non- overlapping substrings from it such that each of them contains string t as a substring? More formally, you need to calculate the number of ways to choose two sequences a1, a2, . . . , ak and b1, b2, . . . , bk satisfying the following requirements: k \u2265 1 t is a substring of string saisai + 1. . . sbi ( string s is considered as 1- indexed) . As the number of ways can be rather large print it modulo 109 + 7.",
    "input": "Input consists of two lines containing strings s and t ( 1 \u2264 | s| , | t| \u2264 105) . Each string consists of lowercase Latin letters.",
    "output": "Print the answer in a single line.",
    "note": "",
    "topics": [
      "dp",
      "strings"
    ]
  },
  {
    "title": "Hacking Cypher",
    "url": "https://codeforces.com/problemset/problem/490/C",
    "history": "Polycarpus participates in a competition for hacking into a new secure messenger. He' s almost won. Having carefully studied the interaction protocol, Polycarpus came to the conclusion that the secret key can be obtained if he properly cuts the public key of the application into two parts. The public key is a long integer which may consist of even a million digits! Polycarpus needs to find such a way to cut the public key into two nonempty parts, that the first ( left) part is divisible by a as a separate number, and the second ( right) part is divisible by b as a separate number. Both parts should be positive integers that have no leading zeros. Polycarpus knows values a and b. Help Polycarpus and find any suitable method to cut the public key.",
    "input": "The first line of the input contains the public key of the messenger \u2014 an integer without leading zeroes, its length is in range from 1 to 106 digits. The second line contains a pair of space- separated positive integers a, b ( 1 \u2264 a, b \u2264 108) .",
    "output": "In the first line print \" YES\" ( without the quotes) , if the method satisfying conditions above exists. In this case, next print two lines \u2014 the left and right parts after the cut. These two parts, being concatenated, must be exactly identical to the public key. The left part must be divisible by a, and the right part must be divisible by b. The two parts must be positive integers having no leading zeros. If there are several answers, print any of them. If there is no answer, print in a single line \" NO\" ( without the quotes) .",
    "note": "",
    "topics": [
      "brute force",
      "math",
      "number theory",
      "strings"
    ]
  },
  {
    "title": "Dreamoon and Binary",
    "url": "https://codeforces.com/problemset/problem/477/D",
    "history": "Dreamoon saw a large integer x written on the ground and wants to print its binary form out. Dreamoon has accomplished the part of turning x into its binary format. Now he is going to print it in the following manner. He has an integer n = 0 and can only perform the following two operations in any order for unlimited times each: Print n in binary form without leading zeros, each print will append to the right of previous prints. Increase n by 1. Let' s define an ideal sequence as a sequence of operations that can successfully print binary representation of x without leading zeros and ends with a print operation ( i. e. operation 1) . Dreamoon wants to know how many different ideal sequences are there and the length ( in operations) of the shortest ideal sequence. The answers might be large so please print them modulo 1000000007 ( 109 + 7) . Let' s define the string representation of an ideal sequence as a string of ' 1' and ' 2' where the i- th character in the string matches the i- th operation performed. Two ideal sequences are called different if their string representations are different.",
    "input": "The single line of the input contains a binary integer representing x ( 1 \u2264 x < 25000) without leading zeros.",
    "output": "The first line of the output should contain an integer representing the number of different ideal sequences modulo 1000000007 ( 109 + 7) . The second line of the output contains an integer representing the minimal length of an ideal sequence modulo 1000000007 ( 109 + 7) .",
    "note": "For the first sample, the shortest and the only ideal sequence is \u00ab222221\u00bb of length 6. For the second sample, there are three ideal sequences \u00ab21211\u00bb, \u00ab212222222221\u00bb, \u00ab222222222222222222222222221\u00bb. Among them the shortest one has length 5.",
    "topics": [
      "dp",
      "strings"
    ]
  },
  {
    "title": "Dreamoon and Strings",
    "url": "https://codeforces.com/problemset/problem/476/E",
    "history": "Dreamoon has a string s and a pattern string p. He first removes exactly x characters from s obtaining string s' as a result. Then he calculates that is defined as the maximal number of non- overlapping substrings equal to p that can be found in s' . He wants to make this number as big as possible. More formally, let' s define as maximum value of over all s' that can be obtained by removing exactly x characters from s. Dreamoon wants to know for all x from 0 to | s| where | s| denotes the length of string s.",
    "input": "The first line of the input contains the string s ( 1 \u2264 | s| \u2264 2 000) . The second line of the input contains the string p ( 1 \u2264 | p| \u2264 500) . Both strings will only consist of lower case English letters.",
    "output": "Print | s| + 1 space- separated integers in a single line representing the for all x from 0 to | s| .",
    "note": "For the first sample, the corresponding optimal values of s' after removal 0 through | s| = 5 characters from s are \" aaaaa\" , \" aaaa\" , \" aaa\" , \" aa\" , \" a\" , \" \" . For the second sample, possible corresponding optimal values of s' are \" axbaxxb\" , \" abaxxb\" , \" axbab\" , \" abab\" , \" aba\" , \" ab\" , \" a\" , \" \" .",
    "topics": [
      "dp",
      "strings"
    ]
  },
  {
    "title": "MUH and Cube Walls",
    "url": "https://codeforces.com/problemset/problem/471/D",
    "history": "Polar bears Menshykov and Uslada from the zoo of St. Petersburg and elephant Horace from the zoo of Kiev got hold of lots of wooden cubes somewhere. They started making cube towers by placing the cubes one on top of the other. They defined multiple towers standing in a line as a wall. A wall can consist of towers of different heights. Horace was the first to finish making his wall. He called his wall an elephant. The wall consists of w towers. The bears also finished making their wall but they didn' t give it a name. Their wall consists of n towers. Horace looked at the bears' tower and wondered: in how many parts of the wall can he \" see an elephant\" ? He can \" see an elephant\" on a segment of w contiguous towers if the heights of the towers on the segment match as a sequence the heights of the towers in Horace' s wall. In order to see as many elephants as possible, Horace can raise and lower his wall. He even can lower the wall below the ground level ( see the pictures to the samples for clarification) . Your task is to count the number of segments where Horace can \" see an elephant\" .",
    "input": "The first line contains two integers n and w ( 1 \u2264 n, w \u2264 2\u00b7105) \u2014 the number of towers in the bears' and the elephant' s walls correspondingly. The second line contains n integers ai ( 1 \u2264 ai \u2264 109) \u2014 the heights of the towers in the bears' wall. The third line contains w integers bi ( 1 \u2264 bi \u2264 109) \u2014 the heights of the towers in the elephant' s wall.",
    "output": "Print the number of segments in the bears' wall where Horace can \" see an elephant\" .",
    "note": "The picture to the left shows Horace' s wall from the sample, the picture to the right shows the bears' wall. The segments where Horace can \" see an elephant\" are in gray.",
    "topics": [
      "string suffix structures",
      "strings"
    ]
  },
  {
    "title": "Fedor and Essay",
    "url": "https://codeforces.com/problemset/problem/467/D",
    "history": "After you had helped Fedor to find friends in the \u00abCall of Soldiers 3\u00bb game, he stopped studying completely. Today, the English teacher told him to prepare an essay. Fedor didn' t want to prepare the essay, so he asked Alex for help. Alex came to help and wrote the essay for Fedor. But Fedor didn' t like the essay at all. Now Fedor is going to change the essay using the synonym dictionary of the English language. Fedor does not want to change the meaning of the essay. So the only change he would do: change a word from essay to one of its synonyms, basing on a replacement rule from the dictionary. Fedor may perform this operation any number of times. As a result, Fedor wants to get an essay which contains as little letters \u00abR\u00bb ( the case doesn' t matter) as possible. If there are multiple essays with minimum number of \u00abR\u00bbs he wants to get the one with minimum length ( length of essay is the sum of the lengths of all the words in it) . Help Fedor get the required essay. Please note that in this problem the case of letters doesn' t matter. For example, if the synonym dictionary says that word cat can be replaced with word DOG, then it is allowed to replace the word Cat with the word doG.",
    "input": "The first line contains a single integer m ( 1 \u2264 m \u2264 105) \u2014 the number of words in the initial essay. The second line contains words of the essay. The words are separated by a single space. It is guaranteed that the total length of the words won' t exceed 105 characters. The next line contains a single integer n ( 0 \u2264 n \u2264 105) \u2014 the number of pairs of words in synonym dictionary. The i- th of the next n lines contains two space- separated non- empty words xi and yi. They mean that word xi can be replaced with word yi ( but not vise versa) . It is guaranteed that the total length of all pairs of synonyms doesn' t exceed 5\u00b7105 characters. All the words at input can only consist of uppercase and lowercase letters of the English alphabet.",
    "output": "Print two integers \u2014 the minimum number of letters \u00abR\u00bb in an optimal essay and the minimum length of an optimal essay.",
    "note": "",
    "topics": [
      "dfs and similar",
      "dp",
      "graphs",
      "hashing",
      "strings"
    ]
  },
  {
    "title": "No to Palindromes!",
    "url": "https://codeforces.com/problemset/problem/464/A",
    "history": "Paul hates palindromes. He assumes that string s is tolerable if each its character is one of the first p letters of the English alphabet and s doesn' t contain any palindrome contiguous substring of length 2 or more. Paul has found a tolerable string s of length n. Help him find the lexicographically next tolerable string of the same length or else state that such string does not exist.",
    "input": "The first line contains two space- separated integers: n and p ( 1 \u2264 n \u2264 1000; 1 \u2264 p \u2264 26) . The second line contains string s, consisting of n small English letters. It is guaranteed that the string is tolerable ( according to the above definition) .",
    "output": "If the lexicographically next tolerable string of the same length exists, print it. Otherwise, print \" NO\" ( without the quotes) .",
    "note": "String s is lexicographically larger ( or simply larger) than string t with the same length, if there is number i, such that s1 = t1, . . . , si = ti, si + 1 > ti + 1. The lexicographically next tolerable string is the lexicographically minimum tolerable string which is larger than the given one. A palindrome is a string that reads the same forward or reversed.",
    "topics": [
      "greedy",
      "strings"
    ]
  },
  {
    "title": "Appleman and a Game",
    "url": "https://codeforces.com/problemset/problem/461/E",
    "history": "Appleman and Toastman like games. Today they play a game with strings with the following rules. Firstly Toastman tells Appleman two strings s and t both consisting only of letters ' A' , ' B' , ' C' , ' D' . Then Appleman must build string s as quickly as possible. Initially he has empty string, and in one second he can append to end of the current string any contiguous substring of t. Now, Toastman and Appleman are beginning to play the game. Toastman has already told string t to Appleman, but he hasn' t come up with string s yet. Toastman only thinks, that he should choose string s consisting of n characters. Of course, he wants to find the worst string for Appleman ( such string, that Appleman will spend as much time as possible during the game) . Tell Toastman, how much time will Appleman spend during the game if Toastman finds the worst string for him. You can assume that Appleman plays optimally, therefore he builds any string s in minimal possible time.",
    "input": "The first line contains an integer n ( 1 \u2264 n \u2264 1018) . The second line contains string t ( 1 \u2264 | t| \u2264 105) . String t consists of only letters ' A' , ' B' , ' C' , ' D' . Each letter appears at least once in string t.",
    "output": "Print a single integer \u2014 the largest possible time Appleman needs.",
    "note": "In the first example, Toastman can choose s equal to \" AAAAA\" . In the second example, Toastman can choose s equal to \" DADDA\" .",
    "topics": [
      "binary search",
      "shortest paths",
      "strings"
    ]
  },
  {
    "title": "A Lot of Games",
    "url": "https://codeforces.com/problemset/problem/455/B",
    "history": "Andrew, Fedor and Alex are inventive guys. Now they invent the game with strings for two players. Given a group of n non- empty strings. During the game two players build the word together, initially the word is empty. The players move in turns. On his step player must add a single letter in the end of the word, the resulting word must be prefix of at least one string from the group. A player loses if he cannot move. Andrew and Alex decided to play this game k times. The player who is the loser of the i- th game makes the first move in the ( i + 1) - th game. Guys decided that the winner of all games is the player who wins the last ( k- th) game. Andrew and Alex already started the game. Fedor wants to know who wins the game if both players will play optimally. Help him.",
    "input": "The first line contains two integers, n and k ( 1 \u2264 n \u2264 105; 1 \u2264 k \u2264 109) . Each of the next n lines contains a single non- empty string from the given group. The total length of all strings from the group doesn' t exceed 105. Each string of the group consists only of lowercase English letters.",
    "output": "If the player who moves first wins, print \" First\" , otherwise print \" Second\" ( without the quotes) .",
    "note": "",
    "topics": [
      "dfs and similar",
      "dp",
      "games",
      "implementation",
      "strings",
      "trees"
    ]
  },
  {
    "title": "Three strings",
    "url": "https://codeforces.com/problemset/problem/452/E",
    "history": "You are given three strings ( s1, s2, s3) . For each integer l ( 1 \u2264 l \u2264 min( | s1| , | s2| , | s3| ) you need to find how many triples ( i1, i2, i3) exist such that three strings sk[ ik. . . ik + l - 1] ( k = 1, 2, 3) are pairwise equal. Print all found numbers modulo 1000000007 ( 109 + 7) . See notes if you are not sure about some of the denotions used in the statement.",
    "input": "First three lines contain three non- empty input strings. The sum of lengths of all strings is no more than 3\u00b7105. All strings consist only of lowercase English letters.",
    "output": "You need to output min( | s1| , | s2| , | s3| ) numbers separated by spaces \u2014 answers for the problem modulo 1000000007 ( 109 + 7) .",
    "note": "Consider a string t = t1t2. . . t| t| , where ti denotes the i- th character of the string, and | t| denotes the length of the string. Then t[ i. . . j] ( 1 \u2264 i \u2264 j \u2264 | t| ) represents the string titi + 1. . . tj ( substring of t from position i to position j inclusive) .",
    "topics": [
      "data structures",
      "dsu",
      "string suffix structures",
      "strings"
    ]
  },
  {
    "title": "Eevee",
    "url": "https://codeforces.com/problemset/problem/452/A",
    "history": "You are solving the crossword problem K from IPSC 2014. You solved all the clues except for one: who does Eevee evolve into? You are not very into pokemons, but quick googling helped you find out, that Eevee can evolve into eight different pokemons: Vaporeon, Jolteon, Flareon, Espeon, Umbreon, Leafeon, Glaceon, and Sylveon. You know the length of the word in the crossword, and you already know some letters. Designers of the crossword made sure that the answer is unambiguous, so you can assume that exactly one pokemon out of the 8 that Eevee evolves into fits the length and the letters given. Your task is to find it.",
    "input": "First line contains an integer n ( 6 \u2264 n \u2264 8) \u2013 the length of the string. Next line contains a string consisting of n characters, each of which is either a lower case english letter ( indicating a known letter) or a dot character ( indicating an empty cell in the crossword) .",
    "output": "Print a name of the pokemon that Eevee can evolve into that matches the pattern in the input. Use lower case letters only to print the name ( in particular, do not capitalize the first letter) .",
    "note": "Here' s a set of names in a form you can paste into your solution: [ \" vaporeon\" , \" jolteon\" , \" flareon\" , \" espeon\" , \" umbreon\" , \" leafeon\" , \" glaceon\" , \" sylveon\" ] \" vaporeon\" , \" jolteon\" , \" flareon\" , \" espeon\" , \" umbreon\" , \" leafeon\" , \" glaceon\" , \" sylveon\"",
    "topics": [
      "brute force",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Suffix Structures",
    "url": "https://codeforces.com/problemset/problem/448/B",
    "history": "Bizon the Champion isn' t just a bison. He also is a favorite of the \" Bizons\" team. At a competition the \" Bizons\" got the following problem: \" You are given two distinct words ( strings of English letters) , s and t. You need to transform word s into word t\" . The task looked simple to the guys because they know the suffix data structures well. Bizon Senior loves suffix automaton. By applying it once to a string, he can remove from this string any single character. Bizon Middle knows suffix array well. By applying it once to a string, he can swap any two characters of this string. The guys do not know anything about the suffix tree, but it can help them do much more. Bizon the Champion wonders whether the \" Bizons\" can solve the problem. Perhaps, the solution do not require both data structures. Find out whether the guys can solve the problem and if they can, how do they do it? Can they solve it either only with use of suffix automaton or only with use of suffix array or they need both structures? Note that any structure may be used an unlimited number of times, the structures may be used in any order.",
    "input": "The first line contains a non- empty word s. The second line contains a non- empty word t. Words s and t are different. Each word consists only of lowercase English letters. Each word contains at most 100 letters.",
    "output": "In the single line print the answer to the problem. Print \" need tree\" ( without the quotes) if word s cannot be transformed into word t even with use of both suffix array and suffix automaton. Print \" automaton\" ( without the quotes) if you need only the suffix automaton to solve the problem. Print \" array\" ( without the quotes) if you need only the suffix array to solve the problem. Print \" both\" ( without the quotes) , if you need both data structures to solve the problem. It' s guaranteed that if you can solve the problem only with use of suffix array, then it is impossible to solve it only with use of suffix automaton. This is also true for suffix automaton.",
    "note": "In the third sample you can act like that: first transform \" both\" into \" oth\" by removing the first character using the suffix automaton and then make two swaps of the string using the suffix array and get \" hot\" .",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "DZY Loves Strings",
    "url": "https://codeforces.com/problemset/problem/444/D",
    "history": "DZY loves strings, and he enjoys collecting them. In China, many people like to use strings containing their names' initials, for example: xyz, jcvb, dzy, dyh. Once DZY found a lucky string s. A lot of pairs of good friends came to DZY when they heard about the news. The first member of the i- th pair has name ai, the second one has name bi. Each pair wondered if there is a substring of the lucky string containing both of their names. If so, they want to find the one with minimum length, which can give them good luck and make their friendship last forever. Please help DZY for each pair find the minimum length of the substring of s that contains both ai and bi, or point out that such substring doesn' t exist. A substring of s is a string slsl + 1. . . sr for some integers l, r ( 1 \u2264 l \u2264 r \u2264 | s| ) . The length of such the substring is ( r - l + 1) . A string p contains some another string q if there is a substring of p equal to q.",
    "input": "The first line contains a string s ( 1 \u2264 | s| \u2264 50000) . The second line contains a non- negative integer q ( 0 \u2264 q \u2264 100000) \u2014 the number of pairs. Each of the next q lines describes a pair, the line contains two space- separated strings ai and bi ( 1 \u2264 | ai| , | bi| \u2264 4) . It is guaranteed that all the strings only consist of lowercase English letters.",
    "output": "For each pair, print a line containing a single integer \u2014 the minimum length of the required substring. If there is no such substring, output - 1.",
    "note": "The shortest substrings in the first sample are: xyz, dyhduxyz. The shortest substrings in the second sample are: ca, abc and abd. The shortest substrings in the third sample are: baabca and abaa.",
    "topics": [
      "binary search",
      "hashing",
      "strings",
      "two pointers"
    ]
  },
  {
    "title": "Kolya and Tandem Repeat",
    "url": "https://codeforces.com/problemset/problem/443/B",
    "history": "Kolya got string s for his birthday, the string consists of small English letters. He immediately added k more characters to the right of the string. Then Borya came and said that the new string contained a tandem repeat of length l as a substring. How large could l be? See notes for definition of a tandem repeat.",
    "input": "The first line contains s ( 1 \u2264 | s| \u2264 200) . This string contains only small English letters. The second line contains number k ( 1 \u2264 k \u2264 200) \u2014 the number of the added characters.",
    "output": "Print a single number \u2014 the maximum length of the tandem repeat that could have occurred in the new string.",
    "note": "A tandem repeat of length 2n is string s, where for any position i ( 1 \u2264 i \u2264 n) the following condition fulfills: si = si + n. In the first sample Kolya could obtain a string aabaab, in the second \u2014 aaabbbbbb, in the third \u2014 abracadabrabracadabra.",
    "topics": [
      "brute force",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Prefixes and Suffixes",
    "url": "https://codeforces.com/problemset/problem/432/D",
    "history": "You have a string s = s1s2. . . s| s| , where | s| is the length of string s, and si its i- th character. Let' s introduce several definitions: A substring s[ i. . j] ( 1 \u2264 i \u2264 j \u2264 | s| ) of string s is string sisi + 1. . . sj. The prefix of string s of length l ( 1 \u2264 l \u2264 | s| ) is string s[ 1. . l] . The suffix of string s of length l ( 1 \u2264 l \u2264 | s| ) is string s[ | s| - l + 1. . | s| ] . Your task is, for any prefix of string s which matches a suffix of string s, print the number of times it occurs in string s as a substring.",
    "input": "The single line contains a sequence of characters s1s2. . . s| s| ( 1 \u2264 | s| \u2264 105) \u2014 string s. The string only consists of uppercase English letters.",
    "output": "In the first line, print integer k ( 0 \u2264 k \u2264 | s| ) \u2014 the number of prefixes that match a suffix of string s. Next print k lines, in each line print two integers li ci. Numbers li ci mean that the prefix of the length li matches the suffix of length li and occurs in string s as a substring ci times. Print pairs li ci in the order of increasing li.",
    "note": "",
    "topics": [
      "dp",
      "string suffix structures",
      "strings",
      "two pointers"
    ]
  },
  {
    "title": "Match & Catch",
    "url": "https://codeforces.com/problemset/problem/427/D",
    "history": "Police headquarter is monitoring signal on different frequency levels. They have got two suspiciously encoded strings s1 and s2 from two different frequencies as signals. They are suspecting that these two strings are from two different criminals and they are planning to do some evil task. Now they are trying to find a common substring of minimum length between these two strings. The substring must occur only once in the first string, and also it must occur only once in the second string. Given two strings s1 and s2 consist of lowercase Latin letters, find the smallest ( by length) common substring p of both s1 and s2, where p is a unique substring in s1 and also in s2. See notes for formal definition of substring and uniqueness.",
    "input": "The first line of input contains s1 and the second line contains s2 ( 1 \u2264 | s1| , | s2| \u2264 5000) . Both strings consist of lowercase Latin letters.",
    "output": "Print the length of the smallest common unique substring of s1 and s2. If there are no common unique substrings of s1 and s2 print - 1.",
    "note": "Imagine we have string a = a1a2a3. . . a| a| , where | a| is the length of string a, and ai is the ith letter of the string. We will call string alal + 1al + 2. . . ar ( 1 \u2264 l \u2264 r \u2264 | a| ) the substring [ l, r] of the string a. The substring [ l, r] is unique in a if and only if there is no pair l1, r1 such that l1 = \u0338 l and the substring [ l1, r1] is equal to the substring [ l, r] in a.",
    "topics": [
      "dp",
      "string suffix structures",
      "strings"
    ]
  },
  {
    "title": "Pattern",
    "url": "https://codeforces.com/problemset/problem/412/C",
    "history": "Developers often face with regular expression patterns. A pattern is usually defined as a string consisting of characters and metacharacters that sets the rules for your search. These patterns are most often used to check whether a particular string meets the certain rules. In this task, a pattern will be a string consisting of small English letters and question marks ( ' ? ' ) . The question mark in the pattern is a metacharacter that denotes an arbitrary small letter of the English alphabet. We will assume that a string matches the pattern if we can transform the string into the pattern by replacing the question marks by the appropriate characters. For example, string aba matches patterns: ? ? ? , ? ? a, a? a, aba. Programmers that work for the R1 company love puzzling each other ( and themselves) with riddles. One of them is as follows: you are given n patterns of the same length, you need to find a pattern that contains as few question marks as possible, and intersects with each of the given patterns. Two patterns intersect if there is a string that matches both the first and the second pattern. Can you solve this riddle?",
    "input": "The first line contains a single integer n ( 1 \u2264 n \u2264 105) \u2014 the number of patterns. Next n lines contain the patterns. It is guaranteed that the patterns can only consist of small English letters and symbols ' ? ' . All patterns are non- empty and have the same length. The total length of all the patterns does not exceed 105 characters.",
    "output": "In a single line print the answer to the problem \u2014 the pattern with the minimal number of signs ' ? ' , which intersects with each of the given ones. If there are several answers, print any of them.",
    "note": "Consider the first example. Pattern xab intersects with each of the given patterns. Pattern ? ? ? also intersects with each of the given patterns, but it contains more question signs, hence it is not an optimal answer. Clearly, xab is the optimal answer, because it doesn' t contain any question sign. There are a lot of other optimal answers, for example: aab, bab, cab, dab and so on.",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Diverse Substrings",
    "url": "https://codeforces.com/problemset/problem/386/C",
    "history": "String diversity is the number of symbols that occur in the string at least once. Diversity of s will be denoted by d( s) . For example , d( \" aaa\" ) = 1, d( \" abacaba\" ) = 3. Given a string s, consisting of lowercase Latin letters. Consider all its substrings. Obviously, any substring diversity is a number from 1 to d( s) . Find statistics about substrings diversity: for each k from 1 to d( s) , find how many substrings of s has a diversity of exactly k.",
    "input": "The input consists of a single line containing s. It contains only lowercase Latin letters, the length of s is from 1 to 3\u00b7105.",
    "output": "Print to the first line the value d( s) . Print sequence t1, t2, . . . , td( s) to the following lines, where ti is the number of substrings of s having diversity of exactly i.",
    "note": "Consider the first example. We denote by s( i, j) a substring of \" abca\" with the indices in the segment [ i, j] . s( 1, 1) = \" a\" , d( \" a\" ) = 1 s( 2, 2) = \" b\" , d( \" b\" ) = 1 s( 3, 3) = \" c\" , d( \" c\" ) = 1 s( 4, 4) = \" a\" , d( \" a\" ) = 1 s( 1, 2) = \" ab\" , d( \" ab\" ) = 2 s( 2, 3) = \" bc\" , d( \" bc\" ) = 2 s( 3, 4) = \" ca\" , d( \" ca\" ) = 2 s( 1, 3) = \" abc\" , d( \" abc\" ) = 3 s( 2, 4) = \" bca\" , d( \" bca\" ) = 3 s( 1, 4) = \" abca\" , d( \" abca\" ) = 3 Total number of substring with diversity 1 is 4, with diversity 2 equals 3, 3 diversity is 3.",
    "topics": [
      "dp",
      "strings",
      "two pointers"
    ]
  },
  {
    "title": "Bear and Strings",
    "url": "https://codeforces.com/problemset/problem/385/B",
    "history": "The bear has a string s = s1s2. . . s| s| ( record | s| is the string' s length) , consisting of lowercase English letters. The bear wants to count the number of such pairs of indices i, j ( 1 \u2264 i \u2264 j \u2264 | s| ) , that string x( i, j) = sisi + 1. . . sj contains at least one string \" bear\" as a substring. String x( i, j) contains string \" bear\" , if there is such index k ( i \u2264 k \u2264 j - 3) , that sk = b, sk + 1 = e, sk + 2 = a, sk + 3 = r. Help the bear cope with the given problem.",
    "input": "The first line contains a non- empty string s ( 1 \u2264 | s| \u2264 5000) . It is guaranteed that the string only consists of lowercase English letters.",
    "output": "Print a single number \u2014 the answer to the problem.",
    "note": "In the first sample, the following pairs ( i, j) match: ( 1, 4) , ( 1, 5) , ( 1, 6) , ( 1, 7) , ( 1, 8) , ( 1, 9) . In the second sample, the following pairs ( i, j) match: ( 1, 4) , ( 1, 5) , ( 1, 6) , ( 1, 7) , ( 1, 8) , ( 1, 9) , ( 1, 10) , ( 1, 11) , ( 2, 10) , ( 2, 11) , ( 3, 10) , ( 3, 11) , ( 4, 10) , ( 4, 11) , ( 5, 10) , ( 5, 11) , ( 6, 10) , ( 6, 11) , ( 7, 10) , ( 7, 11) .",
    "topics": [
      "brute force",
      "greedy",
      "implementation",
      "math",
      "strings"
    ]
  },
  {
    "title": "Dima and Text Messages",
    "url": "https://codeforces.com/problemset/problem/358/B",
    "history": "Seryozha has a very changeable character. This time he refused to leave the room to Dima and his girlfriend ( her hame is Inna, by the way) . However, the two lovebirds can always find a way to communicate. Today they are writing text messages to each other. Dima and Inna are using a secret code in their text messages. When Dima wants to send Inna some sentence, he writes out all words, inserting a heart before each word and after the last word. A heart is a sequence of two characters: the \" less\" characters ( < ) and the digit three ( 3) . After applying the code, a test message looks like that: < 3word1< 3word2< 3 . . . wordn< 3. Encoding doesn' t end here. Then Dima inserts a random number of small English characters, digits, signs \" more\" and \" less\" into any places of the message. Inna knows Dima perfectly well, so she knows what phrase Dima is going to send her beforehand. Inna has just got a text message. Help her find out if Dima encoded the message correctly. In other words, find out if a text message could have been received by encoding in the manner that is described above.",
    "input": "The first line contains integer n ( 1 \u2264 n \u2264 105) \u2014 the number of words in Dima' s message. Next n lines contain non- empty words, one word per line. The words only consist of small English letters. The total length of all words doesn' t exceed 105. The last line contains non- empty text message that Inna has got. The number of characters in the text message doesn' t exceed 105. A text message can contain only small English letters, digits and signs more and less.",
    "output": "In a single line, print \" yes\" ( without the quotes) , if Dima decoded the text message correctly, and \" no\" ( without the quotes) otherwise.",
    "note": "Please note that Dima got a good old kick in the pants for the second sample from the statement.",
    "topics": [
      "brute force",
      "strings"
    ]
  },
  {
    "title": "Xenia and String Problem",
    "url": "https://codeforces.com/problemset/problem/356/E",
    "history": "Xenia the coder went to The Olympiad of Informatics and got a string problem. Unfortunately, Xenia isn' t fabulous in string algorithms. Help her solve the problem. String s is a sequence of characters s1s2. . . s| s| , where record | s| shows the length of the string. Substring s[ i. . . j] of string s is string sisi + 1. . . sj. String s is a Gray string, if it meets the conditions: the length of string | s| is odd; character occurs exactly once in the string; either | s| = 1, or substrings and are the same and are Gray strings. For example, strings \" abacaba\" , \" xzx\" , \" g\" are Gray strings and strings \" aaa\" , \" xz\" , \" abaxcbc\" are not. The beauty of string p is the sum of the squares of the lengths of all substrings of string p that are Gray strings. In other words, consider all pairs of values i, j ( 1 \u2264 i \u2264 j \u2264 | p| ) . If substring p[ i. . . j] is a Gray string, you should add ( j - i + 1) 2 to the beauty. Xenia has got string t consisting of lowercase English letters. She is allowed to replace at most one letter of the string by any other English letter. The task is to get a string of maximum beauty.",
    "input": "The first line contains a non- empty string t ( 1 \u2264 | t| \u2264 105) . String t only consists of lowercase English letters.",
    "output": "Print the sought maximum beauty value Xenia can get. Please do not use the",
    "note": "In the first test sample the given string can be transformed into string p = \" zbz\" . Such string contains Gray strings as substrings p[ 1. . . 1] , p[ 2. . . 2] , p[ 3. . . 3] \u0438 p[ 1. . . 3] . In total, the beauty of string p gets equal to 12 + 12 + 12 + 32 = 12. You can' t obtain a more beautiful string. In the second test case it is not necessary to perform any operation. The initial string has the maximum possible beauty.",
    "topics": [
      "dp",
      "hashing",
      "implementation",
      "string suffix structures",
      "strings"
    ]
  },
  {
    "title": "Lucky Common Subsequence",
    "url": "https://codeforces.com/problemset/problem/346/B",
    "history": "In mathematics, a subsequence is a sequence that can be derived from another sequence by deleting some elements without changing the order of the remaining elements. For example, the sequence BDF is a subsequence of ABCDEF. A substring of a string is a continuous subsequence of the string. For example, BCD is a substring of ABCDEF. You are given two strings s1, s2 and another string called virus. Your task is to find the longest common subsequence of s1 and s2, such that it doesn' t contain virus as a substring.",
    "input": "The input contains three strings in three separate lines: s1, s2 and virus ( 1 \u2264 | s1| , | s2| , | virus| \u2264 100) . Each string consists only of uppercase English letters.",
    "output": "Output the longest common subsequence of s1 and s2 without virus as a substring. If there are multiple answers, any of them will be accepted. If there is no valid common subsequence, output 0.",
    "note": "",
    "topics": [
      "dp",
      "strings"
    ]
  },
  {
    "title": "Suffix Subgroup",
    "url": "https://codeforces.com/problemset/problem/345/G",
    "history": "You are given a group of n strings: s1, s2, . . . , sn. You should find a subgroup si1, si2, . . . , sik ( 1 \u2264 i1 < i2 < . . . < ik \u2264 n) of the group. The following two conditions must hold: there exists a string t such, that each string from found subgroup is its suffix; the number of strings in the found subgroup is as large as possible. Your task is to print the number of strings in the found subgroup.",
    "input": "The first line contains an integer n ( 1 \u2264 n \u2264 105) \u2014 the number of strings in the group. Each of the next n lines contains a string. The i- th line contains non- empty string si. Each string consists only from lowercase Latin letters. The sum of all strings si doesn' t exceed 105.",
    "output": "Output a single integer \u2014 the number of strings in the found subgroup.",
    "note": "Look at the test sample. The required subgroup is s1, s2, s3.",
    "topics": [
      "*special",
      "strings"
    ]
  },
  {
    "title": "Helpful Maths",
    "url": "https://codeforces.com/problemset/problem/339/A",
    "history": "Xenia the beginner mathematician is a third year student at elementary school. She is now learning the addition operation. The teacher has written down the sum of multiple numbers. Pupils should calculate the sum. To make the calculation easier, the sum only contains numbers 1, 2 and 3. Still, that isn' t enough for Xenia. She is only beginning to count, so she can calculate a sum only if the summands follow in non- decreasing order. For example, she can' t calculate sum 1+ 3+ 2+ 1 but she can calculate sums 1+ 1+ 2 and 3+ 3. You' ve got the sum that was written on the board. Rearrange the summans and print the sum in such a way that Xenia can calculate the sum.",
    "input": "The first line contains a non- empty string s \u2014 the sum Xenia needs to count. String s contains no spaces. It only contains digits and characters \" + \" . Besides, string s is a correct sum of numbers 1, 2 and 3. String s is at most 100 characters long.",
    "output": "Print the new sum that Xenia can count.",
    "note": "",
    "topics": [
      "greedy",
      "implementation",
      "sortings",
      "strings"
    ]
  },
  {
    "title": "Have You Ever Heard About the Word?",
    "url": "https://codeforces.com/problemset/problem/319/D",
    "history": "A substring of a string is a contiguous subsequence of that string. So, string bca is substring of string abcabc, but string cc is not. A repeating block is a string formed by concatenating some string with itself. So, string abcabc is a repeating block, but strings abcabd, ababab are not. You' ve got a sequence of Latin characters ( string) . At each step you find the shortest substring that is a repeating block, if there exists more than one you must choose the leftmost. As the substring is of form XX ( X \u2014 some string) you replace this substring with X, in other words you delete one of the X substrings in the substring. You repeat this process until there remains no repeating block in the string. How would the final string looks like? Look at the sample explanation to understand the statement more precise.",
    "input": "In the first line of input you' re given a string of small Latin characters with length between 1 to 50000, inclusive.",
    "output": "Print the final string after applying changes.",
    "note": "At the first sample the string transforms as follows: abccabc \u2192 abcabc \u2192 abc. At the second sample the string transforms as follows: aaaabaaab \u2192 aaabaaab \u2192 aabaaab \u2192 abaaab \u2192 abaab \u2192 abab \u2192 ab.",
    "topics": [
      "greedy",
      "hashing",
      "string suffix structures",
      "strings"
    ]
  },
  {
    "title": "Strings of Power",
    "url": "https://codeforces.com/problemset/problem/318/B",
    "history": "Volodya likes listening to heavy metal and ( occasionally) reading. No wonder Volodya is especially interested in texts concerning his favourite music style. Volodya calls a string powerful if it starts with \" heavy\" and ends with \" metal\" . Finding all powerful substrings ( by substring Volodya means a subsequence of consecutive characters in a string) in a given text makes our hero especially joyful. Recently he felt an enormous fit of energy while reading a certain text. So Volodya decided to count all powerful substrings in this text and brag about it all day long. Help him in this difficult task. Two substrings are considered different if they appear at the different positions in the text. For simplicity, let us assume that Volodya' s text can be represented as a single string.",
    "input": "Input contains a single non- empty string consisting of the lowercase Latin alphabet letters. Length of this string will not be greater than 106 characters.",
    "output": "Print exactly one number \u2014 the number of powerful substrings of the given string. Please, do not use the",
    "note": "In the first sample the string \" heavymetalisheavymetal\" contains powerful substring \" heavymetal\" twice, also the whole string \" heavymetalisheavymetal\" is certainly powerful. In the second sample the string \" heavymetalismetal\" contains two powerful substrings: \" heavymetal\" and \" heavymetalismetal\" .",
    "topics": [
      "implementation",
      "strings",
      "two pointers"
    ]
  },
  {
    "title": "Good Substrings",
    "url": "https://codeforces.com/problemset/problem/316/G1",
    "history": "Smart Beaver recently got interested in a new word game. The point is as follows: count the number of distinct good substrings of some string s. To determine if a string is good or not the game uses rules. Overall there are n rules. Each rule is described by a group of three ( p, l, r) , where p is a string and l and r ( l \u2264 r) are integers. We\u2019ll say that string t complies with rule ( p, l, r) , if the number of occurrences of string t in string p lies between l and r, inclusive. For example, string \" ab\" , complies with rules ( \" ab\" , 1, 2) and ( \" aab\" , 0, 1) , but does not comply with rules ( \" cd\" , 1, 2) and ( \" abab\" , 0, 1) . A substring s[ l. . . r] ( 1 \u2264 l \u2264 r \u2264 | s| ) of string s = s1s2. . . s| s| ( | s| is a length of s) is string slsl + 1. . . sr. Consider a number of occurrences of string t in string p as a number of pairs of integers l, r ( 1 \u2264 l \u2264 r \u2264 | p| ) such that p[ l. . . r] = t. We\u2019ll say that string t is good if it complies with all n rules. Smart Beaver asks you to help him to write a program that can calculate the number of distinct good substrings of string s. Two substrings s[ x. . . y] and s[ z. . . w] are cosidered to be distinct iff s[ x. . . y] = \u0338 s[ z. . . w] .",
    "input": "The first line contains string s. The second line contains integer n. Next n lines contain the rules, one per line. Each of these lines contains a string and two integers pi, li, ri, separated by single spaces ( 0 \u2264 li \u2264 ri \u2264 | pi| ) . It is guaranteed that all the given strings are non- empty and only contain lowercase English letters. The input limits for scoring 30 points are ( subproblem G1) : 0 \u2264 n \u2264 10. The length of string s and the maximum length of string p is \u2264 200. The input limits for scoring 70 points are ( subproblems G1+ G2) : 0 \u2264 n \u2264 10. The length of string s and the maximum length of string p is \u2264 2000. The input limits for scoring 100 points are ( subproblems G1+ G2+ G3) : 0 \u2264 n \u2264 10. The length of string s and the maximum length of string p is \u2264 50000.",
    "output": "Print a single integer \u2014 the number of good substrings of string s.",
    "note": "There are three good substrings in the first sample test: \u00abaab\u00bb, \u00abab\u00bb and \u00abb\u00bb. In the second test only substrings \u00abe\u00bb and \u00abt\u00bb are good.",
    "topics": [
      "hashing",
      "strings"
    ]
  },
  {
    "title": "Sereja and Periods",
    "url": "https://codeforces.com/problemset/problem/314/B",
    "history": "Let' s introduce the designation , where x is a string, n is a positive integer and operation \" + \" is the string concatenation operation. For example, [ abc, 2] = abcabc. We' ll say that string s can be obtained from string t, if we can remove some characters from string t and obtain string s. For example, strings ab and a\u0441ba can be obtained from string xacbac, and strings bx and aaa cannot be obtained from it. Sereja has two strings, w = [ a, b] and q = [ c, d] . He wants to find such maximum integer p ( p > 0) , that [ q, p] can be obtained from string w.",
    "input": "The first line contains two integers b, d ( 1 \u2264 b, d \u2264 107) . The second line contains string a. The third line contains string c. The given strings are not empty and consist of lowercase English letters. Their lengths do not exceed 100.",
    "output": "In a single line print an integer \u2014 the largest number p. If the required value of p doesn' t exist, print 0.",
    "note": "",
    "topics": [
      "binary search",
      "dfs and similar",
      "strings"
    ]
  },
  {
    "title": "Whose sentence is it?",
    "url": "https://codeforces.com/problemset/problem/312/A",
    "history": "One day, liouzhou_ 101 got a chat record of Freda and Rainbow. Out of curiosity, he wanted to know which sentences were said by Freda, and which were said by Rainbow. According to his experience, he thought that Freda always said \" lala. \" at the end of her sentences, while Rainbow always said \" miao. \" at the beginning of his sentences. For each sentence in the chat record, help liouzhou_ 101 find whose sentence it is.",
    "input": "The first line of the input contains an integer n ( 1 \u2264 n \u2264 10) , number of sentences in the chat record. Each of the next n lines contains a sentence. A sentence is a string that contains only Latin letters ( A- Z, a- z) , underline ( _ ) , comma ( , ) , point ( . ) and space ( ) . Its length doesn\u2019t exceed 100.",
    "output": "For each sentence, output \" Freda' s\" if the sentence was said by Freda, \" Rainbow' s\" if the sentence was said by Rainbow, or \" OMG> . < I don' t know! \" if liouzhou_ 101 can\u2019t recognize whose sentence it is. He can\u2019t recognize a sentence if it begins with \" miao. \" and ends with \" lala. \" , or satisfies neither of the conditions.",
    "note": "",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Tree-String Problem",
    "url": "https://codeforces.com/problemset/problem/291/E",
    "history": "A rooted tree is a non- directed connected graph without any cycles with a distinguished vertex, which is called the tree root. Consider the vertices of a rooted tree, that consists of n vertices, numbered from 1 to n. In this problem the tree root is the vertex number 1. Let' s represent the length of the shortest by the number of edges path in the tree between vertices v and u as d( v, u) . A parent of vertex v in the rooted tree with the root in vertex r ( v = \u0338 r) is vertex pv, such that d( r, pv) + 1 = d( r, v) and d( pv, v) = 1. For example, on the picture the parent of vertex v = 5 is vertex p5 = 2. One day Polycarpus came across a rooted tree, consisting of n vertices. The tree wasn' t exactly ordinary: it had strings written on its edges. Polycarpus positioned the tree on the plane so as to make all edges lead from top to bottom if you go from the vertex parent to the vertex ( see the picture) . For any edge that lead from vertex pv to vertex v ( 1 < v \u2264 n) , he knows string sv that is written on it. All strings are written on the edges from top to bottom. For example, on the picture s7= \" ba\" . The characters in the strings are numbered starting from 0. An example of Polycarpus' s tree ( corresponds to the example from the statement) Polycarpus defines the position in this tree as a specific letter on a specific string. The position is written as a pair of integers ( v, x) that means that the position is the x- th letter of the string sv ( 1 < v \u2264 n, 0 \u2264 x < | sv| ) , where | sv| is the length of string sv. For example, the highlighted letters are positions ( 2, 1) and ( 3, 1) . Let' s consider the pair of positions ( v, x) and ( u, y) in Polycarpus' tree, such that the way from the first position to the second goes down on each step. We will consider that the pair of such positions defines string z. String z consists of all letters on the way from ( v, x) to ( u, y) , written in the order of this path. For example, in the picture the highlighted positions define string \" bacaba\" . Polycarpus has a string t, he wants to know the number of pairs of positions that define string t. Note that the way from the first position to the second in the pair must go down everywhere. Help him with this challenging tree- string problem!",
    "input": "The first line contains integer n ( 2 \u2264 n \u2264 105) \u2014 the number of vertices of Polycarpus' s tree. Next n - 1 lines contain the tree edges. The i- th of them contains number pi + 1 and string si + 1 ( 1 \u2264 pi + 1 \u2264 n; pi + 1 = \u0338 ( i + 1) ) . String si + 1 is non- empty and consists of lowercase English letters. The last line contains string t. String t consists of lowercase English letters, its length is at least 2. It is guaranteed that the input contains at most 3\u00b7105 English letters.",
    "output": "Print a single integer \u2014 the required number. Please, do not use the",
    "note": "In the first test case string \" aba\" is determined by the pairs of positions: ( 2, 0) and ( 5, 0) ; ( 5, 2) and ( 6, 1) ; ( 5, 2) and ( 3, 1) ; ( 4, 0) and ( 4, 2) ; ( 4, 4) and ( 4, 6) ; ( 3, 3) and ( 3, 5) . Note that the string is not defined by the pair of positions ( 7, 1) and ( 5, 0) , as the way between them doesn' t always go down.",
    "topics": [
      "*special",
      "dfs and similar",
      "hashing",
      "strings"
    ]
  },
  {
    "title": "Command Line Arguments",
    "url": "https://codeforces.com/problemset/problem/291/B",
    "history": "The problem describes the properties of a command line. The description somehow resembles the one you usually see in real operating systems. However, there are differences in the behavior. Please make sure you' ve read the statement attentively and use it as a formal document. In the Pindows operating system a strings are the lexemes of the command line \u2014 the first of them is understood as the name of the program to run and the following lexemes are its arguments. For example, as we execute the command \" run. exe one, two . \" , we give four lexemes to the Pindows command line: \" run. exe\" , \" one, \" , \" two\" , \" . \" . More formally, if we run a command that can be represented as string s ( that has no quotes) , then the command line lexemes are maximal by inclusion substrings of string s that contain no spaces. To send a string with spaces or an empty string as a command line lexeme, we can use double quotes. The block of characters that should be considered as one lexeme goes inside the quotes. Embedded quotes are prohibited \u2014 that is, for each occurrence of character \" \" \" we should be able to say clearly that the quotes are opening or closing. For example, as we run the command \" \" run. exe o\" \" \" \" ne, \" two . \" \" \" , we give six lexemes to the Pindows command line: \" run. exe o\" , \" \" ( an empty string) , \" ne, \" , \" two\" , \" . \" , \" \" ( a single space) . It is guaranteed that each lexeme of the command line is either surrounded by spaces on both sides or touches the corresponding command border. One of its consequences is: the opening brackets are either the first character of the string or there is a space to the left of them. You have a string that consists of uppercase and lowercase English letters, digits, characters \" . , ? ! \" \" and spaces. It is guaranteed that this string is a correct OS Pindows command line string. Print all lexemes of this command line string. Consider the character \" \" \" to be used only in order to denote a single block of characters into one command line lexeme. In particular, the consequence is that the given string has got an even number of such characters.",
    "input": "The single line contains a non- empty string s. String s consists of at most 105 characters. Each character is either an uppercase or a lowercase English letter, or a digit, or one of the \" . , ? ! \" \" signs, or a space. It is guaranteed that the given string is some correct command line string of the OS Pindows. It is guaranteed that the given command line string contains at least one lexeme.",
    "output": "In the first line print the first lexeme, in the second line print the second one and so on. To make the output clearer, print the \" < \" ( less) character to the left of your lexemes and the \" > \" ( more) character to the right. Print the lexemes in the order in which they occur in the command. Please, follow the given output format strictly. For more clarifications on the output format see the test samples.",
    "note": "",
    "topics": [
      "*special",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Word Capitalization",
    "url": "https://codeforces.com/problemset/problem/281/A",
    "history": "Capitalization is writing a word with its first letter as a capital letter. Your task is to capitalize the given word. Note, that during capitalization all the letters except the first one remains unchanged.",
    "input": "A single line contains a non- empty word. This word consists of lowercase and uppercase English letters. The length of the word will not exceed 103.",
    "output": "Output the given word after capitalization.",
    "note": "",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "New Problem",
    "url": "https://codeforces.com/problemset/problem/278/B",
    "history": "Coming up with a new problem isn' t as easy as many people think. Sometimes it is hard enough to name it. We' ll consider a title original if it doesn' t occur as a substring in any titles of recent Codeforces problems. You' ve got the titles of n last problems \u2014 the strings, consisting of lowercase English letters. Your task is to find the shortest original title for the new problem. If there are multiple such titles, choose the lexicographically minimum one. Note, that title of the problem can' t be an empty string. A substring s[ l. . . r] ( 1 \u2264 l \u2264 r \u2264 | s| ) of string s = s1s2. . . s| s| ( where | s| is the length of string s) is string slsl + 1. . . sr. String x = x1x2. . . xp is lexicographically smaller than string y = y1y2. . . yq, if either p < q and x1 = y1, x2 = y2, . . . , xp = yp, or there exists such number r ( r < p, r < q) , that x1 = y1, x2 = y2, . . . , xr = yr and xr + 1 < yr + 1. The string characters are compared by their ASCII codes.",
    "input": "The first line contains integer n ( 1 \u2264 n \u2264 30) \u2014 the number of titles you' ve got to consider. Then follow n problem titles, one per line. Each title only consists of lowercase English letters ( specifically, it doesn' t contain any spaces) and has the length from 1 to 20, inclusive.",
    "output": "Print a string, consisting of lowercase English letters \u2014 the lexicographically minimum shortest original title.",
    "note": "In the first sample the first 9 letters of the English alphabet ( a, b, c, d, e, f, g, h, i) occur in the problem titles, so the answer is letter j. In the second sample the titles contain 26 English letters, so the shortest original title cannot have length 1. Title aa occurs as a substring in the first title.",
    "topics": [
      "brute force",
      "strings"
    ]
  },
  {
    "title": "Good Substrings",
    "url": "https://codeforces.com/problemset/problem/271/D",
    "history": "You' ve got string s, consisting of small English letters. Some of the English letters are good, the rest are bad. A substring s[ l. . . r] ( 1 \u2264 l \u2264 r \u2264 | s| ) of string s = s1s2. . . s| s| ( where | s| is the length of string s) is string slsl + 1. . . sr. The substring s[ l. . . r] is good, if among the letters sl, sl + 1, . . . , sr there are at most k bad ones ( look at the sample' s explanation to understand it more clear) . Your task is to find the number of distinct good substrings of the given string s. Two substrings s[ x. . . y] and s[ p. . . q] are considered distinct if their content is different, i. e. s[ x. . . y] = \u0338 s[ p. . . q] .",
    "input": "The first line of the input is the non- empty string s, consisting of small English letters, the string' s length is at most 1500 characters. The second line of the input is the string of characters \" 0\" and \" 1\" , the length is exactly 26 characters. If the i- th character of this string equals \" 1\" , then the i- th English letter is good, otherwise it' s bad. That is, the first character of this string corresponds to letter \" a\" , the second one corresponds to letter \" b\" and so on. The third line of the input consists a single integer k ( 0 \u2264 k \u2264 | s| ) \u2014 the maximum acceptable number of bad characters in a good substring.",
    "output": "Print a single integer \u2014 the number of distinct good substrings of string s.",
    "note": "In the first example there are following good substrings: \" a\" , \" ab\" , \" b\" , \" ba\" , \" bab\" . In the second example there are following good substrings: \" a\" , \" aa\" , \" ac\" , \" b\" , \" ba\" , \" c\" , \" ca\" , \" cb\" .",
    "topics": [
      "data structures",
      "strings"
    ]
  },
  {
    "title": "String Theory",
    "url": "https://codeforces.com/problemset/problem/269/E",
    "history": "Emuskald is an innovative musician and always tries to push the boundaries of music production. Now he has come up with an idea for a revolutionary musical instrument \u2014 a rectangular harp. A rectangular harp is a rectangle n \u00d7 m consisting of n rows and m columns. The rows are numbered 1 to n from top to bottom. Similarly the columns are numbered 1 to m from left to right. String pins are spaced evenly across every side, one per unit. Thus there are n pins on the left and right sides of the harp and m pins on its top and bottom. The harp has exactly n + m different strings, each string connecting two different pins, each on a different side of the harp. Emuskald has ordered his apprentice to construct the first ever rectangular harp. However, he didn' t mention that no two strings can cross, otherwise it would be impossible to play the harp. Two strings cross if the segments connecting their pins intersect. To fix the harp, Emuskald can perform operations of two types: pick two different columns and swap their pins on each side of the harp, not changing the pins that connect each string; pick two different rows and swap their pins on each side of the harp, not changing the pins that connect each string; In the following example, he can fix the harp by swapping two columns: Help Emuskald complete his creation and find the permutations how the rows and columns of the harp need to be rearranged, or tell that it is impossible to do so. He can detach and reattach each string to its pins, so the physical layout of the strings doesn' t matter.",
    "input": "The first line of input contains two space- separated integers numbers n and m ( 1 \u2264 n, m \u2264 105) , the height and width of the harp in units. Each of the following n + m lines contains 4 space- separated tokens, describing a single string: two symbols ai, bi and two integer numbers pi, qi. The pair ai, pi describes the first pin, and the pair bi, qi describes the second pin of the string; A pair s, x describes the position of a single pin in a following way: s is equal to one of the symbols \" L\" , \" T\" , \" R\" or \" B\" ( without quotes) , which means that the pin is positioned on the left, top, right or bottom side of the harp accordingly; x is equal to the number of the row, if the pin is on the left or right border of the harp, and to the number of the column, if the pin is on the top or bottom border of the harp. It is guaranteed that no two different strings are connected to the same pin.",
    "output": "If it is possible to rearrange the rows and columns to fix the harp, on the first line output n space- separated integers \u2014 the old numbers of rows now placed from top to bottom in the fixed harp. On the second line, output m space- separated integers \u2014 the old numbers of columns now placed from left to right in the fixed harp. If it is impossible to rearrange the rows and columns to fix the harp, output \" No solution\" ( without quotes) .",
    "note": "",
    "topics": [
      "geometry",
      "math",
      "strings"
    ]
  },
  {
    "title": "Ancient Prophesy",
    "url": "https://codeforces.com/problemset/problem/260/B",
    "history": "A recently found Ancient Prophesy is believed to contain the exact Apocalypse date. The prophesy is a string that only consists of digits and characters \" - \" . We' ll say that some date is mentioned in the Prophesy if there is a substring in the Prophesy that is the date' s record in the format \" dd- mm- yyyy\" . We' ll say that the number of the date' s occurrences is the number of such substrings in the Prophesy. For example, the Prophesy \" 0012- 10- 2012- 10- 2012\" mentions date 12- 10- 2012 twice ( first time as \" 0012- 10- 2012- 10- 2012\" , second time as \" 0012- 10- 2012- 10- 2012\" ) . The date of the Apocalypse is such correct date that the number of times it is mentioned in the Prophesy is strictly larger than that of any other correct date. A date is correct if the year lies in the range from 2013 to 2015, the month is from 1 to 12, and the number of the day is strictly more than a zero and doesn' t exceed the number of days in the current month. Note that a date is written in the format \" dd- mm- yyyy\" , that means that leading zeroes may be added to the numbers of the months or days if needed. In other words, date \" 1- 1- 2013\" isn' t recorded in the format \" dd- mm- yyyy\" , and date \" 01- 01- 2013\" is recorded in it. Notice, that any year between 2013 and 2015 is not a leap year.",
    "input": "The first line contains the Prophesy: a non- empty string that only consists of digits and characters \" - \" . The length of the Prophesy doesn' t exceed 105 characters.",
    "output": "In a single line print the date of the Apocalypse. It is guaranteed that such date exists and is unique.",
    "note": "",
    "topics": [
      "brute force",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Little Elephant and Chess",
    "url": "https://codeforces.com/problemset/problem/259/A",
    "history": "The Little Elephant loves chess very much. One day the Little Elephant and his friend decided to play chess. They' ve got the chess pieces but the board is a problem. They' ve got an 8 \u00d7 8 checkered board, each square is painted either black or white. The Little Elephant and his friend know that a proper chessboard doesn' t have any side- adjacent cells with the same color and the upper left cell is white. To play chess, they want to make the board they have a proper chessboard. For that the friends can choose any row of the board and cyclically shift the cells of the chosen row, that is, put the last ( rightmost) square on the first place in the row and shift the others one position to the right. You can run the described operation multiple times ( or not run it at all) . For example, if the first line of the board looks like that \" BBBBBBWW\" ( the white cells of the line are marked with character \" W\" , the black cells are marked with character \" B\" ) , then after one cyclic shift it will look like that \" WBBBBBBW\" . Help the Little Elephant and his friend to find out whether they can use any number of the described operations to turn the board they have into a proper chessboard.",
    "input": "The input consists of exactly eight lines. Each line contains exactly eight characters \" W\" or \" B\" without any spaces: the j- th character in the i- th line stands for the color of the j- th cell of the i- th row of the elephants' board. Character \" W\" stands for the white color, character \" B\" stands for the black color. Consider the rows of the board numbered from 1 to 8 from top to bottom, and the columns \u2014 from 1 to 8 from left to right. The given board can initially be a proper chessboard.",
    "output": "In a single line print \" YES\" ( without the quotes) , if we can make the board a proper chessboard and \" NO\" ( without the quotes) otherwise.",
    "note": "In the first sample you should shift the following lines one position to the right: the 3- rd, the 6- th, the 7- th and the 8- th. In the second sample there is no way you can achieve the goal.",
    "topics": [
      "brute force",
      "strings"
    ]
  },
  {
    "title": "Anagram",
    "url": "https://codeforces.com/problemset/problem/254/C",
    "history": "String x is an anagram of string y, if we can rearrange the letters in string x and get exact string y. For example, strings \" DOG\" and \" GOD\" are anagrams, so are strings \" BABA\" and \" AABB\" , but strings \" ABBAC\" and \" CAABA\" are not. You are given two strings s and t of the same length, consisting of uppercase English letters. You need to get the anagram of string t from string s. You are permitted to perform the replacing operation: every operation is replacing some character from the string s by any other character. Get the anagram of string t in the least number of replacing operations. If you can get multiple anagrams of string t in the least number of operations, get the lexicographically minimal one. The lexicographic order of strings is the familiar to us \" dictionary\" order. Formally, the string p of length n is lexicographically smaller than string q of the same length, if p1 = q1, p2 = q2, . . . , pk - 1 = qk - 1, pk < qk for some k ( 1 \u2264 k \u2264 n) . Here characters in the strings are numbered from 1. The characters of the strings are compared in the alphabetic order.",
    "input": "The input consists of two lines. The first line contains string s, the second line contains string t. The strings have the same length ( from 1 to 105 characters) and consist of uppercase English letters.",
    "output": "In the first line print z \u2014 the minimum number of replacement operations, needed to get an anagram of string t from string s. In the second line print the lexicographically minimum anagram that could be obtained in z operations.",
    "note": "The second sample has eight anagrams of string t, that can be obtained from string s by replacing exactly two letters: \" ADBADC\" , \" ADDABC\" , \" CDAABD\" , \" CDBAAD\" , \" CDBADA\" , \" CDDABA\" , \" DDAABC\" , \" DDBAAC\" . These anagrams are listed in the lexicographical order. The lexicographically minimum anagram is \" ADBADC\" .",
    "topics": [
      "greedy",
      "strings"
    ]
  },
  {
    "title": "Restoring IPv6",
    "url": "https://codeforces.com/problemset/problem/250/B",
    "history": "An IPv6- address is a 128- bit number. For convenience, this number is recorded in blocks of 16 bits in hexadecimal record, the blocks are separated by colons \u2014 8 blocks in total, each block has four hexadecimal digits. Here is an example of the correct record of a IPv6 address: \" 0124: 5678: 90ab: cdef: 0124: 5678: 90ab: cdef\" . We' ll call such format of recording an IPv6- address full. Besides the full record of an IPv6 address there is a short record format. The record of an IPv6 address can be shortened by removing one or more leading zeroes at the beginning of each block. However, each block should contain at least one digit in the short format. For example, the leading zeroes can be removed like that: \" a56f: 00d3: 0000: 0124: 0001: f19a: 1000: 0000\" \u2192 \" a56f: d3: 0: 0124: 01: f19a: 1000: 00\" . There are more ways to shorten zeroes in this IPv6 address. Some IPv6 addresses contain long sequences of zeroes. Continuous sequences of 16- bit zero blocks can be shortened to \" : : \" . A sequence can consist of one or several consecutive blocks, with all 16 bits equal to 0. You can see examples of zero block shortenings below: \" a56f: 00d3: 0000: 0124: 0001: 0000: 0000: 0000\" \u2192 \" a56f: 00d3: 0000: 0124: 0001: : \" ; \" a56f: 0000: 0000: 0124: 0001: 0000: 1234: 0ff0\" \u2192 \" a56f: : 0124: 0001: 0000: 1234: 0ff0\" ; \" a56f: 0000: 0000: 0000: 0001: 0000: 1234: 0ff0\" \u2192 \" a56f: 0000: : 0000: 0001: 0000: 1234: 0ff0\" ; \" a56f: 00d3: 0000: 0124: 0001: 0000: 0000: 0000\" \u2192 \" a56f: 00d3: 0000: 0124: 0001: : 0000\" ; \" 0000: 0000: 0000: 0000: 0000: 0000: 0000: 0000\" \u2192 \" : : \" . It is not allowed to shorten zero blocks in the address more than once. This means that the short record can' t contain the sequence of characters \" : : \" more than once. Otherwise, it will sometimes be impossible to determine the number of zero blocks, each represented by a double colon. The format of the record of the IPv6 address after removing the leading zeroes and shortening the zero blocks is called short. You' ve got several short records of IPv6 addresses. Restore their full record.",
    "input": "The first line contains a single integer n \u2014 the number of records to restore ( 1 \u2264 n \u2264 100) . Each of the following n lines contains a string \u2014 the short IPv6 addresses. Each string only consists of string characters \" 0123456789abcdef: \" . It is guaranteed that each short address is obtained by the way that is described in the statement from some full IPv6 address.",
    "output": "For each short IPv6 address from the input print its full record on a separate line. Print the full records for the short IPv6 addresses in the order, in which the short records follow in the input.",
    "note": "",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Queries for Number of Palindromes",
    "url": "https://codeforces.com/problemset/problem/245/H",
    "history": "You' ve got a string s = s1s2. . . s| s| of length | s| , consisting of lowercase English letters. There also are q queries, each query is described by two integers li, ri ( 1 \u2264 li \u2264 ri \u2264 | s| ) . The answer to the query is the number of substrings of string s[ li. . . ri] , which are palindromes. String s[ l. . . r] = slsl + 1. . . sr ( 1 \u2264 l \u2264 r \u2264 | s| ) is a substring of string s = s1s2. . . s| s| . String t is called a palindrome, if it reads the same from left to right and from right to left. Formally, if t = t1t2. . . t| t| = t| t| t| t| - 1. . . t1.",
    "input": "The first line contains string s ( 1 \u2264 | s| \u2264 5000) . The second line contains a single integer q ( 1 \u2264 q \u2264 106) \u2014 the number of queries. Next q lines contain the queries. The i- th of these lines contains two space- separated integers li, ri ( 1 \u2264 li \u2264 ri \u2264 | s| ) \u2014 the description of the i- th query. It is guaranteed that the given string consists only of lowercase English letters.",
    "output": "Print q integers \u2014 the answers to the queries. Print the answers in the order, in which the queries are given in the input. Separate the printed numbers by whitespaces.",
    "note": "Consider the fourth query in the first test case. String s[ 4. . . 6] = \u00ababa\u00bb. Its palindrome substrings are: \u00aba\u00bb, \u00abb\u00bb, \u00aba\u00bb, \u00ababa\u00bb.",
    "topics": [
      "dp",
      "hashing",
      "strings"
    ]
  },
  {
    "title": "Log Stream Analysis",
    "url": "https://codeforces.com/problemset/problem/245/F",
    "history": "You' ve got a list of program warning logs. Each record of a log stream is a string in this format: \" 2012- MM- DD HH: MM: SS: MESSAGE\" ( without the quotes) . String \" MESSAGE\" consists of spaces, uppercase and lowercase English letters and characters \" ! \" , \" . \" , \" , \" , \" ? \" . String \" 2012- MM- DD\" determines a correct date in the year of 2012. String \" HH: MM: SS\" determines a correct time in the 24 hour format. The described record of a log stream means that at a certain time the record has got some program warning ( string \" MESSAGE\" contains the warning' s description) . Your task is to print the first moment of time, when the number of warnings for the last n seconds was not less than m.",
    "input": "The first line of the input contains two space- separated integers n and m ( 1 \u2264 n, m \u2264 10000) . The second and the remaining lines of the input represent the log stream. The second line of the input contains the first record of the log stream, the third line contains the second record and so on. Each record of the log stream has the above described format. All records are given in the chronological order, that is, the warning records are given in the order, in which the warnings appeared in the program. It is guaranteed that the log has at least one record. It is guaranteed that the total length of all lines of the log stream doesn' t exceed 5\u00b7106 ( in particular, this means that the length of some line does not exceed 5\u00b7106 characters) . It is guaranteed that all given dates and times are correct, and the string ' MESSAGE\" in all records is non- empty.",
    "output": "If there is no sought moment of time, print - 1. Otherwise print a string in the format \" 2012- MM- DD HH: MM: SS\" ( without the quotes) \u2014 the first moment of time when the number of warnings for the last n seconds got no less than m.",
    "note": "",
    "topics": [
      "binary search",
      "brute force",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Internet Address",
    "url": "https://codeforces.com/problemset/problem/245/B",
    "history": "Vasya is an active Internet user. One day he came across an Internet resource he liked, so he wrote its address in the notebook. We know that the address of the written resource has format: < protocol> : / / < domain> . ru[ / < context> ] where: < protocol> can equal either \" http\" ( without the quotes) or \" ftp\" ( without the quotes) , < domain> is a non- empty string, consisting of lowercase English letters, the / < context> part may not be present. If it is present, then < context> is a non- empty string, consisting of lowercase English letters. If string < context> isn' t present in the address, then the additional character \" / \" isn' t written. Thus, the address has either two characters \" / \" ( the ones that go before the domain) , or three ( an extra one in front of the context) . When the boy came home, he found out that the address he wrote in his notebook had no punctuation marks. Vasya must have been in a lot of hurry and didn' t write characters \" : \" , \" / \" , \" . \" . Help Vasya to restore the possible address of the recorded Internet resource.",
    "input": "The first line contains a non- empty string that Vasya wrote out in his notebook. This line consists of lowercase English letters only. It is guaranteed that the given string contains at most 50 letters. It is guaranteed that the given string can be obtained from some correct Internet resource address, described above.",
    "output": "Print a single line \u2014 the address of the Internet resource that Vasya liked. If there are several addresses that meet the problem limitations, you are allowed to print any of them.",
    "note": "In the second sample there are two more possible answers: \" ftp: / / httpruru. ru\" and \" ftp: / / httpru. ru/ ru\" .",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Boy or Girl",
    "url": "https://codeforces.com/problemset/problem/236/A",
    "history": "Those days, many boys use beautiful girls' photos as avatars in forums. So it is pretty hard to tell the gender of a user at the first glance. Last year, our hero went to a forum and had a nice chat with a beauty ( he thought so) . After that they talked very often and eventually they became a couple in the network. But yesterday, he came to see \" her\" in the real world and found out \" she\" is actually a very strong man! Our hero is very sad and he is too tired to love again now. So he came up with a way to recognize users' genders by their user names. This is his method: if the number of distinct characters in one' s user name is odd, then he is a male, otherwise she is a female. You are given the string that denotes the user name, please help our hero to determine the gender of this user by his method.",
    "input": "The first line contains a non- empty string, that contains only lowercase English letters \u2014 the user name. This string contains at most 100 letters.",
    "output": "If it is a female by our hero' s method, print \" CHAT WITH HER! \" ( without the quotes) , otherwise, print \" IGNORE HIM! \" ( without the quotes) .",
    "note": "For the first example. There are 6 distinct characters in \" wjmzbmr\" . These characters are: \" w\" , \" j\" , \" m\" , \" z\" , \" b\" , \" r\" . So wjmzbmr is a female and you should print \" CHAT WITH HER! \" .",
    "topics": [
      "brute force",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Cyclical Quest",
    "url": "https://codeforces.com/problemset/problem/235/C",
    "history": "Some days ago, WJMZBMR learned how to answer the query \" how many times does a string x occur in a string s\" quickly by preprocessing the string s. But now he wants to make it harder. So he wants to ask \" how many consecutive substrings of s are cyclical isomorphic to a given string x\" . You are given string s and n strings xi, for each string xi find, how many consecutive substrings of s are cyclical isomorphic to xi. Two strings are called cyclical isomorphic if one can rotate one string to get the other one. ' Rotate' here means ' to take some consecutive chars ( maybe none) from the beginning of a string and put them back at the end of the string in the same order' . For example, string \" abcde\" can be rotated to string \" deabc\" . We can take characters \" abc\" from the beginning and put them at the end of \" de\" .",
    "input": "The first line contains a non- empty string s. The length of string s is not greater than 106 characters. The second line contains an integer n ( 1 \u2264 n \u2264 105) \u2014 the number of queries. Then n lines follow: the i- th line contains the string xi \u2014 the string for the i- th query. The total length of xi is less than or equal to 106 characters. In this problem, strings only consist of lowercase English letters.",
    "output": "For each query xi print a single integer that shows how many consecutive substrings of s are cyclical isomorphic to xi. Print the answers to the queries in the order they are given in the input.",
    "note": "",
    "topics": [
      "data structures",
      "string suffix structures",
      "strings"
    ]
  },
  {
    "title": "Two Strings",
    "url": "https://codeforces.com/problemset/problem/223/B",
    "history": "A subsequence of length | x| of string s = s1s2. . . s| s| ( where | s| is the length of string s) is a string x = sk1sk2. . . sk| x| ( 1 \u2264 k1 < k2 < . . . < k| x| \u2264 | s| ) . You' ve got two strings \u2014 s and t. Let' s consider all subsequences of string s, coinciding with string t. Is it true that each character of string s occurs in at least one of these subsequences? In other words, is it true that for all i ( 1 \u2264 i \u2264 | s| ) , there is such subsequence x = sk1sk2. . . sk| x| of string s, that x = t and for some j ( 1 \u2264 j \u2264 | x| ) kj = i.",
    "input": "The first line contains string s, the second line contains string t. Each line consists only of lowercase English letters. The given strings are non- empty, the length of each string does not exceed 2\u00b7105.",
    "output": "Print \" Yes\" ( without the quotes) , if each character of the string s occurs in at least one of the described subsequences, or \" No\" ( without the quotes) otherwise.",
    "note": "In the first sample string t can occur in the string s as a subsequence in three ways: abab, abab and abab. In these occurrences each character of string s occurs at least once. In the second sample the 4- th character of the string s doesn' t occur in any occurrence of string t. In the third sample there is no occurrence of string t in string s.",
    "topics": [
      "data structures",
      "dp",
      "strings"
    ]
  },
  {
    "title": "k-String",
    "url": "https://codeforces.com/problemset/problem/219/A",
    "history": "A string is called a k- string if it can be represented as k concatenated copies of some string. For example, the string \" aabaabaabaab\" is at the same time a 1- string, a 2- string and a 4- string, but it is not a 3- string, a 5- string, or a 6- string and so on. Obviously any string is a 1- string. You are given a string s, consisting of lowercase English letters and a positive integer k. Your task is to reorder the letters in the string s in such a way that the resulting string is a k- string.",
    "input": "The first input line contains integer k ( 1 \u2264 k \u2264 1000) . The second line contains s, all characters in s are lowercase English letters. The string length s satisfies the inequality 1 \u2264 | s| \u2264 1000, where | s| is the length of string s.",
    "output": "Rearrange the letters in string s in such a way that the result is a k- string. Print the result on a single output line. If there are multiple solutions, print any of them. If the solution doesn' t exist, print \" - 1\" ( without quotes) .",
    "note": "",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Two Permutations",
    "url": "https://codeforces.com/problemset/problem/213/E",
    "history": "Rubik is very keen on number permutations. A permutation a with length n is a sequence, consisting of n different numbers from 1 to n. Element number i ( 1 \u2264 i \u2264 n) of this permutation will be denoted as ai. Furik decided to make a present to Rubik and came up with a new problem on permutations. Furik tells Rubik two number permutations: permutation a with length n and permutation b with length m. Rubik must give an answer to the problem: how many distinct integers d exist, such that sequence c ( c1 = a1 + d, c2 = a2 + d, . . . , cn = an + d) of length n is a subsequence of b. Sequence a is a subsequence of sequence b, if there are such indices i1, i2, . . . , in ( 1 \u2264 i1 < i2 < . . . < in \u2264 m) , that a1 = bi1, a2 = bi2, . . . , an = bin, where n is the length of sequence a, and m is the length of sequence b. You are given permutations a and b, help Rubik solve the given problem.",
    "input": "The first line contains two integers n and m ( 1 \u2264 n \u2264 m \u2264 200000) \u2014 the sizes of the given permutations. The second line contains n distinct integers \u2014 permutation a, the third line contains m distinct integers \u2014 permutation b. Numbers on the lines are separated by spaces.",
    "output": "On a single line print the answer to the problem.",
    "note": "",
    "topics": [
      "data structures",
      "hashing",
      "strings"
    ]
  },
  {
    "title": "Dubstep",
    "url": "https://codeforces.com/problemset/problem/208/A",
    "history": "Vasya works as a DJ in the best Berland nightclub, and he often uses dubstep music in his performance. Recently, he has decided to take a couple of old songs and make dubstep remixes from them. Let' s assume that a song consists of some number of words. To make the dubstep remix of this song, Vasya inserts a certain number of words \" WUB\" before the first word of the song ( the number may be zero) , after the last word ( the number may be zero) , and between words ( at least one between any pair of neighbouring words) , and then the boy glues together all the words, including \" WUB\" , in one string and plays the song at the club. For example, a song with words \" I AM X\" can transform into a dubstep remix as \" WUBWUBIWUBAMWUBWUBX\" and cannot transform into \" WUBWUBIAMWUBX\" . Recently, Petya has heard Vasya' s new dubstep track, but since he isn' t into modern music, he decided to find out what was the initial song that Vasya remixed. Help Petya restore the original song.",
    "input": "The input consists of a single non- empty string, consisting only of uppercase English letters, the string' s length doesn' t exceed 200 characters. It is guaranteed that before Vasya remixed the song, no word contained substring \" WUB\" in it; Vasya didn' t change the word order. It is also guaranteed that initially the song had at least one word.",
    "output": "Print the words of the initial song that Vasya used to make a dubsteb remix. Separate the words with a space.",
    "note": "In the first sample: \" WUBWUBABCWUB\" = \" WUB\" + \" WUB\" + \" ABC\" + \" WUB\" . That means that the song originally consisted of a single word \" ABC\" , and all words \" WUB\" were added by Vasya. In the second sample Vasya added a single word \" WUB\" between all neighbouring words, in the beginning and in the end, except for words \" ARE\" and \" THE\" \u2014 between them Vasya added two \" WUB\" .",
    "topics": [
      "strings"
    ]
  },
  {
    "title": "LLPS",
    "url": "https://codeforces.com/problemset/problem/202/A",
    "history": "This problem' s actual name, \" Lexicographically Largest Palindromic Subsequence\" is too long to fit into the page headline. You are given string s consisting of lowercase English letters only. Find its lexicographically largest palindromic subsequence. We' ll call a non- empty string s[ p1p2. . . pk] = sp1sp2. . . spk ( 1 \u2264 p1 < p2 < . . . < pk \u2264 | s| ) a subsequence of string s = s1s2. . . s| s| , where | s| is the length of string s. For example, strings \" abcb\" , \" b\" and \" abacaba\" are subsequences of string \" abacaba\" . String x = x1x2. . . x| x| is lexicographically larger than string y = y1y2. . . y| y| if either | x| > | y| and x1 = y1, x2 = y2, . . . , x| y| = y| y| , or there exists such number r ( r < | x| , r < | y| ) that x1 = y1, x2 = y2, . . . , xr = yr and xr + 1 > yr + 1. Characters in the strings are compared according to their ASCII codes. For example, string \" ranger\" is lexicographically larger than string \" racecar\" and string \" poster\" is lexicographically larger than string \" post\" . String s = s1s2. . . s| s| is a palindrome if it matches string rev( s) = s| s| s| s| - 1. . . s1. In other words, a string is a palindrome if it reads the same way from left to right and from right to left. For example, palindromic strings are \" racecar\" , \" refer\" and \" z\" .",
    "input": "The only input line contains a non- empty string s consisting of lowercase English letters only. Its length does not exceed 10.",
    "output": "Print the lexicographically largest palindromic subsequence of string s.",
    "note": "Among all distinct subsequences of string \" radar\" the following ones are palindromes: \" a\" , \" d\" , \" r\" , \" aa\" , \" rr\" , \" ada\" , \" rar\" , \" rdr\" , \" raar\" and \" radar\" . The lexicographically largest of them is \" rr\" .",
    "topics": [
      "binary search",
      "bitmasks",
      "brute force",
      "greedy",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "The Next Good String",
    "url": "https://codeforces.com/problemset/problem/196/D",
    "history": "In problems on strings one often has to find a string with some particular properties. The problem authors were reluctant to waste time on thinking of a name for some string so they called it good. A string is good if it doesn' t have palindrome substrings longer than or equal to d. You are given string s, consisting only of lowercase English letters. Find a good string t with length | s| , consisting of lowercase English letters, which is lexicographically larger than s. Of all such strings string t must be lexicographically minimum. We will call a non- empty string s[ a . . . b] = sasa + 1. . . sb ( 1 \u2264 a \u2264 b \u2264 | s| ) a substring of string s = s1s2. . . s| s| . A non- empty string s = s1s2. . . sn is called a palindrome if for all i from 1 to n the following fulfills: si = sn - i + 1. In other words, palindrome read the same in both directions. String x = x1x2. . . x| x| is lexicographically larger than string y = y1y2. . . y| y| , if either | x| > | y| and x1 = y1, x2 = y2, . . . , x| y| = y| y| , or there exists such number r ( r < | x| , r < | y| ) , that x1 = y1, x2 = y2, . . . , xr = yr and xr + 1 > yr + 1. Characters in such strings are compared like their ASCII codes.",
    "input": "The first line contains integer d ( 1 \u2264 d \u2264 | s| ) . The second line contains a non- empty string s, its length is no more than 4\u00b7105 characters. The string consists of lowercase English letters.",
    "output": "Print the good string that lexicographically follows s, has the same length and consists of only lowercase English letters. If such string does not exist, print \" Impossible\" ( without the quotes) .",
    "note": "",
    "topics": [
      "data structures",
      "greedy",
      "hashing",
      "strings"
    ]
  },
  {
    "title": "Lexicographically Maximum Subsequence",
    "url": "https://codeforces.com/problemset/problem/196/A",
    "history": "You' ve got string s, consisting of only lowercase English letters. Find its lexicographically maximum subsequence. We' ll call a non- empty string s[ p1p2. . . pk] = sp1sp2. . . spk( 1 \u2264 p1 < p2 < . . . < pk \u2264 | s| ) a subsequence of string s = s1s2. . . s| s| . String x = x1x2. . . x| x| is lexicographically larger than string y = y1y2. . . y| y| , if either | x| > | y| and x1 = y1, x2 = y2, . . . , x| y| = y| y| , or exists such number r ( r < | x| , r < | y| ) , that x1 = y1, x2 = y2, . . . , xr = yr and xr + 1 > yr + 1. Characters in lines are compared like their ASCII codes.",
    "input": "The single line contains a non- empty string s, consisting only of lowercase English letters. The string' s length doesn' t exceed 105.",
    "output": "Print the lexicographically maximum subsequence of string s.",
    "note": "Let' s look at samples and see what the sought subsequences look like ( they are marked with uppercase bold letters) . The first sample: aBaBBAThe second sample: abbCbCCaCbbCBaaBA",
    "topics": [
      "greedy",
      "strings"
    ]
  },
  {
    "title": "Comparing Strings",
    "url": "https://codeforces.com/problemset/problem/186/A",
    "history": "Some dwarves that are finishing the StUDY ( State University for Dwarven Youngsters) Bachelor courses, have been told \" no genome, no degree\" . That means that all dwarves should write a thesis on genome. Dwarven genome is far from simple. It is represented by a string that consists of lowercase Latin letters. Dwarf Misha has already chosen the subject for his thesis: determining by two dwarven genomes, whether they belong to the same race. Two dwarves belong to the same race if we can swap two characters in the first dwarf' s genome and get the second dwarf' s genome as a result. Help Dwarf Misha and find out whether two gnomes belong to the same race or not.",
    "input": "The first line contains the first dwarf' s genome: a non- empty string, consisting of lowercase Latin letters. The second line contains the second dwarf' s genome: a non- empty string, consisting of lowercase Latin letters. The number of letters in each genome doesn' t exceed 105. It is guaranteed that the strings that correspond to the genomes are different. The given genomes may have different length.",
    "output": "Print \" YES\" , if the dwarves belong to the same race. Otherwise, print \" NO\" .",
    "note": "First example: you can simply swap two letters in string \" ab\" . So we get \" ba\" . Second example: we can' t change string \" aa\" into string \" ab\" , because \" aa\" does not contain letter \" b\" .",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Common Divisors",
    "url": "https://codeforces.com/problemset/problem/182/D",
    "history": "Vasya has recently learned at school what a number' s divisor is and decided to determine a string' s divisor. Here is what he came up with. String a is the divisor of string b if and only if there exists a positive integer x such that if we write out string a consecutively x times, we get string b. For example, string \" abab\" has two divisors \u2014 \" ab\" and \" abab\" . Now Vasya wants to write a program that calculates the number of common divisors of two strings. Please help him.",
    "input": "The first input line contains a non- empty string s1. The second input line contains a non- empty string s2. Lengths of strings s1 and s2 are positive and do not exceed 105. The strings only consist of lowercase Latin letters.",
    "output": "Print the number of common divisors of strings s1 and s2.",
    "note": "In first sample the common divisors are strings \" abcd\" and \" abcdabcd\" . In the second sample the common divisor is a single string \" a\" . String \" aa\" isn' t included in the answer as it isn' t a divisor of string \" aaa\" .",
    "topics": [
      "brute force",
      "hashing",
      "implementation",
      "math",
      "strings"
    ]
  },
  {
    "title": "Name",
    "url": "https://codeforces.com/problemset/problem/180/D",
    "history": "Everything got unclear to us in a far away constellation Tau Ceti. Specifically, the Taucetians choose names to their children in a very peculiar manner. Two young parents abac and bbad think what name to give to their first- born child. They decided that the name will be the permutation of letters of string s. To keep up with the neighbours, they decided to call the baby so that the name was lexicographically strictly larger than the neighbour' s son' s name t. On the other hand, they suspect that a name tax will be introduced shortly. According to it, the Taucetians with lexicographically larger names will pay larger taxes. That' s the reason abac and bbad want to call the newborn so that the name was lexicographically strictly larger than name t and lexicographically minimum at that. The lexicographical order of strings is the order we are all used to, the \" dictionary\" order. Such comparison is used in all modern programming languages to compare strings. Formally, a string p of length n is lexicographically less than string q of length m, if one of the two statements is correct: n < m, and p is the beginning ( prefix) of string q ( for example, \" aba\" is less than string \" abaa\" ) , p1 = q1, p2 = q2, . . . , pk - 1 = qk - 1, pk < qk for some k ( 1 \u2264 k \u2264 min( n, m) ) , here characters in strings are numbered starting from 1. Write a program that, given string s and the heighbours' child' s name t determines the string that is the result of permutation of letters in s. The string should be lexicographically strictly more than t and also, lexicographically minimum.",
    "input": "The first line contains a non- empty string s ( 1 \u2264 | s| \u2264 5000) , where | s| is its length. The second line contains a non- empty string t ( 1 \u2264 | t| \u2264 5000) , where | t| is its length. Both strings consist of lowercase Latin letters.",
    "output": "Print the sought name or - 1 if it doesn' t exist.",
    "note": "In the first sample the given string s is the sought one, consequently, we do not need to change the letter order there.",
    "topics": [
      "greedy",
      "strings"
    ]
  },
  {
    "title": "Representative Sampling",
    "url": "https://codeforces.com/problemset/problem/178/F2",
    "history": "The Smart Beaver from ABBYY has a long history of cooperating with the \" Institute of Cytology and Genetics\" . Recently, the Institute staff challenged the Beaver with a new problem. The problem is as follows. There is a collection of n proteins ( not necessarily distinct) . Each protein is a string consisting of lowercase Latin letters. The problem that the scientists offered to the Beaver is to select a subcollection of size k from the initial collection of proteins so that the representativity of the selected subset of proteins is maximum possible. The Smart Beaver from ABBYY did some research and came to the conclusion that the representativity of a collection of proteins can be evaluated by a single number, which is simply calculated. Let' s suppose we have a collection a1, . . . , ak consisting of k strings describing proteins. The representativity of this collection is the following value: where f( x, y) is the length of the longest common prefix of strings x and y; for example, f( \" abc\" , \" abd\" ) = 2, and f( \" ab\" , \" bcd\" ) = 0. Thus, the representativity of collection of proteins \" abc\" , \" abd\" , \" abe\" equals 6, and the representativity of collection \" aaa\" , \" ba\" , \" ba\" equals 2. Having discovered that, the Smart Beaver from ABBYY asked the Cup contestants to write a program that selects, from the given collection of proteins, a subcollection of size k which has the largest possible value of representativity. Help him to solve this problem!",
    "input": "The first input line contains two integers n and k ( 1 \u2264 k \u2264 n) , separated by a single space. The following n lines contain the descriptions of proteins, one per line. Each protein is a non- empty string of no more than 500 characters consisting of only lowercase Latin letters ( a. . . z) . Some of the strings may be equal. The input limitations for getting 20 points are: 1 \u2264 n \u2264 20 The input limitations for getting 50 points are: 1 \u2264 n \u2264 100 The input limitations for getting 100 points are: 1 \u2264 n \u2264 2000",
    "output": "Print a single number denoting the largest possible value of representativity that a subcollection of size k of the given collection of proteins can have.",
    "note": "",
    "topics": [
      "dp",
      "sortings",
      "strings"
    ]
  },
  {
    "title": "Fibonacci Strings",
    "url": "https://codeforces.com/problemset/problem/177/G2",
    "history": "Fibonacci strings are defined as follows: f1 = \u00aba\u00bb f2 = \u00abb\u00bb fn = fn - 1 fn - 2, n > 2 Thus, the first five Fibonacci strings are: \" a\" , \" b\" , \" ba\" , \" bab\" , \" babba\" . You are given a Fibonacci string and m strings si. For each string si, find the number of times it occurs in the given Fibonacci string as a substring.",
    "input": "The first line contains two space- separated integers k and m \u2014 the number of a Fibonacci string and the number of queries, correspondingly. Next m lines contain strings si that correspond to the queries. It is guaranteed that strings si aren' t empty and consist only of characters \" a\" and \" b\" . The input limitations for getting 30 points are: 1 \u2264 k \u2264 3000 1 \u2264 m \u2264 3000 The total length of strings si doesn' t exceed 3000 The input limitations for getting 100 points are: 1 \u2264 k \u2264 1018 1 \u2264 m \u2264 104 The total length of strings si doesn' t exceed 105 Please do not use the",
    "output": "For each string si print the number of times it occurs in the given Fibonacci string as a substring. Since the numbers can be large enough, print them modulo 1000000007 ( 109 + 7) . Print the answers for the strings in the order in which they are given in the input.",
    "note": "",
    "topics": [
      "matrices",
      "strings"
    ]
  },
  {
    "title": "Fibonacci Strings",
    "url": "https://codeforces.com/problemset/problem/177/G1",
    "history": "Fibonacci strings are defined as follows: f1 = \u00aba\u00bb f2 = \u00abb\u00bb fn = fn - 1 fn - 2, n > 2 Thus, the first five Fibonacci strings are: \" a\" , \" b\" , \" ba\" , \" bab\" , \" babba\" . You are given a Fibonacci string and m strings si. For each string si, find the number of times it occurs in the given Fibonacci string as a substring.",
    "input": "The first line contains two space- separated integers k and m \u2014 the number of a Fibonacci string and the number of queries, correspondingly. Next m lines contain strings si that correspond to the queries. It is guaranteed that strings si aren' t empty and consist only of characters \" a\" and \" b\" . The input limitations for getting 30 points are: 1 \u2264 k \u2264 3000 1 \u2264 m \u2264 3000 The total length of strings si doesn' t exceed 3000 The input limitations for getting 100 points are: 1 \u2264 k \u2264 1018 1 \u2264 m \u2264 104 The total length of strings si doesn' t exceed 105 Please do not use the",
    "output": "For each string si print the number of times it occurs in the given Fibonacci string as a substring. Since the numbers can be large enough, print them modulo 1000000007 ( 109 + 7) . Print the answers for the strings in the order in which they are given in the input.",
    "note": "",
    "topics": [
      "strings"
    ]
  },
  {
    "title": "Wizards and Minimal Spell",
    "url": "https://codeforces.com/problemset/problem/168/B",
    "history": "Let' s dive into one of the most interesting areas of magic \u2014 writing spells. Learning this exciting but challenging science is very troublesome, so now you will not learn the magic words, but only get to know the basic rules of writing spells. Each spell consists of several lines. The line, whose first non- space character is character \" # \" is an amplifying line and it is responsible for spell power. The remaining lines are common, and determine the effect of the spell. You came across the text of some spell. Spell was too long, so you cannot understand its meaning. So you want to make it as short as possible without changing the meaning. The only way to shorten a spell that you know is the removal of some spaces and line breaks. We know that when it comes to texts of spells, the spaces carry meaning only in the amplifying lines, so we should remove all spaces in other lines. Newlines also do not matter, unless any of the two separated lines is amplifying. Thus, if two consecutive lines are not amplifying, they need to be joined into one ( i. e. we should concatenate the second line to the first one) . Removing spaces in amplifying lines and concatenating the amplifying lines to anything is forbidden. Note that empty lines must be processed just like all the others: they must be joined to the adjacent non- amplifying lines, or preserved in the output, if they are surrounded with amplifying lines on both sides ( i. e. the line above it, if there is one, is amplifying, and the line below it, if there is one, is amplifying too) . For now those are the only instructions for removing unnecessary characters that you have to follow ( oh yes, a newline is a character, too) . The input contains the text of the spell, which should be reduced. Remove the extra characters and print the result to the output.",
    "input": "The input contains multiple lines. All characters in the lines have codes from 32 to 127 ( inclusive) . Please note that the lines may begin with or end with one or more spaces. The size of the input does not exceed 1048576 ( = 220) bytes. Newlines are included in this size. In the Windows operating system used on the testing computer, a newline is a sequence of characters with codes # 13# 10. It is guaranteed that after each line of input there is a newline. In particular, the input ends with a newline. Note that the newline is the end of the line, and not the beginning of the next one. It is guaranteed that the input contains at least one character other than a newline. It is recommended to organize the input- output line by line, in this case the newlines will be processed correctly by the language means.",
    "output": "Print the text of the spell where all extra characters are deleted. Please note that each output line should be followed by a newline. Please be careful: your answers will be validated by comparing them to the jury' s answer byte- by- byte. So, all spaces and newlines matter.",
    "note": "In the first sample the amplifying lines are lines 1 and 7. So, lines 2 to 6 are concatenated to each other, all spaces are deleted from them. In the second sample the amplifying lines are lines 1 and 3. So, no lines are concatenated to each other.",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Another Problem on Strings",
    "url": "https://codeforces.com/problemset/problem/165/C",
    "history": "A string is binary, if it consists only of characters \" 0\" and \" 1\" . String v is a substring of string w if it has a non- zero length and can be read starting from some position in string w. For example, string \" 010\" has six substrings: \" 0\" , \" 1\" , \" 0\" , \" 01\" , \" 10\" , \" 010\" . Two substrings are considered different if their positions of occurrence are different. So, if some string occurs multiple times, we should consider it the number of times it occurs. You are given a binary string s. Your task is to find the number of its substrings, containing exactly k characters \" 1\" .",
    "input": "The first line contains the single integer k ( 0 \u2264 k \u2264 106) . The second line contains a non- empty binary string s. The length of s does not exceed 106 characters.",
    "output": "Print the single number \u2014 the number of substrings of the given string, containing exactly k characters \" 1\" . Please do not use the",
    "note": "In the first sample the sought substrings are: \" 1\" , \" 1\" , \" 10\" , \" 01\" , \" 10\" , \" 010\" . In the second sample the sought substrings are: \" 101\" , \" 0101\" , \" 1010\" , \" 01010\" .",
    "topics": [
      "binary search",
      "brute force",
      "dp",
      "math",
      "strings",
      "two pointers"
    ]
  },
  {
    "title": "e-Government",
    "url": "https://codeforces.com/problemset/problem/163/E",
    "history": "The best programmers of Embezzland compete to develop a part of the project called \" e- Government\" \u2014 the system of automated statistic collecting and press analysis. We know that any of the k citizens can become a member of the Embezzland government. The citizens' surnames are a1, a2, . . . , ak. All surnames are different. Initially all k citizens from this list are members of the government. The system should support the following options: Include citizen ai to the government. Exclude citizen ai from the government. Given a newspaper article text, calculate how politicized it is. To do this, for every active government member the system counts the number of times his surname occurs in the text as a substring. All occurrences are taken into consideration, including the intersecting ones. The degree of politicization of a text is defined as the sum of these values for all active government members. Implement this system.",
    "input": "The first line contains space- separated integers n and k ( 1 \u2264 n, k \u2264 105) \u2014 the number of queries to the system and the number of potential government members. Next k lines contain the surnames a1, a2, . . . , ak, one per line. All surnames are pairwise different. Next n lines contain queries to the system, one per line. Each query consists of a character that determines an operation and the operation argument, written consecutively without a space. Operation \" include in the government\" corresponds to the character \" + \" , operation \" exclude\" corresponds to \" - \" . An argument of those operations is an integer between 1 and k \u2014 the index of the citizen involved in the operation. Any citizen can be included and excluded from the government an arbitrary number of times in any order. Including in the government a citizen who is already there or excluding the citizen who isn' t there changes nothing. The operation \" calculate politicization\" corresponds to character \" ? \" . Its argument is a text. All strings \u2014 surnames and texts \u2014 are non- empty sequences of lowercase Latin letters. The total length of all surnames doesn' t exceed 106, the total length of all texts doesn' t exceed 106.",
    "output": "For any \" calculate politicization\" operation print on a separate line the degree of the politicization of the given text. Print nothing for other operations.",
    "note": "",
    "topics": [
      "data structures",
      "dfs and similar",
      "dp",
      "strings",
      "trees"
    ]
  },
  {
    "title": "Palindrome pairs",
    "url": "https://codeforces.com/problemset/problem/159/D",
    "history": "You are given a non- empty string s consisting of lowercase letters. Find the number of pairs of non- overlapping palindromic substrings of this string. In a more formal way, you have to find the quantity of tuples ( a, b, x, y) such that 1 \u2264 a \u2264 b < x \u2264 y \u2264 | s| and substrings s[ a. . . b] , s[ x. . . y] are palindromes. A palindrome is a string that can be read the same way from left to right and from right to left. For example, \" abacaba\" , \" z\" , \" abba\" are palindromes. A substring s[ i. . . j] ( 1 \u2264 i \u2264 j \u2264 | s| ) of string s = s1s2. . . s| s| is a string sisi + 1. . . sj. For example, substring s[ 2. . . 4] of string s = \" abacaba\" equals \" bac\" .",
    "input": "The first line of input contains a non- empty string s which consists of lowercase letters ( ' a' . . . ' z' ) , s contains at most 2000 characters.",
    "output": "Output a single number \u2014 the quantity of pairs of non- overlapping palindromic substrings of s. Please do not use the",
    "note": "",
    "topics": [
      "*special",
      "brute force",
      "dp",
      "strings"
    ]
  },
  {
    "title": "String Manipulation 1.0",
    "url": "https://codeforces.com/problemset/problem/159/C",
    "history": "One popular website developed an unusual username editing procedure. One can change the username only by deleting some characters from it: to change the current name s, a user can pick number p and character c and delete the p- th occurrence of character c from the name. After the user changed his name, he can' t undo the change. For example, one can change name \" arca\" by removing the second occurrence of character \" a\" to get \" arc\" . Polycarpus learned that some user initially registered under nickname t, where t is a concatenation of k copies of string s. Also, Polycarpus knows the sequence of this user' s name changes. Help Polycarpus figure out the user' s final name.",
    "input": "The first line contains an integer k ( 1 \u2264 k \u2264 2000) . The second line contains a non- empty string s, consisting of lowercase Latin letters, at most 100 characters long. The third line contains an integer n ( 0 \u2264 n \u2264 20000) \u2014 the number of username changes. Each of the next n lines contains the actual changes, one per line. The changes are written as \" pi ci\" ( without the quotes) , where pi ( 1 \u2264 pi \u2264 200000) is the number of occurrences of letter ci, ci is a lowercase Latin letter. It is guaranteed that the operations are correct, that is, the letter to be deleted always exists, and after all operations not all letters are deleted from the name. The letters' occurrences are numbered starting from 1.",
    "output": "Print a single string \u2014 the user' s final name after all changes are applied to it.",
    "note": "Let' s consider the first sample. Initially we have name \" bacbac\" ; the first operation transforms it into \" bacbc\" , the second one \u2014 to \" acbc\" , and finally, the third one transforms it into \" acb\" .",
    "topics": [
      "*special",
      "binary search",
      "brute force",
      "data structures",
      "strings"
    ]
  },
  {
    "title": "Phone Numbers",
    "url": "https://codeforces.com/problemset/problem/151/B",
    "history": "Winters are just damn freezing cold in Nvodsk! That' s why a group of n friends prefers to take a taxi, order a pizza and call girls. The phone numbers in the city consist of three pairs of digits ( for example, 12- 34- 56) . Each friend has a phonebook of size si ( that' s the number of phone numbers) . We know that taxi numbers consist of six identical digits ( for example, 22- 22- 22) , the numbers of pizza deliveries should necessarily be decreasing sequences of six different digits ( for example, 98- 73- 21) , all other numbers are the girls' numbers. You are given your friends' phone books. Calculate which friend is best to go to when you are interested in each of those things ( who has maximal number of phone numbers of each type) . If the phone book of one person contains some number two times, you should count it twice. That is, each number should be taken into consideration the number of times it occurs in the phone book.",
    "input": "The first line contains an integer n ( 1 \u2264 n \u2264 100) \u2014 the number of friends. Then follow n data blocks that describe each friend' s phone books. Each block is presented in the following form: first goes the line that contains integer si and string namei ( 0 \u2264 si \u2264 100) \u2014 the number of phone numbers in the phone book of the i- th friend and the name of the i- th friend. The name is a non- empty sequence of uppercase and lowercase Latin letters, containing no more than 20 characters. Next si lines contain numbers as \" XX- XX- XX\" , where X is arbitrary digits from 0 to 9.",
    "output": "In the first line print the phrase \" If you want to call a taxi, you should call: \" . Then print names of all friends whose phone books contain maximal number of taxi phone numbers. In the second line print the phrase \" If you want to order a pizza, you should call: \" . Then print names of all friends who have maximal number of pizza phone numbers. In the third line print the phrase \" If you want to go to a cafe with a wonderful girl, you should call: \" . Then print names of all friends who have maximal number of girls' phone numbers. Print the names in the order in which they are given in the input data. Separate two consecutive names with a comma and a space. Each line should end with exactly one point. For clarifications concerning the output form, see sample tests. It is necessary that you follow the output form strictly. Extra spaces are not allowed.",
    "note": "In the first sample you are given four friends. Fedorov' s phone book contains one taxi number and one pizza delivery number, Melnikov' s phone book only has 3 numbers of girls, Rogulenko' s one has 6 taxi numbers and one pizza delivery number, Kaluzhin' s one contains 2 taxi numbers and one pizza delivery number. Thus, if you need to order a taxi, you should obviously call Rogulenko, if you need to order a pizza you should call anybody of the following: Rogulenko, Fedorov, Kaluzhin ( each of them has one number) . Melnikov has maximal number of phone numbers of girls.",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Mission Impassable",
    "url": "https://codeforces.com/problemset/problem/150/D",
    "history": "Market stalls now have the long- awaited game The Colder Scrools V: Nvodsk. The game turned out to be difficult as hell and most students can' t complete the last quest ( \" We don' t go to Nvodsk. . . \" ) . That threatened winter exams. The rector already started to wonder whether he should postpone the winter exams till April ( in fact, he wanted to complete the quest himself) . But all of a sudden a stranger appeared at the door of his office. \" Good afternoon. My name is Chuck and I solve any problems\" \u2014 he said. And here they are sitting side by side but still they can' t complete the mission. The thing is, to kill the final boss one should prove one' s perfect skills in the art of managing letters. One should be a real magician to do that. And can you imagine what happens when magicians start competing. . . But let' s put it more formally: you are given a string and a set of integers ai. You are allowed to choose any substring that is a palindrome and delete it. At that we receive some number of points equal to ak, where k is the length of the deleted palindrome. For some k, ak = - 1, which means that deleting palindrome strings of such length is forbidden. After a substring is deleted, the remaining part \" shifts together\" , that is, at no moment of time the string has gaps. The process is repeated while the string has at least one palindrome substring that can be deleted. All gained points are summed up. Determine what maximum number of points can be earned. \" Oh\" \u2014 said Chuck, raising from the chair, \u2014 \" I used to love deleting palindromes, just like you, but one day I took an arrow in the Knee\" .",
    "input": "The first line contains an integer l ( 1 \u2264 l \u2264 150) \u2014 the length of the string. The second line contains exactly l integers ak ( - 1 \u2264 ak \u2264 105) \u2014 the points a player gains for deleting. The third line contains exactly l lowercase Latin letters \u2014 the original string from which a player can delete palindromes. The line contains no other characters apart from the newline character at the end of the string.",
    "output": "Print a single number \u2014 the maximum number of points one can gain if he plays on the given string.",
    "note": "In the first sample we cannot delete any substring, so the best result is 0. In the second sample we are allowed to delete only those palindromes whose length equals 1, thus, if we delete the whole string, we get 7 points. In the third sample the optimal strategy is: first we delete character c, then string aa, then bb, and the last one aa. At that we get 1 + 3 * 5 = 16 points.",
    "topics": [
      "dp",
      "strings"
    ]
  },
  {
    "title": "Martian Strings",
    "url": "https://codeforces.com/problemset/problem/149/E",
    "history": "During the study of the Martians Petya clearly understood that the Martians are absolutely lazy. They like to sleep and don' t like to wake up. Imagine a Martian who has exactly n eyes located in a row and numbered from the left to the right from 1 to n. When a Martian sleeps, he puts a patch on each eye ( so that the Martian morning doesn' t wake him up) . The inner side of each patch has an uppercase Latin letter. So, when a Martian wakes up and opens all his eyes he sees a string s consisting of uppercase Latin letters. The string' s length is n. \" Ding dong! \" \u2014 the alarm goes off. A Martian has already woken up but he hasn' t opened any of his eyes. He feels that today is going to be a hard day, so he wants to open his eyes and see something good. The Martian considers only m Martian words beautiful. Besides, it is hard for him to open all eyes at once so early in the morning. So he opens two non- overlapping segments of consecutive eyes. More formally, the Martian chooses four numbers a, b, c, d, ( 1 \u2264 a \u2264 b < c \u2264 d \u2264 n) and opens all eyes with numbers i such that a \u2264 i \u2264 b or c \u2264 i \u2264 d. After the Martian opens the eyes he needs, he reads all the visible characters from the left to the right and thus, he sees some word. Let' s consider all different words the Martian can see in the morning. Your task is to find out how many beautiful words are among them.",
    "input": "The first line contains a non- empty string s consisting of uppercase Latin letters. The strings' length is n ( 2 \u2264 n \u2264 105) . The second line contains an integer m ( 1 \u2264 m \u2264 100) \u2014 the number of beautiful words. Next m lines contain the beautiful words pi, consisting of uppercase Latin letters. Their length is from 1 to 1000. All beautiful strings are pairwise different.",
    "output": "Print the single integer \u2014 the number of different beautiful strings the Martian can see this morning.",
    "note": "Let' s consider the sample test. There the Martian can get only the second beautiful string if he opens segments of eyes a = 1, b = 2 and c = 4, d = 5 or of he opens segments of eyes a = 1, b = 2 and c = 6, d = 7.",
    "topics": [
      "string suffix structures",
      "strings"
    ]
  },
  {
    "title": "Punctuation",
    "url": "https://codeforces.com/problemset/problem/147/A",
    "history": "You are given a text that consists of lowercase Latin letters, spaces and punctuation marks ( dot, comma, exclamation mark and question mark) . A word is defined as a sequence of consecutive Latin letters. Your task is to add spaces to the text by the following rules: if there is no punctuation mark between two words, then they should be separated by exactly one space there should be no spaces before each punctuation mark there should be exactly one space after each punctuation mark It is guaranteed that there is at least one word between any two punctuation marks. The text begins and ends with a Latin letter.",
    "input": "The input data contains of a single non- empty line \u2014 the text whose length is no more than 10000 characters.",
    "output": "Print the text, edited according to the rules. In this problem you should follow the output format very strictly. For example, extra space at the end of the output line is considered as wrong answer. Note that a newline character at the end of the line doesn' t matter.",
    "note": "",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Anagram Search",
    "url": "https://codeforces.com/problemset/problem/144/C",
    "history": "A string t is called an anagram of the string s, if it is possible to rearrange letters in t so that it is identical to the string s. For example, the string \" aab\" is an anagram of the string \" aba\" and the string \" aaa\" is not. The string t is called a substring of the string s if it can be read starting from some position in the string s. For example, the string \" aba\" has six substrings: \" a\" , \" b\" , \" a\" , \" ab\" , \" ba\" , \" aba\" . You are given a string s, consisting of lowercase Latin letters and characters \" ? \" . You are also given a string p, consisting of lowercase Latin letters only. Let' s assume that a string is good if you can obtain an anagram of the string p from it, replacing the \" ? \" characters by Latin letters. Each \" ? \" can be replaced by exactly one character of the Latin alphabet. For example, if the string p = \u00ababa\u00bb, then the string \" a? ? \" is good, and the string \u00ab? bc\u00bb is not. Your task is to find the number of good substrings of the string s ( identical substrings must be counted in the answer several times) .",
    "input": "The first line is non- empty string s, consisting of no more than 105 lowercase Latin letters and characters \" ? \" . The second line is non- empty string p, consisting of no more than 105 lowercase Latin letters. Please note that the length of the string p can exceed the length of the string s.",
    "output": "Print the single number representing the number of good substrings of string s. Two substrings are considered different in their positions of occurrence are different. Thus, if some string occurs several times, then it should be counted the same number of times.",
    "note": "Consider the first sample test. Here the string s has two good substrings: \" b? ? \" ( after we replace the question marks we get \" baa\" ) , \" ? ? ? \" ( after we replace the question marks we get \" baa\" ) . Let' s consider the second sample test. Here the string s has two good substrings: \" ab? \" ( \" ? \" can be replaced by \" c\" ) , \" b? c\" ( \" ? \" can be replaced by \" a\" ) .",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Help Kingdom of Far Far Away 2",
    "url": "https://codeforces.com/problemset/problem/143/B",
    "history": "For some time the program of rounding numbers that had been developed by the Codeforces participants during one of the previous rounds, helped the citizens of Far Far Away to convert numbers into a more easily readable format. However, as time went by, the economy of the Far Far Away developed and the scale of operations grew. So the King ordered to found the Bank of Far Far Away and very soon even the rounding didn' t help to quickly determine even the order of the numbers involved in operations. Besides, rounding a number to an integer wasn' t very convenient as a bank needed to operate with all numbers with accuracy of up to 0. 01, and not up to an integer. The King issued yet another order: to introduce financial format to represent numbers denoting amounts of money. The formal rules of storing a number in the financial format are as follows: A number contains the integer part and the fractional part. The two parts are separated with a character \" . \" ( decimal point) . To make digits in the integer part of a number easier to read, they are split into groups of three digits, starting from the least significant ones. The groups are separated with the character \" , \" ( comma) . For example, if the integer part of a number equals 12345678, then it will be stored in the financial format as 12, 345, 678 In the financial format a number' s fractional part should contain exactly two digits. So, if the initial number ( the number that is converted into the financial format) contains less than two digits in the fractional part ( or contains no digits at all) , it is complemented with zeros until its length equals 2. If the fractional part contains more than two digits, the extra digits are simply discarded ( they are not rounded: see sample tests) . When a number is stored in the financial format, the minus sign is not written. Instead, if the initial number had the minus sign, the result is written in round brackets. Please keep in mind that the bank of Far Far Away operates using an exotic foreign currency \u2014 snakes ( ) , that' s why right before the number in the financial format we should put the sign \" \" . If the number should be written in the brackets, then the snake sign should also be inside the brackets. For example, by the above given rules number 2012 will be stored in the financial format as \" 2, 012. 00\" and number - 12345678. 9 will be stored as \" ( 12, 345, 678. 90) \" . The merchants of Far Far Away visited you again and expressed much hope that you supply them with the program that can convert arbitrary numbers to the financial format. Can you help them?",
    "input": "The input contains a number that needs to be converted into financial format. The number' s notation length does not exceed 100 characters, including ( possible) signs \" - \" ( minus) and \" . \" ( decimal point) . The number' s notation is correct, that is: The number' s notation only contains characters from the set \" 0\" \u2013 \" 9\" , \" - \" , \" . \" . The decimal point ( if it is present) is unique and is preceded and followed by a non- zero quantity on decimal digits A number cannot start with digit 0, except for a case when its whole integer part equals zero ( in this case the integer parts is guaranteed to be a single zero: \" 0\" ) . The minus sign ( if it is present) is unique and stands in the very beginning of the number' s notation If a number is identically equal to 0 ( that is, if it is written as, for example, \" 0\" or \" 0. 000\" ) , than it is not preceded by the minus sign. The input data contains no spaces. The number' s notation contains at least one decimal digit.",
    "output": "Print the number given in the input in the financial format by the rules described in the problem statement.",
    "note": "Pay attention to the second and third sample tests. They show that the sign of a number in the financial format ( and consequently, the presence or absence of brackets) is determined solely by the sign of the initial number. It does not depend on the sign of the number you got after translating the number to the financial format.",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Amusing Joke",
    "url": "https://codeforces.com/problemset/problem/141/A",
    "history": "So, the New Year holidays are over. Santa Claus and his colleagues can take a rest and have guests at last. When two \" New Year and Christmas Men\" meet, thear assistants cut out of cardboard the letters from the guest' s name and the host' s name in honor of this event. Then the hung the letters above the main entrance. One night, when everyone went to bed, someone took all the letters of our characters' names. Then he may have shuffled the letters and put them in one pile in front of the door. The next morning it was impossible to find the culprit who had made the disorder. But everybody wondered whether it is possible to restore the names of the host and his guests from the letters lying at the door? That is, we need to verify that there are no extra letters, and that nobody will need to cut more letters. Help the \" New Year and Christmas Men\" and their friends to cope with this problem. You are given both inscriptions that hung over the front door the previous night, and a pile of letters that were found at the front door next morning.",
    "input": "The input file consists of three lines: the first line contains the guest' s name, the second line contains the name of the residence host and the third line contains letters in a pile that were found at the door in the morning. All lines are not empty and contain only uppercase Latin letters. The length of each line does not exceed 100.",
    "output": "Print \" YES\" without the quotes, if the letters in the pile could be permuted to make the names of the \" New Year and Christmas Men\" . Otherwise, print \" NO\" without the quotes.",
    "note": "In the first sample the letters written in the last line can be used to write the names and there won' t be any extra letters left. In the second sample letter \" P\" is missing from the pile and there' s an extra letter \" L\" . In the third sample there' s an extra letter \" L\" .",
    "topics": [
      "implementation",
      "sortings",
      "strings"
    ]
  },
  {
    "title": "Last Chance",
    "url": "https://codeforces.com/problemset/problem/137/E",
    "history": "Having read half of the book called \" Storm and Calm\" on the IT lesson, Innocentius was absolutely determined to finish the book on the maths lessons. All was fine until the math teacher Ms. Watkins saw Innocentius reading fiction books instead of solving equations of the fifth degree. As during the last maths class Innocentius suggested the algorithm of solving equations of the fifth degree in the general case, Ms. Watkins had no other choice but to give him a new task. The teacher asked to write consecutively ( without spaces) all words from the \" Storm and Calm\" in one long string s. She thought that a string is good if the number of vowels in the string is no more than twice more than the number of consonants. That is, the string with v vowels and c consonants is good if and only if v \u2264 2c. The task Innocentius had to solve turned out to be rather simple: he should find the number of the longest good substrings of the string s.",
    "input": "The only input line contains a non- empty string s consisting of no more than 2\u00b7105 uppercase and lowercase Latin letters. We shall regard letters \" a\" , \" e\" , \" i\" , \" o\" , \" u\" and their uppercase variants as vowels.",
    "output": "Print on a single line two numbers without a space: the maximum length of a good substring and the number of good substrings with this length. If no good substring exists, print \" No solution\" without the quotes. Two substrings are considered different if their positions of occurrence are different. So if some string occurs more than once, then it should be counted more than once.",
    "note": "In the first sample there is only one longest good substring: \" Abo\" itself. The other good substrings are \" b\" , \" Ab\" , \" bo\" , but these substrings have shorter length. In the second sample there is only one longest good substring: \" EIS\" . The other good substrings are: \" S\" , \" IS\" .",
    "topics": [
      "data structures",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Palindromes",
    "url": "https://codeforces.com/problemset/problem/137/D",
    "history": "Friday is Polycarpus' favourite day of the week. Not because it is followed by the weekend, but because the lessons on Friday are 2 IT lessons, 2 math lessons and 2 literature lessons. Of course, Polycarpus has prepared to all of them, unlike his buddy Innocentius. Innocentius spent all evening playing his favourite game Fur2 and didn' t have enough time to do the literature task. As Innocentius didn' t want to get an F, he decided to do the task and read the book called \" Storm and Calm\" during the IT and Math lessons ( he never used to have problems with these subjects) . When the IT teacher Mr. Watkins saw this, he decided to give Innocentius another task so that the boy concentrated more on the lesson and less \u2014 on the staff that has nothing to do with IT. Mr. Watkins said that a palindrome is a string that can be read the same way in either direction, from the left to the right and from the right to the left. A concatenation of strings a, b is a string ab that results from consecutive adding of string b to string a. Of course, Innocentius knew it all but the task was much harder than he could have imagined. Mr. Watkins asked change in the \" Storm and Calm\" the minimum number of characters so that the text of the book would also be a concatenation of no more than k palindromes. Innocentius can' t complete the task and therefore asks you to help him.",
    "input": "The first input line contains a non- empty string s which is the text of \" Storm and Calm\" ( without spaces) . The length of the string s does not exceed 500 characters. String s consists of uppercase and lowercase Latin letters. The second line contains a single number k ( 1 \u2264 k \u2264 | s| , where | s| represents the length of the string s) .",
    "output": "Print on the first line the minimum number of changes that Innocentius will have to make. Print on the second line the string consisting of no more than k palindromes. Each palindrome should be non- empty and consist of uppercase and lowercase Latin letters. Use the character \" + \" ( ASCII- code 43) to separate consecutive palindromes. If there exist several solutions, print any of them. The letters' case does matter, that is an uppercase letter is not considered equivalent to the corresponding lowercase letter.",
    "note": "",
    "topics": [
      "dp",
      "strings"
    ]
  },
  {
    "title": "cAPS lOCK",
    "url": "https://codeforces.com/problemset/problem/131/A",
    "history": "wHAT DO WE NEED cAPS LOCK FOR? Caps lock is a computer keyboard key. Pressing it sets an input mode in which typed letters are capital by default. If it is pressed by accident, it leads to accidents like the one we had in the first passage. Let' s consider that a word has been typed with the Caps lock key accidentally switched on, if: either it only contains uppercase letters; or all letters except for the first one are uppercase. In this case we should automatically change the case of all letters. For example, the case of the letters that form words \" hELLO\" , \" HTTP\" , \" z\" should be changed. Write a program that applies the rule mentioned above. If the rule cannot be applied, the program should leave the word unchanged.",
    "input": "The first line of the input data contains a word consisting of uppercase and lowercase Latin letters. The word' s length is from 1 to 100 characters, inclusive.",
    "output": "Print the result of the given word' s processing.",
    "note": "",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Gnikool Ssalg",
    "url": "https://codeforces.com/problemset/problem/130/B",
    "history": "You are given a string. Reverse its characters.",
    "input": "The only line of input contains a string between 1 and 100 characters long. Each character of the string has ASCII- code between 33 ( exclamation mark) and 126 ( tilde) , inclusive.",
    "output": "Output the characters of this string in reverse order.",
    "note": "",
    "topics": [
      "*special",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "String",
    "url": "https://codeforces.com/problemset/problem/128/B",
    "history": "One day in the IT lesson Anna and Maria learned about the lexicographic order. String x is lexicographically less than string y, if either x is a prefix of y ( and x = \u0338 y) , or there exists such i ( 1 \u2264 i \u2264 min( | x| , | y| ) ) , that xi < yi, and for any j ( 1 \u2264 j < i) xj = yj. Here | a| denotes the length of the string a. The lexicographic comparison of strings is implemented by operator < in modern programming languages\u200b\u200b. The teacher gave Anna and Maria homework. She gave them a string of length n. They should write out all substrings of the given string, including the whole initial string, and the equal substrings ( for example, one should write out the following substrings from the string \" aab\" : \" a\" , \" a\" , \" aa\" , \" ab\" , \" aab\" , \" b\" ) . The resulting strings should be sorted in the lexicographical order. The cunning teacher doesn' t want to check all these strings. That' s why she said to find only the k- th string from the list. Help Anna and Maria do the homework.",
    "input": "The first line contains a non- empty string that only consists of small Latin letters ( \" a\" - \" z\" ) , whose length does not exceed 105. The second line contains the only integer k ( 1 \u2264 k \u2264 105) .",
    "output": "Print the string Anna and Maria need \u2014 the k- th ( in the lexicographical order) substring of the given string. If the total number of substrings is less than k, print a string saying \" No such line. \" ( without the quotes) .",
    "note": "In the second sample before string \" bc\" follow strings \" a\" , \" ab\" , \" abc\" , \" b\" .",
    "topics": [
      "brute force",
      "constructive algorithms",
      "hashing",
      "implementation",
      "string suffix structures",
      "strings"
    ]
  },
  {
    "title": "Password",
    "url": "https://codeforces.com/problemset/problem/126/B",
    "history": "Asterix, Obelix and their temporary buddies Suffix and Prefix has finally found the Harmony temple. However, its doors were firmly locked and even Obelix had no luck opening them. A little later they found a string s, carved on a rock below the temple' s gates. Asterix supposed that that' s the password that opens the temple and read the string aloud. However, nothing happened. Then Asterix supposed that a password is some substring t of the string s. Prefix supposed that the substring t is the beginning of the string s; Suffix supposed that the substring t should be the end of the string s; and Obelix supposed that t should be located somewhere inside the string s, that is, t is neither its beginning, nor its end. Asterix chose the substring t so as to please all his companions. Besides, from all acceptable variants Asterix chose the longest one ( as Asterix loves long strings) . When Asterix read the substring t aloud, the temple doors opened. You know the string s. Find the substring t or determine that such substring does not exist and all that' s been written above is just a nice legend.",
    "input": "You are given the string s whose length can vary from 1 to 106 ( inclusive) , consisting of small Latin letters.",
    "output": "Print the string t. If a suitable t string does not exist, then print \" Just a legend\" without the quotes.",
    "note": "",
    "topics": [
      "binary search",
      "dp",
      "hashing",
      "string suffix structures",
      "strings"
    ]
  },
  {
    "title": "Prime Permutation",
    "url": "https://codeforces.com/problemset/problem/123/A",
    "history": "You are given a string s, consisting of small Latin letters. Let' s denote the length of the string as | s| . The characters in the string are numbered starting from 1. Your task is to find out if it is possible to rearrange characters in string s so that for any prime number p \u2264 | s| and for any integer i ranging from 1 to | s| / p ( inclusive) the following condition was fulfilled sp = sp \u00d7 i. If the answer is positive, find one way to rearrange the characters.",
    "input": "The only line contains the initial string s, consisting of small Latin letters ( 1 \u2264 | s| \u2264 1000) .",
    "output": "If it is possible to rearrange the characters in the string so that the above- mentioned conditions were fulfilled, then print in the first line \" YES\" ( without the quotes) and print on the second line one of the possible resulting strings. If such permutation is impossible to perform, then print the single string \" NO\" .",
    "note": "In the first sample any of the six possible strings will do: \" abc\" , \" acb\" , \" bac\" , \" bca\" , \" cab\" or \" cba\" . In the second sample no letter permutation will satisfy the condition at p = 2 ( s2 = s4) . In the third test any string where character \" y\" doesn' t occupy positions 2, 3, 4, 6 will be valid.",
    "topics": [
      "implementation",
      "number theory",
      "strings"
    ]
  },
  {
    "title": "Lucky Transformation",
    "url": "https://codeforces.com/problemset/problem/121/B",
    "history": "Petya loves lucky numbers. Everybody knows that lucky numbers are positive integers whose decimal representation contains only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not. Petya has a number consisting of n digits without leading zeroes. He represented it as an array of digits without leading zeroes. Let' s call it d. The numeration starts with 1, starting from the most significant digit. Petya wants to perform the following operation k times: find the minimum x ( 1 \u2264 x < n) such that dx = 4 and dx + 1 = 7, if x is odd, then to assign dx = dx + 1 = 4, otherwise to assign dx = dx + 1 = 7. Note that if no x was found, then the operation counts as completed and the array doesn' t change at all. You are given the initial number as an array of digits and the number k. Help Petya find the result of completing k operations.",
    "input": "The first line contains two integers n and k ( 1 \u2264 n \u2264 105, 0 \u2264 k \u2264 109) \u2014 the number of digits in the number and the number of completed operations. The second line contains n digits without spaces representing the array of digits d, starting with d1. It is guaranteed that the first digit of the number does not equal zero.",
    "output": "In the single line print the result without spaces \u2014 the number after the k operations are fulfilled.",
    "note": "In the first sample the number changes in the following sequence: 4727447 \u2192 4427447 \u2192 4427477 \u2192 4427447 \u2192 4427477. In the second sample: 4478 \u2192 4778 \u2192 4478.",
    "topics": [
      "strings"
    ]
  },
  {
    "title": "String Transformation",
    "url": "https://codeforces.com/problemset/problem/119/D",
    "history": "Let s be a string whose length equals n. Its characters are numbered from 0 to n - 1, i and j are integers, 0 \u2264 i < j < n. Let' s define function f as follows: f( s, i, j) = s[ i + 1. . . j - 1] + r( s[ j. . . n - 1] ) + r( s[ 0. . . i] ) . Here s[ p. . . q] is a substring of string s, that starts in position p and ends in position q ( inclusive) ; \" + \" is the string concatenation operator; r( x) is a string resulting from writing the characters of the x string in the reverse order. If j = i + 1, then the substring s[ i + 1. . . j - 1] is considered empty. You are given two strings a and b. Find such values of i and j, that f( a, i, j) = b. Number i should be maximally possible. If for this i there exists several valid values of j, choose the minimal j.",
    "input": "The first two input lines are non- empty strings a and b correspondingly. Each string' s length does not exceed 106 characters. The strings can contain any characters with ASCII codes from 32 to 126 inclusive.",
    "output": "Print two integers i, j \u2014 the answer to the problem. If no solution exists, print \" - 1 - 1\" ( without the quotes) .",
    "note": "",
    "topics": [
      "hashing",
      "strings"
    ]
  },
  {
    "title": "Fancy Number",
    "url": "https://codeforces.com/problemset/problem/118/C",
    "history": "A car number in Berland consists of exactly n digits. A number is called beautiful if it has at least k equal digits. Vasya wants to change the digits in his car' s number so that the number became beautiful. To replace one of n digits Vasya has to pay the sum of money, equal to the absolute difference between the old digit and the new one. Help Vasya: find the minimum sum of money he should pay to make the number of his car beautiful. You should also find the resulting beautiful number. If there are several such numbers, then print the lexicographically minimum one.",
    "input": "The first line contains two space- separated integers n and k ( 2 \u2264 n \u2264 104, 2 \u2264 k \u2264 n) which represent how many digits the number has and how many equal digits a beautiful number should have. The second line consists of n digits. It describes the old number of Vasya' s car. It is guaranteed that the number contains no spaces and only contains digits.",
    "output": "On the first line print the minimum sum of money Vasya needs to change the number. On the second line print the car' s new number. If there are several solutions, print the lexicographically minimum one.",
    "note": "In the first sample replacing the second digit with an \" 8\" costs | 9 - 8| = 1. Replacing the fifth digit with an \" 8\" costs the same. Replacing the sixth digit costs | 6 - 8| = 2. As a result, Vasya will pay 1 + 1 + 2 = 4 for a beautiful number \" 888188\" . The lexicographical comparison of strings is performed by the < operator in modern programming languages. The string x is lexicographically smaller than the string y, if there exists such i ( 1 \u2264 i \u2264 n) , that xi < yi, and for any j ( 1 \u2264 j < i) xj = yj. The strings compared in this problem will always have the length n.",
    "topics": [
      "brute force",
      "greedy",
      "sortings",
      "strings"
    ]
  },
  {
    "title": "String Task",
    "url": "https://codeforces.com/problemset/problem/118/A",
    "history": "Petya started to attend programming lessons. On the first lesson his task was to write a simple program. The program was supposed to do the following: in the given string, consisting if uppercase and lowercase Latin letters, it: deletes all the vowels, inserts a character \" . \" before each consonant, replaces all uppercase consonants with corresponding lowercase ones. Vowels are letters \" A\" , \" O\" , \" Y\" , \" E\" , \" U\" , \" I\" , and the rest are consonants. The program' s input is exactly one string, it should return the output as a single string, resulting after the program' s processing the initial string. Help Petya cope with this easy task.",
    "input": "The first line represents input string of Petya' s program. This string only consists of uppercase and lowercase Latin letters and its length is from 1 to 100, inclusive.",
    "output": "Print the resulting string. It is guaranteed that this string is not empty.",
    "note": "",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Petr#",
    "url": "https://codeforces.com/problemset/problem/113/B",
    "history": "Long ago, when Petya was a schoolboy, he was very much interested in the Petr# language grammar. During one lesson Petya got interested in the following question: how many different continuous substrings starting with the sbegin and ending with the send ( it is possible sbegin = send) , the given string t has. Substrings are different if and only if their contents aren' t equal, their positions of occurence don' t matter. Petya wasn' t quite good at math, that' s why he couldn' t count this number. Help him!",
    "input": "The input file consists of three lines. The first line contains string t. The second and the third lines contain the sbegin and send identificators, correspondingly. All three lines are non- empty strings consisting of lowercase Latin letters. The length of each string doesn' t exceed 2000 characters.",
    "output": "Output the only number \u2014 the amount of different substrings of t that start with sbegin and end with send.",
    "note": "In the third sample there are four appropriate different substrings. They are: ab, abab, ababab, abababab. In the fourth sample identificators intersect.",
    "topics": [
      "brute force",
      "data structures",
      "hashing",
      "strings"
    ]
  },
  {
    "title": "Grammar Lessons",
    "url": "https://codeforces.com/problemset/problem/113/A",
    "history": "Petya got interested in grammar on his third year in school. He invented his own language called Petya' s. Petya wanted to create a maximally simple language that would be enough to chat with friends, that' s why all the language' s grammar can be described with the following set of rules: There are three parts of speech: the adjective, the noun, the verb. Each word in his language is an adjective, noun or verb. There are two genders: masculine and feminine. Each word in his language has gender either masculine or feminine. Masculine adjectives end with - lios, and feminine adjectives end with - liala. Masculine nouns end with - etr, and feminime nouns end with - etra. Masculine verbs end with - initis, and feminime verbs end with - inites. Thus, each word in the Petya' s language has one of the six endings, given above. There are no other endings in Petya' s language. It is accepted that the whole word consists of an ending. That is, words \" lios\" , \" liala\" , \" etr\" and so on belong to the Petya' s language. There aren' t any punctuation marks, grammatical tenses, singular/ plural forms or other language complications. A sentence is either exactly one valid language word or exactly one statement. Statement is any sequence of the Petya' s language, that satisfy both conditions: Words in statement follow in the following order ( from the left to the right) : zero or more adjectives followed by exactly one noun followed by zero or more verbs. All words in the statement should have the same gender. After Petya' s friend Vasya wrote instant messenger ( an instant messaging program) that supported the Petya' s language, Petya wanted to add spelling and grammar checking to the program. As Vasya was in the country and Petya didn' t feel like waiting, he asked you to help him with this problem. Your task is to define by a given sequence of words, whether it is true that the given text represents exactly one sentence in Petya' s language.",
    "input": "The first line contains one or more words consisting of lowercase Latin letters. The overall number of characters ( including letters and spaces) does not exceed 105. It is guaranteed that any two consecutive words are separated by exactly one space and the input data do not contain any other spaces. It is possible that given words do not belong to the Petya' s language.",
    "output": "If some word of the given text does not belong to the Petya' s language or if the text contains more that one sentence, print \" NO\" ( without the quotes) . Otherwise, print \" YES\" ( without the quotes) .",
    "note": "",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Petya and Strings",
    "url": "https://codeforces.com/problemset/problem/112/A",
    "history": "Little Petya loves presents. His mum bought him two strings of the same size for his birthday. The strings consist of uppercase and lowercase Latin letters. Now Petya wants to compare those two strings lexicographically. The letters' case does not matter, that is an uppercase letter is considered equivalent to the corresponding lowercase letter. Help Petya perform the comparison.",
    "input": "Each of the first two lines contains a bought string. The strings' lengths range from 1 to 100 inclusive. It is guaranteed that the strings are of the same length and also consist of uppercase and lowercase Latin letters.",
    "output": "If the first string is less than the second one, print \" - 1\" . If the second string is less than the first one, print \" 1\" . If the strings are equal, print \" 0\" . Note that the letters' case is not taken into consideration when the strings are compared.",
    "note": "If you want more formal information about the lexicographical order ( also known as the \" dictionary order\" or \" alphabetical order\" ) , you can visit the following site: http: / / en. wikipedia. org/ wiki/ Lexicographical_ order",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Lucky String",
    "url": "https://codeforces.com/problemset/problem/110/B",
    "history": "Petya loves lucky numbers. We all know that lucky numbers are the positive integers whose decimal representations contain only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not. Petya recently learned to determine whether a string of lowercase Latin letters is lucky. For each individual letter all its positions in the string are written out in the increasing order. This results in 26 lists of numbers; some of them can be empty. A string is considered lucky if and only if in each list the absolute difference of any two adjacent numbers is a lucky number. For example, let' s consider string \" zbcdzefdzc\" . The lists of positions of equal letters are: b: 2 c: 3, 10 d: 4, 8 e: 6 f: 7 z: 1, 5, 9 Lists of positions of letters a, g, h, . . . , y are empty. This string is lucky as all differences are lucky numbers. For letters z: 5 - 1 = 4, 9 - 5 = 4, for letters c: 10 - 3 = 7, for letters d: 8 - 4 = 4. Note that if some letter occurs only once in a string, it doesn' t influence the string' s luckiness after building the lists of positions of equal letters. The string where all the letters are distinct is considered lucky. Find the lexicographically minimal lucky string whose length equals n.",
    "input": "The single line contains a positive integer n ( 1 \u2264 n \u2264 105) \u2014 the length of the sought string.",
    "output": "Print on the single line the lexicographically minimal lucky string whose length equals n.",
    "note": "The lexical comparison of strings is performed by the < operator in modern programming languages. String a is lexicographically less than string b if exists such i ( 1 \u2264 i \u2264 n) , that ai < bi, and for any j ( 1 \u2264 j < i) aj = bj.",
    "topics": [
      "constructive algorithms",
      "strings"
    ]
  },
  {
    "title": "Palindromic Times",
    "url": "https://codeforces.com/problemset/problem/108/A",
    "history": "Tattah is asleep if and only if Tattah is attending a lecture. This is a well- known formula among Tattah' s colleagues. On a Wednesday afternoon, Tattah was attending Professor HH' s lecture. At 12: 21, right before falling asleep, he was staring at the digital watch around Saher' s wrist. He noticed that the digits on the clock were the same when read from both directions i. e. a palindrome. In his sleep, he started dreaming about such rare moments of the day when the time displayed on a digital clock is a palindrome. As soon as he woke up, he felt destined to write a program that finds the next such moment. However, he still hasn' t mastered the skill of programming while sleeping, so your task is to help him.",
    "input": "The first and only line of the input starts with a string with the format \" HH: MM\" where \" HH\" is from \" 00\" to \" 23\" and \" MM\" is from \" 00\" to \" 59\" . Both \" HH\" and \" MM\" have exactly two digits.",
    "output": "Print the palindromic time of day that comes soonest after the time given in the input. If the input time is palindromic, output the soonest palindromic time after the input time.",
    "note": "",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "World of Mouth",
    "url": "https://codeforces.com/problemset/problem/100/D",
    "history": "There are a lot of rumors in the media these days. One day Aida decided to find out how rumors are made. She asked n of her friends to help her. They all formed a circle and Aida told the person to her right a piece of news which was just a simple string. Then each person told the string to the person on his/ her right. But they didn' t tell the string exactly as they' d heard it. Each person made at most one of these two types of changes: Removing one character from the end of the heard string. Adding a character to the end of the heard string. Finally when the rumor passed exactly n moves ( a complete cycle) , Aida heard something quite different from what she expected from the person on her left. She thinks someone has cheated and made some changes other than those explained above. Now she wants you to write a Pike piece of code which gets the initial and final strings and tells Aida whether it' s possible to get to the final string from the initial one, by the rules described above.",
    "input": "The first line contains a single integer n ( 2 \u2264 n \u2264 8 \u00d7 106) , the number of Aida' s friends. The following two lines contain a non- empty string each \u2014 initial and final strings. The lengths of strings are at most 107 and they only contain English alphabet letters.",
    "output": "Write a single YES or NO. Write YES only if it' s possible to get to the final string from the initial string.",
    "note": "The input is case- sensitive, while the output is not.",
    "topics": [
      "*special",
      "strings"
    ]
  },
  {
    "title": "Help Far Away Kingdom",
    "url": "https://codeforces.com/problemset/problem/99/A",
    "history": "In a far away kingdom lived the King, the Prince, the Shoemaker, the Dressmaker and many other citizens. They lived happily until great trouble came into the Kingdom. The ACMers settled there. Most damage those strange creatures inflicted upon the kingdom was that they loved high precision numbers. As a result, the Kingdom healers had already had three appointments with the merchants who were asked to sell, say, exactly 0. 273549107 beer barrels. To deal with the problem somehow, the King issued an order obliging rounding up all numbers to the closest integer to simplify calculations. Specifically, the order went like this: If a number' s integer part does not end with digit 9 and its fractional part is strictly less than 0. 5, then the rounded up number coincides with the number\u2019s integer part. If a number' s integer part does not end with digit 9 and its fractional part is not less than 0. 5, the rounded up number is obtained if we add 1 to the last digit of the number\u2019s integer part. If the number\u2019s integer part ends with digit 9, to round up the numbers one should go to Vasilisa the Wise. In the whole Kingdom she is the only one who can perform the tricky operation of carrying into the next position. Merchants found the algorithm very sophisticated and they asked you ( the ACMers) to help them. Can you write a program that would perform the rounding according to the King\u2019s order?",
    "input": "The first line contains a single number to round up \u2014 the integer part ( a non- empty set of decimal digits that do not start with 0 \u2014 with the exception of a case when the set consists of a single digit \u2014 in this case 0 can go first) , then follows character \u00ab. \u00bb ( a dot) , and then follows the fractional part ( any non- empty set of decimal digits) . The number' s length does not exceed 1000 characters, including the dot. There are no other characters in the input data.",
    "output": "If the last number of the integer part is not equal to 9, print the rounded- up number without leading zeroes. Otherwise, print the message \" GOTO Vasilisa. \" ( without the quotes) .",
    "note": "",
    "topics": [
      "strings"
    ]
  },
  {
    "title": "Football",
    "url": "https://codeforces.com/problemset/problem/96/A",
    "history": "Petya loves football very much. One day, as he was watching a football match, he was writing the players' current positions on a piece of paper. To simplify the situation he depicted it as a string consisting of zeroes and ones. A zero corresponds to players of one team; a one corresponds to players of another team. If there are at least 7 players of some team standing one after another, then the situation is considered dangerous. For example, the situation 00100110111111101 is dangerous and 11110111011101 is not. You are given the current situation. Determine whether it is dangerous or not.",
    "input": "The first input line contains a non- empty string consisting of characters \" 0\" and \" 1\" , which represents players. The length of the string does not exceed 100 characters. There' s at least one player from each team present on the field.",
    "output": "Print \" YES\" if the situation is dangerous. Otherwise, print \" NO\" .",
    "note": "",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Hockey",
    "url": "https://codeforces.com/problemset/problem/95/A",
    "history": "Petya loves hockey very much. One day, as he was watching a hockey match, he fell asleep. Petya dreamt of being appointed to change a hockey team' s name. Thus, Petya was given the original team name w and the collection of forbidden substrings s1, s2, . . . , sn. All those strings consist of uppercase and lowercase Latin letters. String w has the length of | w| , its characters are numbered from 1 to | w| . First Petya should find all the occurrences of forbidden substrings in the w string. During the search of substrings the case of letter shouldn' t be taken into consideration. That is, strings \" aBC\" and \" ABc\" are considered equal. After that Petya should perform the replacement of all letters covered by the occurrences. More formally: a letter in the position i should be replaced by any other one if for position i in string w there exist pair of indices l, r ( 1 \u2264 l \u2264 i \u2264 r \u2264 | w| ) such that substring w[ l . . . r] is contained in the collection s1, s2, . . . , sn, when using case insensitive comparison. During the replacement the letter' s case should remain the same. Petya is not allowed to replace the letters that aren' t covered by any forbidden substring. Letter letter ( uppercase or lowercase) is considered lucky for the hockey players. That' s why Petya should perform the changes so that the letter occurred in the resulting string as many times as possible. Help Petya to find such resulting string. If there are several such strings, find the one that comes first lexicographically. Note that the process of replacements is not repeated, it occurs only once. That is, if after Petya' s replacements the string started to contain new occurrences of bad substrings, Petya pays no attention to them.",
    "input": "The first line contains the only integer n ( 1 \u2264 n \u2264 100) \u2014 the number of forbidden substrings in the collection. Next n lines contain these substrings. The next line contains string w. All those n + 1 lines are non- empty strings consisting of uppercase and lowercase Latin letters whose length does not exceed 100. The last line contains a lowercase letter letter.",
    "output": "Output the only line \u2014 Petya' s resulting string with the maximum number of letters letter. If there are several answers then output the one that comes first lexicographically. The lexicographical comparison is performed by the standard < operator in modern programming languages. The line a is lexicographically smaller than the line b, if a is a prefix of b, or there exists such an i ( 1 \u2264 i \u2264 | a| ) , that ai < bi, and for any j ( 1 \u2264 j < i) aj = bj. | a| stands for the length of string a.",
    "note": "",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Restoring Password",
    "url": "https://codeforces.com/problemset/problem/94/A",
    "history": "Igor K. always used to trust his favorite Kashpirovsky Antivirus. That is why he didn' t hesitate to download the link one of his groupmates sent him via QIP Infinium. The link was said to contain \" some real funny stuff about swine influenza\" . The antivirus had no objections and Igor K. run the flash application he had downloaded. Immediately his QIP Infinium said: \" invalid login/ password\" . Igor K. entered the ISQ from his additional account and looked at the info of his main one. His name and surname changed to \" H1N1\" and \" Infected\" correspondingly, and the \" Additional Information\" field contained a strange- looking binary code 80 characters in length, consisting of zeroes and ones. \" I' ve been hacked\" \u2014 thought Igor K. and run the Internet Exploiter browser to quickly type his favourite search engine' s address. Soon he learned that it really was a virus that changed ISQ users' passwords. Fortunately, he soon found out that the binary code was actually the encrypted password where each group of 10 characters stood for one decimal digit. Accordingly, the original password consisted of 8 decimal digits. Help Igor K. restore his ISQ account by the encrypted password and encryption specification.",
    "input": "The input data contains 11 lines. The first line represents the binary code 80 characters in length. That is the code written in Igor K. ' s ISQ account' s info. Next 10 lines contain pairwise distinct binary codes 10 characters in length, corresponding to numbers 0, 1, . . . , 9.",
    "output": "Print one line containing 8 characters \u2014 The password to Igor K. ' s ISQ account. It is guaranteed that the solution exists.",
    "note": "",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Newspaper Headline",
    "url": "https://codeforces.com/problemset/problem/91/A",
    "history": "A newspaper is published in Walrusland. Its heading is s1, it consists of lowercase Latin letters. Fangy the little walrus wants to buy several such newspapers, cut out their headings, glue them one to another in order to get one big string. After that walrus erase several letters from this string in order to get a new word s2. It is considered that when Fangy erases some letter, there' s no whitespace formed instead of the letter. That is, the string remains unbroken and it still only consists of lowercase Latin letters. For example, the heading is \" abc\" . If we take two such headings and glue them one to the other one, we get \" abcabc\" . If we erase the letters on positions 1 and 5, we get a word \" bcac\" . Which least number of newspaper headings s1 will Fangy need to glue them, erase several letters and get word s2?",
    "input": "The input data contain two lines. The first line contain the heading s1, the second line contains the word s2. The lines only consist of lowercase Latin letters ( 1 \u2264 | s1| \u2264 104, 1 \u2264 | s2| \u2264 106) .",
    "output": "If it is impossible to get the word s2 in the above- described manner, print \" - 1\" ( without the quotes) . Otherwise, print the least number of newspaper headings s1, which Fangy will need to receive the word s2.",
    "note": "",
    "topics": [
      "greedy",
      "strings"
    ]
  },
  {
    "title": "African Crossword",
    "url": "https://codeforces.com/problemset/problem/90/B",
    "history": "An African crossword is a rectangular table n \u00d7 m in size. Each cell of the table contains exactly one letter. This table ( it is also referred to as grid) contains some encrypted word that needs to be decoded. To solve the crossword you should cross out all repeated letters in rows and columns. In other words, a letter should only be crossed out if and only if the corresponding column or row contains at least one more letter that is exactly the same. Besides, all such letters are crossed out simultaneously. When all repeated letters have been crossed out, we should write the remaining letters in a string. The letters that occupy a higher position follow before the letters that occupy a lower position. If the letters are located in one row, then the letter to the left goes first. The resulting word is the answer to the problem. You are suggested to solve an African crossword and print the word encrypted there.",
    "input": "The first line contains two integers n and m ( 1 \u2264 n, m \u2264 100) . Next n lines contain m lowercase Latin letters each. That is the crossword grid.",
    "output": "Print the encrypted word on a single line. It is guaranteed that the answer consists of at least one letter.",
    "note": "",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Vasya and Types",
    "url": "https://codeforces.com/problemset/problem/87/B",
    "history": "Programmer Vasya is studying a new programming language K* . The K* language resembles the languages of the C family in its syntax. However, it is more powerful, which is why the rules of the actual C- like languages are unapplicable to it. To fully understand the statement, please read the language' s description below carefully and follow it and not the similar rules in real programming languages. There is a very powerful system of pointers on K* \u2014 you can add an asterisk to the right of the existing type X \u2014 that will result in new type X * . That is called pointer- definition operation. Also, there is the operation that does the opposite \u2014 to any type of X, which is a pointer, you can add an ampersand \u2014 that will result in a type X, to which refers X. That is called a dereference operation. The K* language has only two basic data types \u2014 void and errtype. Also, the language has operators typedef and typeof. The operator \" typedef A B\" defines a new data type B, which is equivalent to A. A can have asterisks and ampersands, and B cannot have them. For example, the operator typedef void* * ptptvoid will create a new type ptptvoid, that can be used as void* * . The operator \" typeof A\" returns type of A, brought to void, that is, returns the type void* * . . . * , equivalent to it with the necessary number of asterisks ( the number can possibly be zero) . That is, having defined the ptptvoid type, as shown above, the typeof ptptvoid operator will return void* * . An attempt of dereferencing of the void type will lead to an error: to a special data type errtype. For errtype the following equation holds true: errtype* = errtype = errtype. An attempt to use the data type that hasn' t been defined before that will also lead to the errtype. Using typedef, we can define one type several times. Of all the definitions only the last one is valid. However, all the types that have been defined earlier using this type do not change. Let us also note that the dereference operation has the lower priority that the pointer operation, in other words T * is always equal to T. Note, that the operators are executed consecutively one by one. If we have two operators \" typedef void a\" and \" typedef a* b\" , then at first a becomes errtype, and after that b becomes errtype* = errtype, but not void* = void ( see sample 2) . Vasya does not yet fully understand this powerful technology, that' s why he asked you to help him. Write a program that analyzes these operators.",
    "input": "The first line contains an integer n ( 1 \u2264 n \u2264 100) \u2014 the number of operators. Then follow n lines with operators. Each operator is of one of two types: either \" typedef A B\" , or \" typeof A\" . In the first case the B type differs from void and errtype types, and besides, doesn' t have any asterisks and ampersands. All the data type names are non- empty lines of no more than 20 lowercase Latin letters. The number of asterisks and ampersands separately in one type in any operator does not exceed 10, however if we bring some types to void with several asterisks, their number may exceed 10.",
    "output": "For every typeof operator print on the single line the answer to that operator \u2014 the type that the given operator returned.",
    "note": "Let' s look at the second sample. After the first two queries typedef the b type is equivalent to void* , and \u0441 \u2014 to void* * . The next query typedef redefines b \u2014 it is now equal to b = void* = void. At that, the \u0441 type doesn' t change. After that the \u0441 type is defined as b* = void* = void = errtype. It doesn' t influence the b type, that' s why the next typedef defines c as void* = void. Then the b type is again redefined as void = errtype. Please note that the c type in the next query is defined exactly as errtype* * * * * * * = errtype, and not void* * * * * * * = void* * * * * * . The same happens in the last typedef.",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Sequence Formatting",
    "url": "https://codeforces.com/problemset/problem/81/B",
    "history": "Polycarp is very careful. He even types numeric sequences carefully, unlike his classmates. If he sees a sequence without a space after the comma, with two spaces in a row, or when something else does not look neat, he rushes to correct it. For example, number sequence written like \" 1, 2 , 3, . . . , 10\" will be corrected to \" 1, 2, 3, . . . , 10\" . In this task you are given a string s, which is composed by a concatination of terms, each of which may be: a positive integer of an arbitrary length ( leading zeroes are not allowed) , a \" comma\" symbol ( \" , \" ) , a \" space\" symbol ( \" \" ) , \" three dots\" ( \" . . . \" , that is, exactly three points written one after another, also known as suspension points) . Polycarp wants to add and remove spaces in the string s to ensure the following: each comma is followed by exactly one space ( if the comma is the last character in the string, this rule does not apply to it) , each \" three dots\" term is preceded by exactly one space ( if the dots are at the beginning of the string, this rule does not apply to the term) , if two consecutive numbers were separated by spaces only ( one or more) , then exactly one of them should be left, there should not be other spaces. Automate Polycarp' s work and write a program that will process the given string s.",
    "input": "The input data contains a single string s. Its length is from 1 to 255 characters. The string s does not begin and end with a space. Its content matches the description given above.",
    "output": "Print the string s after it is processed. Your program' s output should be exactly the same as the expected answer. It is permissible to end output line with a line- break character, and without it.",
    "note": "",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Beaver",
    "url": "https://codeforces.com/problemset/problem/79/C",
    "history": "After Fox Ciel got off a bus, she found that the bus she was on was a wrong bus and she lost her way in a strange town. However, she fortunately met her friend Beaver Taro and asked which way to go to her castle. Taro' s response to her was a string s, and she tried to remember the string s correctly. However, Ciel feels n strings b1, b2, . . . , bn are really boring, and unfortunately she dislikes to remember a string that contains a boring substring. To make the thing worse, what she can remember is only the contiguous substring of s. Determine the longest contiguous substring of s that does not contain any boring string, so that she can remember the longest part of Taro' s response.",
    "input": "In the first line there is a string s. The length of s will be between 1 and 105, inclusive. In the second line there is a single integer n ( 1 \u2264 n \u2264 10) . Next n lines, there is a string bi ( 1 \u2264 i \u2264 n) . Each length of bi will be between 1 and 10, inclusive. Each character of the given strings will be either a English alphabet ( both lowercase and uppercase) or a underscore ( ' _ ' ) or a digit. Assume that these strings are case- sensitive.",
    "output": "Output in the first line two space- separated integers len and pos: the length of the longest contiguous substring of s that does not contain any bi, and the first position of the substring ( 0- indexed) . The position pos must be between 0 and | s| - len inclusive, where | s| is the length of string s. If there are several solutions, output any.",
    "note": "In the first sample, the solution is traight_ alon. In the second sample, the solution is an empty string, so the output can be \u00ab0 0\u00bb, \u00ab0 1\u00bb, \u00ab0 2\u00bb, and so on. In the third sample, the solution is either nagio or oisii.",
    "topics": [
      "data structures",
      "dp",
      "greedy",
      "hashing",
      "strings",
      "two pointers"
    ]
  },
  {
    "title": "Haiku",
    "url": "https://codeforces.com/problemset/problem/78/A",
    "history": "Haiku is a genre of Japanese traditional poetry. A haiku poem consists of 17 syllables split into three phrases, containing 5, 7 and 5 syllables correspondingly ( the first phrase should contain exactly 5 syllables, the second phrase should contain exactly 7 syllables, and the third phrase should contain exactly 5 syllables) . A haiku masterpiece contains a description of a moment in those three phrases. Every word is important in a small poem, which is why haiku are rich with symbols. Each word has a special meaning, a special role. The main principle of haiku is to say much using a few words. To simplify the matter, in the given problem we will consider that the number of syllable in the phrase is equal to the number of vowel letters there. Only the following letters are regarded as vowel letters: \" a\" , \" e\" , \" i\" , \" o\" and \" u\" . Three phases from a certain poem are given. Determine whether it is haiku or not.",
    "input": "The input data consists of three lines. The length of each line is between 1 and 100, inclusive. The i- th line contains the i- th phrase of the poem. Each phrase consists of one or more words, which are separated by one or more spaces. A word is a non- empty sequence of lowercase Latin letters. Leading and/ or trailing spaces in phrases are allowed. Every phrase has at least one non- space character. See the example for clarification.",
    "output": "Print \" YES\" ( without the quotes) if the poem is a haiku. Otherwise, print \" NO\" ( also without the quotes) .",
    "note": "",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Facetook Priority Wall",
    "url": "https://codeforces.com/problemset/problem/75/B",
    "history": "Facetook is a well known social network website, and it will launch a new feature called Facetook Priority Wall. This feature will sort all posts from your friends according to the priority factor ( it will be described) . This priority factor will be affected by three types of actions: 1. \" X posted on Y' s wall\" ( 15 points) , 2. \" X commented on Y' s post\" ( 10 points) , 3. \" X likes Y' s post\" ( 5 points) . X and Y will be two distinct names. And each action will increase the priority factor between X and Y ( and vice versa) by the above value of points ( the priority factor between X and Y is the same as the priority factor between Y and X) . You will be given n actions with the above format ( without the action number and the number of points) , and you have to print all the distinct names in these actions sorted according to the priority factor with you.",
    "input": "The first line contains your name. The second line contains an integer n, which is the number of actions ( 1 \u2264 n \u2264 100) . Then n lines follow, it is guaranteed that each one contains exactly 1 action in the format given above. There is exactly one space between each two words in a line, and there are no extra spaces. All the letters are lowercase. All names in the input will consist of at least 1 letter and at most 10 small Latin letters.",
    "output": "Print m lines, where m is the number of distinct names in the input ( excluding yourself) . Each line should contain just 1 name. The names should be sorted according to the priority factor with you in the descending order ( the highest priority factor should come first) . If two or more names have the same priority factor, print them in the alphabetical ( lexicographical) order. Note, that you should output all the names that are present in the input data ( excluding yourself) , even if that person has a zero priority factor. The lexicographical comparison is performed by the standard \" < \" operator in modern programming languages. The line a is lexicographically smaller than the line b, if either a is the prefix of b, or if exists such an i ( 1 \u2264 i \u2264 min( | a| , | b| ) ) , that ai < bi, and for any j ( 1 \u2264 j < i) aj = bj, where | a| and | b| stand for the lengths of strings a and b correspondently.",
    "note": "",
    "topics": [
      "expression parsing",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Ali goes shopping",
    "url": "https://codeforces.com/problemset/problem/72/E",
    "history": "Ali Koochooloo is going to buy new clothes since we' re reaching Noruz, the ancient Persian festival and the beginning of new Persian year. When Ali entered a shop, he saw that the shopkeeper was a programmer and since there is no money in programming he had changed his career. The shopkeeper told Ali that he can buy anything for free if he could answer a simple question in 10 seconds. But to see the question Ali has to pay 3 tomans. Ali agreed instantly and the shopkeeper handed him a piece of paper containing the task. The task was indeed very simple. It said: Let string A be ababababababab. Which non- empty substring of A is repeated the most times in it? Ali answered fast. He said the answer is a. But the shopkeeper said that Ali is wrong and asked him to read the rest of statement: If several substrings have the maximal repeat time, then the substring with maximal length would be the answer, in case of a tie the alphabetically latest substring will be chosen. So the answer is ab. Now Ali wants us to solve this problem for different strings. We don' t have a great advantage over Ali, we just have a computer and a weird language.",
    "input": "The single line consisting of a string A. It is non- empty, made of lower- case Latin letters and contains at most 30 characters.",
    "output": "The single line contains the answer.",
    "note": "",
    "topics": [
      "*special",
      "brute force",
      "strings"
    ]
  },
  {
    "title": "Way Too Long Words",
    "url": "https://codeforces.com/problemset/problem/71/A",
    "history": "Sometimes some words like \" localization\" or \" internationalization\" are so long that writing them many times in one text is quite tiresome. Let' s consider a word too long, if its length is strictly more than 10 characters. All too long words should be replaced with a special abbreviation. This abbreviation is made like this: we write down the first and the last letter of a word and between them we write the number of letters between the first and the last letters. That number is in decimal system and doesn' t contain any leading zeroes. Thus, \" localization\" will be spelt as \" l10n\" , and \" internationalization\u00bb will be spelt as \" i18n\" . You are suggested to automatize the process of changing the words with abbreviations. At that all too long words should be replaced by the abbreviation and the words that are not too long should not undergo any changes.",
    "input": "The first line contains an integer n ( 1 \u2264 n \u2264 100) . Each of the following n lines contains one word. All the words consist of lowercase Latin letters and possess the lengths of from 1 to 100 characters.",
    "output": "Print n lines. The i- th line should contain the result of replacing of the i- th word from the input data.",
    "note": "",
    "topics": [
      "strings"
    ]
  },
  {
    "title": "Text Messaging",
    "url": "https://codeforces.com/problemset/problem/70/B",
    "history": "Fangy the little walrus, as all the modern walruses, loves to communicate via text messaging. One day he faced the following problem: When he sends large texts, they are split into parts each containing n characters ( which is the size of one text message) . Thus, whole sentences and words get split! Fangy did not like it, so he faced the task of breaking the text into minimal messages on his own so that no sentence were broken into pieces when it is sent and the number of text messages to be sent would be minimal. If two consecutive sentences are in different messages, the space between them can be ignored ( Fangy does not write this space) . The little walrus' s text looks in the following manner: TEXT : : = SENTENCE | SENTENCE SPACE TEXTSENTENCE : : = WORD SPACE SENTENCE | WORD ENDEND : : = ' . ' , ' ? ' , ' ! ' WORD : : = LETTER | LETTER WORDLETTER : : = ' a' . . ' z' , ' A' . . ' Z' SPACE : : = ' ' SPACE stands for the symbol of a space. So, how many messages did Fangy send?",
    "input": "The first line contains an integer n, which is the size of one message ( 2 \u2264 n \u2264 255) . The second line contains the text. The length of the text does not exceed 104 characters. It is guaranteed that the text satisfies the above described format. Specifically, this implies that the text is not empty.",
    "output": "On the first and only line print the number of text messages Fangy will need. If it is impossible to split the text, print \" Impossible\" without the quotes.",
    "note": "Let' s take a look at the third sample. The text will be split into three messages: \" Hello! \" , \" Do you like fish? \" and \" Why? \" .",
    "topics": [
      "expression parsing",
      "greedy",
      "strings"
    ]
  },
  {
    "title": "Petya and Java",
    "url": "https://codeforces.com/problemset/problem/66/A",
    "history": "Little Petya has recently started attending a programming club. Naturally he is facing the problem of choosing a programming language. After long considerations he realized that Java is the best choice. The main argument in favor of choosing Java was that it has a very large integer data type, called BigInteger. But having attended several classes of the club, Petya realized that not all tasks require using the BigInteger type. It turned out that in some tasks it is much easier to use small data types. That' s why a question arises: \" Which integer type to use if one wants to store a positive integer n? \" Petya knows only 5 integer types: 1) byte occupies 1 byte and allows you to store numbers from - 128 to 1272) short occupies 2 bytes and allows you to store numbers from - 32768 to 327673) int occupies 4 bytes and allows you to store numbers from - 2147483648 to 21474836474) long occupies 8 bytes and allows you to store numbers from - 9223372036854775808 to 92233720368547758075) BigInteger can store any integer number, but at that it is not a primitive type, and operations with it are much slower. For all the types given above the boundary values are included in the value range. From this list, Petya wants to choose the smallest type that can store a positive integer n. Since BigInteger works much slower, Peter regards it last. Help him.",
    "input": "The first line contains a positive number n. It consists of no more than 100 digits and doesn' t contain any leading zeros. The number n can' t be represented as an empty string. Please, do not use",
    "output": "Print the first type from the list \" byte, short, int, long, BigInteger\" , that can store the natural number n, in accordance with the data given above.",
    "note": "",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Sinking Ship",
    "url": "https://codeforces.com/problemset/problem/63/A",
    "history": "The ship crashed into a reef and is sinking. Now the entire crew must be evacuated. All n crew members have already lined up in a row ( for convenience let' s label them all from left to right with positive integers from 1 to n) and await further instructions. However, one should evacuate the crew properly, in a strict order. Specifically: The first crew members to leave the ship are rats. Then women and children ( both groups have the same priority) leave the ship. After that all men are evacuated from the ship. The captain leaves the sinking ship last. If we cannot determine exactly who should leave the ship first for any two members of the crew by the rules from the previous paragraph, then the one who stands to the left in the line leaves the ship first ( or in other words, the one whose number in the line is less) . For each crew member we know his status as a crew member, and also his name. All crew members have different names. Determine the order in which to evacuate the crew.",
    "input": "The first line contains an integer n, which is the number of people in the crew ( 1 \u2264 n \u2264 100) . Then follow n lines. The i- th of those lines contains two words \u2014 the name of the crew member who is i- th in line, and his status on the ship. The words are separated by exactly one space. There are no other spaces in the line. The names consist of Latin letters, the first letter is uppercase, the rest are lowercase. The length of any name is from 1 to 10 characters. The status can have the following values: rat for a rat, woman for a woman, child for a child, man for a man, captain for the captain. The crew contains exactly one captain.",
    "output": "Print n lines. The i- th of them should contain the name of the crew member who must be the i- th one to leave the ship.",
    "note": "",
    "topics": [
      "implementation",
      "sortings",
      "strings"
    ]
  },
  {
    "title": "Hard Work",
    "url": "https://codeforces.com/problemset/problem/61/B",
    "history": "After the contest in comparing numbers, Shapur' s teacher found out that he is a real genius and that no one could possibly do the calculations faster than him even using a super computer! Some days before the contest, the teacher took a very simple- looking exam and all his n students took part in the exam. The teacher gave them 3 strings and asked them to concatenate them. Concatenating strings means to put them in some arbitrary order one after the other. For example from concatenating Alireza and Amir we can get to AlirezaAmir or AmirAlireza depending on the order of concatenation. Unfortunately enough, the teacher forgot to ask students to concatenate their strings in a pre- defined order so each student did it the way he/ she liked. Now the teacher knows that Shapur is such a fast- calculating genius boy and asks him to correct the students' papers. Shapur is not good at doing such a time- taking task. He rather likes to finish up with it as soon as possible and take his time to solve 3- SAT in polynomial time. Moreover, the teacher has given some advice that Shapur has to follow. Here' s what the teacher said: As I expect you know, the strings I gave to my students ( including you) contained only lowercase and uppercase Persian Mikhi- Script letters. These letters are too much like Latin letters, so to make your task much harder I converted all the initial strings and all of the students' answers to Latin. As latin alphabet has much less characters than Mikhi- Script, I added three odd- looking characters to the answers, these include \" - \" , \" ; \" and \" _ \" . These characters are my own invention of course! And I call them Signs. The length of all initial strings was less than or equal to 100 and the lengths of my students' answers are less than or equal to 600 My son, not all students are genius as you are. It is quite possible that they make minor mistakes changing case of some characters. For example they may write ALiReZaAmIR instead of AlirezaAmir. Don' t be picky and ignore these mistakes. Those signs which I previously talked to you about are not important. You can ignore them, since many students are in the mood for adding extra signs or forgetting about a sign. So something like Iran; ; \u2013 is the same as \u2013; IRAN You should indicate for any of my students if his answer was right or wrong. Do this by writing \" WA\" for Wrong answer or \" ACC\" for a correct answer. I should remind you that none of the strings ( initial strings or answers) are empty. Finally, do these as soon as possible. You have less than 2 hours to complete this.",
    "input": "The first three lines contain a string each. These are the initial strings. They consists only of lowercase and uppercase Latin letters and signs ( \" - \" , \" ; \" and \" _ \" ) . All the initial strings have length from 1 to 100, inclusively. In the fourth line there is a single integer n ( 0 \u2264 n \u2264 1000) , the number of students. Next n lines contain a student' s answer each. It is guaranteed that the answer meets what the teacher said. Each answer iconsists only of lowercase and uppercase Latin letters and signs ( \" - \" , \" ; \" and \" _ \" ) . Length is from 1 to 600, inclusively.",
    "output": "For each student write in a different line. Print \" WA\" if his answer is wrong or \" ACC\" if his answer is OK.",
    "note": "",
    "topics": [
      "strings"
    ]
  },
  {
    "title": "Word",
    "url": "https://codeforces.com/problemset/problem/59/A",
    "history": "Vasya is very upset that many people on the Net mix uppercase and lowercase letters in one word. That' s why he decided to invent an extension for his favorite browser that would change the letters' register in every word so that it either only consisted of lowercase letters or, vice versa, only of uppercase ones. At that as little as possible letters should be changed in the word. For example, the word HoUse must be replaced with house, and the word ViP \u2014 with VIP. If a word contains an equal number of uppercase and lowercase letters, you should replace all the letters with lowercase ones. For example, maTRIx should be replaced by matrix. Your task is to use the given method on one given word.",
    "input": "The first line contains a word s \u2014 it consists of uppercase and lowercase Latin letters and possesses the length from 1 to 100.",
    "output": "Print the corrected word s. If the given word s has strictly more uppercase letters, make the word written in the uppercase register, otherwise - in the lowercase one.",
    "note": "",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Calendar",
    "url": "https://codeforces.com/problemset/problem/58/D",
    "history": "BerOilGasDiamondBank has branches in n cities, at that n is an even number. The bank management wants to publish a calendar with the names of all those cities written in two columns: the calendar should consist of exactly n / 2 lines of strictly equal length, each of which contains exactly two names and exactly one separator character between them. The name of every city should be used in the calendar exactly once. For historical reasons the symbol d is used as the separator of words in the calendar. The BerOilGasDiamondBank management wants to show that all its branches are equally important to it, that' s why the order of their appearance in the calendar should be following: if we \" glue\" ( concatinate) all the n / 2 calendar lines ( from top to bottom) to make a single line, then the lexicographically minimal line is obtained. No separator character will be used to separate calendar lines. For example, if the lines are \" bertown! berville\" , \" newberville! bera\" , then the resulting line is \" bertown! bervillenewberville! bera\" . In some sense one has to find the lexicographically minimal calendar, where the comparison of calendars happens line by line. Help BerOilGasDiamondBank and construct the required calendar.",
    "input": "The first line contains an integer n ( 1 \u2264 n \u2264 104, n is even) which is the number of branches. Then follow n lines which are the names of the cities. All the names consist of lowercase Latin letters; their lengths are no less than 1 and no more than 10 symbols. The next line contains a single symbol d ( d has an ASCII- code from 33 to 126 inclusively, excluding lowercase Latin letters) which is the separator between words in the calendar lines. It is guaranteed that the calendar is possible to be constructed and all the names are different.",
    "output": "Print n / 2 lines of similar length which are the required calendar. Every line should contain exactly two words and exactly one separator between them. If there are several solutions, print the lexicographically minimal one. The lexicographical comparison of lines is realized by the \" < \" operator in the modern programming languages.",
    "note": "",
    "topics": [
      "greedy",
      "strings"
    ]
  },
  {
    "title": "Chat room",
    "url": "https://codeforces.com/problemset/problem/58/A",
    "history": "Vasya has recently learned to type and log on to the Internet. He immediately entered a chat room and decided to say hello to everybody. Vasya typed the word s. It is considered that Vasya managed to say hello if several letters can be deleted from the typed word so that it resulted in the word \" hello\" . For example, if Vasya types the word \" ahhellllloou\" , it will be considered that he said hello, and if he types \" hlelo\" , it will be considered that Vasya got misunderstood and he didn' t manage to say hello. Determine whether Vasya managed to say hello by the given word s.",
    "input": "The first and only line contains the word s, which Vasya typed. This word consisits of small Latin letters, its length is no less that 1 and no more than 100 letters.",
    "output": "If Vasya managed to say hello, print \" YES\" , otherwise print \" NO\" .",
    "note": "",
    "topics": [
      "greedy",
      "strings"
    ]
  },
  {
    "title": "Writing a Song",
    "url": "https://codeforces.com/problemset/problem/54/D",
    "history": "One of the Hedgehog and his friend' s favorite entertainments is to take some sentence or a song and replace half of the words ( sometimes even all of them) with each other' s names. The friend' s birthday is approaching and the Hedgehog decided to make a special present to his friend: a very long song, where his name will be repeated many times. But try as he might, he can' t write a decent song! The problem is that the Hedgehog has already decided how long the resulting sentence should be ( i. e. how many letters it should contain) and in which positions in the sentence the friend' s name should occur, and it must not occur in any other position in the sentence. Besides, the Hedgehog decided to limit himself to using only the first K letters of an English alphabet in this sentence ( so it will be not even a sentence, but one long word) . The resulting problem is indeed quite complicated, that' s why the Hedgehog asks you to help him and write a program that will make the desired word by the given name P, the length N of the required word, the given positions of the occurrences of the name P in the desired word and the alphabet' s size K. Note that the occurrences of the name can overlap with each other.",
    "input": "The first line contains numbers N and K which are the length of the required string and the alphabet size accordingly. The limitations are: 1 \u2264 N \u2264 100, 2 \u2264 K \u2264 26. The second line contains the name P which is a non- empty string whose length does not exceed N characters. The string consists only of the first K lowercase symbols of an English alphabet. The third line contains the string of length N - length( P) + 1, consisting only of numbers zero and one. A number one in the i- th position means that an occurrence of the name P should start from i- th position of the desired word, while a zero means that there is no occurrence starting here.",
    "output": "Print the desired word S. If there are several answers, print any of them. If there is no solution, then print \" No solution\" .",
    "note": "",
    "topics": [
      "brute force",
      "dp",
      "strings"
    ]
  },
  {
    "title": "Choosing Symbol Pairs",
    "url": "https://codeforces.com/problemset/problem/50/B",
    "history": "There is a given string S consisting of N symbols. Your task is to find the number of ordered pairs of integers i and j such that1. 1 \u2264 i, j \u2264 N2. S[ i] = S[ j] , that is the i- th symbol of string S is equal to the j- th.",
    "input": "The single input line contains S, consisting of lowercase Latin letters and digits. It is guaranteed that string S in not empty and its length does not exceed 105.",
    "output": "Print a single number which represents the number of pairs i and j with the needed property. Pairs ( x, y) and ( y, x) should be considered different, i. e. the ordered pairs count.",
    "note": "",
    "topics": [
      "strings"
    ]
  },
  {
    "title": "Letter",
    "url": "https://codeforces.com/problemset/problem/43/B",
    "history": "Vasya decided to write an anonymous letter cutting the letters out of a newspaper heading. He knows heading s1 and text s2 that he wants to send. Vasya can use every single heading letter no more than once. Vasya doesn' t have to cut the spaces out of the heading \u2014 he just leaves some blank space to mark them. Help him; find out if he will manage to compose the needed text.",
    "input": "The first line contains a newspaper heading s1. The second line contains the letter text s2. s1 \u0438 s2 are non- empty lines consisting of spaces, uppercase and lowercase Latin letters, whose lengths do not exceed 200 symbols. The uppercase and lowercase letters should be differentiated. Vasya does not cut spaces out of the heading.",
    "output": "If Vasya can write the given anonymous letter, print YES, otherwise print NO",
    "note": "",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Football",
    "url": "https://codeforces.com/problemset/problem/43/A",
    "history": "One day Vasya decided to have a look at the results of Berland 1910 Football Championship\u2019s finals. Unfortunately he didn' t find the overall score of the match; however, he got hold of a profound description of the match' s process. On the whole there are n lines in that description each of which described one goal. Every goal was marked with the name of the team that had scored it. Help Vasya, learn the name of the team that won the finals. It is guaranteed that the match did not end in a tie.",
    "input": "The first line contains an integer n ( 1 \u2264 n \u2264 100) \u2014 the number of lines in the description. Then follow n lines \u2014 for each goal the names of the teams that scored it. The names are non- empty lines consisting of uppercase Latin letters whose lengths do not exceed 10 symbols. It is guaranteed that the match did not end in a tie and the description contains no more than two different teams.",
    "output": "Print the name of the winning team. We remind you that in football the team that scores more goals is considered the winner.",
    "note": "",
    "topics": [
      "strings"
    ]
  },
  {
    "title": "Translation",
    "url": "https://codeforces.com/problemset/problem/41/A",
    "history": "The translation from the Berland language into the Birland language is not an easy task. Those languages are very similar: a berlandish word differs from a birlandish word with the same meaning a little: it is spelled ( and pronounced) reversely. For example, a Berlandish word code corresponds to a Birlandish word edoc. However, it' s easy to make a mistake during the \u00abtranslation\u00bb. Vasya translated word s from Berlandish into Birlandish as t. Help him: find out if he translated the word correctly.",
    "input": "The first line contains word s, the second line contains word t. The words consist of lowercase Latin letters. The input data do not consist unnecessary spaces. The words are not empty and their lengths do not exceed 100 symbols.",
    "output": "If the word t is a word s, written reversely, print YES, otherwise print NO.",
    "note": "",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Spelling Check",
    "url": "https://codeforces.com/problemset/problem/39/J",
    "history": "Petya has noticed that when he types using a keyboard, he often presses extra buttons and adds extra letters to the words. Of course, the spell- checking system underlines the words for him and he has to click every word and choose the right variant. Petya got fed up with correcting his mistakes himself, that\u2019s why he decided to invent the function that will correct the words itself. Petya started from analyzing the case that happens to him most of the time, when all one needs is to delete one letter for the word to match a word from the dictionary. Thus, Petya faces one mini- task: he has a printed word and a word from the dictionary, and he should delete one letter from the first word to get the second one. And now the very non- trivial question that Petya faces is: which letter should he delete?",
    "input": "The input data contains two strings, consisting of lower- case Latin letters. The length of each string is from 1 to 106 symbols inclusive, the first string contains exactly 1 symbol more than the second one.",
    "output": "In the first line output the number of positions of the symbols in the first string, after the deleting of which the first string becomes identical to the second one. In the second line output space- separated positions of these symbols in increasing order. The positions are numbered starting from 1. If it is impossible to make the first string identical to the second string by deleting one symbol, output one number 0.",
    "note": "",
    "topics": [
      "hashing",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Smart Boy",
    "url": "https://codeforces.com/problemset/problem/38/F",
    "history": "Once Petya and Vasya invented a new game and called it \" Smart Boy\" . They located a certain set of words \u2014 the dictionary \u2014 for the game. It is admissible for the dictionary to contain similar words. The rules of the game are as follows: first the first player chooses any letter ( a word as long as 1) from any word from the dictionary and writes it down on a piece of paper. The second player adds some other letter to this one' s initial or final position, thus making a word as long as 2, then it' s the first player' s turn again, he adds a letter in the beginning or in the end thus making a word as long as 3 and so on. But the player mustn' t break one condition: the newly created word must be a substring of a word from a dictionary. The player who can' t add a letter to the current word without breaking the condition loses. Also if by the end of a turn a certain string s is written on paper, then the player, whose turn it just has been, gets a number of points according to the formula: where is a sequence number of symbol c in Latin alphabet, numbered starting from 1. For example, , and . is the number of words from the dictionary where the line s occurs as a substring at least once. Your task is to learn who will win the game and what the final score will be. Every player plays optimally and most of all tries to win, then \u2014 to maximize the number of his points, then \u2014 to minimize the number of the points of the opponent.",
    "input": "The first input line contains an integer n which is the number of words in the located dictionary ( 1 \u2264 n \u2264 30) . The n lines contain the words from the dictionary \u2014 one word is written on one line. Those lines are nonempty, consisting of Latin lower- case characters no longer than 30 characters. Equal words can be in the list of words.",
    "output": "On the first output line print a line \" First\" or \" Second\" which means who will win the game. On the second line output the number of points of the first player and the number of points of the second player after the game ends. Separate the numbers by a single space.",
    "note": "",
    "topics": [
      "dp",
      "games",
      "strings"
    ]
  },
  {
    "title": "Page Numbers",
    "url": "https://codeforces.com/problemset/problem/34/C",
    "history": "\u00abBersoft\u00bb company is working on a new version of its most popular text editor \u2014 Bord 2010. Bord, like many other text editors, should be able to print out multipage documents. A user keys a sequence of the document page numbers that he wants to print out ( separates them with a comma, without spaces) . Your task is to write a part of the program, responsible for \u00abstandardization\u00bb of this sequence. Your program gets the sequence, keyed by the user, as input. The program should output this sequence in format l1- r1, l2- r2, . . . , lk- rk, where ri + 1 < li + 1 for all i from 1 to k - 1, and li \u2264 ri. The new sequence should contain all the page numbers, keyed by the user, and nothing else. If some page number appears in the input sequence several times, its appearances, starting from the second one, should be ignored. If for some element i from the new sequence li = ri, this element should be output as li, and not as \u00abli - li\u00bb. For example, sequence 1, 2, 3, 1, 1, 2, 6, 6, 2 should be output as 1- 3, 6.",
    "input": "The only line contains the sequence, keyed by the user. The sequence contains at least one and at most 100 positive integer numbers. It' s guaranteed, that this sequence consists of positive integer numbers, not exceeding 1000, separated with a comma, doesn' t contain any other characters, apart from digits and commas, can' t end with a comma, and the numbers don' t contain leading zeroes. Also it doesn' t start with a comma or contain more than one comma in a row.",
    "output": "Output the sequence in the required format.",
    "note": "",
    "topics": [
      "expression parsing",
      "implementation",
      "sortings",
      "strings"
    ]
  },
  {
    "title": "Sysadmin Bob",
    "url": "https://codeforces.com/problemset/problem/31/B",
    "history": "Email address in Berland is a string of the form A@ B, where A and B are arbitrary strings consisting of small Latin letters. Bob is a system administrator in \u00abBersoft\u00bb company. He keeps a list of email addresses of the company' s staff. This list is as a large string, where all addresses are written in arbitrary order, separated by commas. The same address can be written more than once. Suddenly, because of unknown reasons, all commas in Bob' s list disappeared. Now Bob has a string, where all addresses are written one after another without any separators, and there is impossible to determine, where the boundaries between addresses are. Unfortunately, on the same day his chief asked him to bring the initial list of addresses. Now Bob wants to disjoin addresses in some valid way. Help him to do that.",
    "input": "The first line contains the list of addresses without separators. The length of this string is between 1 and 200, inclusive. The string consists only from small Latin letters and characters \u00ab@ \u00bb.",
    "output": "If there is no list of the valid ( according to the Berland rules) email addresses such that after removing all commas it coincides with the given string, output No solution. In the other case, output the list. The same address can be written in this list more than once. If there are several solutions, output any of them.",
    "note": "",
    "topics": [
      "greedy",
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Tricky and Clever Password",
    "url": "https://codeforces.com/problemset/problem/30/E",
    "history": "In his very young years the hero of our story, king Copa, decided that his private data was hidden not enough securely, what is unacceptable for the king. That' s why he invented tricky and clever password ( later he learned that his password is a palindrome of odd length) , and coded all his data using it. Copa is afraid to forget his password, so he decided to write it on a piece of paper. He is aware that it is insecure to keep password in such way, so he decided to cipher it the following way: he cut x characters from the start of his password and from the end of it ( x can be 0, and 2x is strictly less than the password length) . He obtained 3 parts of the password. Let' s call it prefix, middle and suffix correspondingly, both prefix and suffix having equal length and middle always having odd length. From these parts he made a string A + prefix + B + middle + C + suffix, where A, B and C are some ( possibly empty) strings invented by Copa, and \u00ab + \u00bb means concatenation. Many years have passed, and just yesterday the king Copa found the piece of paper where his ciphered password was written. The password, as well as the strings A, B and C, was completely forgotten by Copa, so he asks you to find a password of maximum possible length, which could be invented, ciphered and written by Copa.",
    "input": "The input contains single string of small Latin letters with length from 1 to 105 characters.",
    "output": "The first line should contain integer k \u2014 amount of nonempty parts of the password in your answer ( ) . In each of the following k lines output two integers xi and li \u2014 start and length of the corresponding part of the password. Output pairs in order of increasing xi. Separate the numbers in pairs by a single space. Starting position xi should be an integer from 1 to the length of the input string. All li must be positive, because you should output only non- empty parts. The middle part must have odd length. If there are several solutions, output any. Note that your goal is to maximize the sum of li, but not to maximize k.",
    "note": "",
    "topics": [
      "binary search",
      "constructive algorithms",
      "data structures",
      "greedy",
      "hashing",
      "strings"
    ]
  },
  {
    "title": "Test",
    "url": "https://codeforces.com/problemset/problem/25/E",
    "history": "Sometimes it is hard to prepare tests for programming problems. Now Bob is preparing tests to new problem about strings \u2014 input data to his problem is one string. Bob has 3 wrong solutions to this problem. The first gives the wrong answer if the input data contains the substring s1, the second enters an infinite loop if the input data contains the substring s2, and the third requires too much memory if the input data contains the substring s3. Bob wants these solutions to fail single test. What is the minimal length of test, which couldn' t be passed by all three Bob' s solutions?",
    "input": "There are exactly 3 lines in the input data. The i- th line contains string si. All the strings are non- empty, consists of lowercase Latin letters, the length of each string doesn' t exceed 105.",
    "output": "Output one number \u2014 what is minimal length of the string, containing s1, s2 and s3 as substrings.",
    "note": "",
    "topics": [
      "hashing",
      "strings"
    ]
  },
  {
    "title": "Jabber ID",
    "url": "https://codeforces.com/problemset/problem/21/A",
    "history": "Jabber ID on the national Berland service \u00abBabber\u00bb has a form < username> @ < hostname> [ / resource] , where < username> \u2014 is a sequence of Latin letters ( lowercase or uppercase) , digits or underscores characters \u00ab_ \u00bb, the length of < username> is between 1 and 16, inclusive. < hostname> \u2014 is a sequence of word separated by periods ( characters \u00ab. \u00bb) , where each word should contain only characters allowed for < username> , the length of each word is between 1 and 16, inclusive. The length of < hostname> is between 1 and 32, inclusive. < resource> \u2014 is a sequence of Latin letters ( lowercase or uppercase) , digits or underscores characters \u00ab_ \u00bb, the length of < resource> is between 1 and 16, inclusive. The content of square brackets is optional \u2014 it can be present or can be absent. There are the samples of correct Jabber IDs: mike@ codeforces. com, 007@ en. codeforces. com/ contest. Your task is to write program which checks if given string is a correct Jabber ID.",
    "input": "The input contains of a single line. The line has the length between 1 and 100 characters, inclusive. Each characters has ASCII- code between 33 and 127, inclusive.",
    "output": "Print YES or NO.",
    "note": "",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Palisection",
    "url": "https://codeforces.com/problemset/problem/17/E",
    "history": "In an English class Nick had nothing to do at all, and remembered about wonderful strings called palindromes. We should remind you that a string is called a palindrome if it can be read the same way both from left to right and from right to left. Here are examples of such strings: \u00abeye\u00bb, \u00abpop\u00bb, \u00ablevel\u00bb, \u00ababa\u00bb, \u00abdeed\u00bb, \u00abracecar\u00bb, \u00abrotor\u00bb, \u00abmadam\u00bb. Nick started to look carefully for all palindromes in the text that they were reading in the class. For each occurrence of each palindrome in the text he wrote a pair \u2014 the position of the beginning and the position of the ending of this occurrence in the text. Nick called each occurrence of each palindrome he found in the text subpalindrome. When he found all the subpalindromes, he decided to find out how many different pairs among these subpalindromes cross. Two subpalindromes cross if they cover common positions in the text. No palindrome can cross itself. Let' s look at the actions, performed by Nick, by the example of text \u00abbabb\u00bb. At first he wrote out all subpalindromes: \u2022 \u00abb\u00bb \u2014 1. . 1 \u2022 \u00abbab\u00bb \u2014 1. . 3 \u2022 \u00aba\u00bb \u2014 2. . 2 \u2022 \u00abb\u00bb \u2014 3. . 3 \u2022 \u00abbb\u00bb \u2014 3. . 4 \u2022 \u00abb\u00bb \u2014 4. . 4 Then Nick counted the amount of different pairs among these subpalindromes that cross. These pairs were six: 1. 1. . 1 cross with 1. . 3 2. 1. . 3 cross with 2. . 2 3. 1. . 3 cross with 3. . 3 4. 1. . 3 cross with 3. . 4 5. 3. . 3 cross with 3. . 4 6. 3. . 4 cross with 4. . 4 Since it' s very exhausting to perform all the described actions manually, Nick asked you to help him and write a program that can find out the amount of different subpalindrome pairs that cross. Two subpalindrome pairs are regarded as different if one of the pairs contains a subpalindrome that the other does not.",
    "input": "The first input line contains integer n ( 1 \u2264 n \u2264 2\u00b7106) \u2014 length of the text. The following line contains n lower- case Latin letters ( from a to z) .",
    "output": "In the only line output the amount of different pairs of two subpalindromes that cross each other. Output the answer modulo 51123987.",
    "note": "",
    "topics": [
      "strings"
    ]
  },
  {
    "title": "Logging",
    "url": "https://codeforces.com/problemset/problem/16/D",
    "history": "The main server of Gomble company received a log of one top- secret process, the name of which can' t be revealed. The log was written in the following format: \u00ab[ date: time] : message\u00bb, where for each \u00ab[ date: time] \u00bb value existed not more than 10 lines. All the files were encoded in a very complicated manner, and only one programmer \u2014 Alex \u2014 managed to decode them. The code was so complicated that Alex needed four weeks to decode it. Right after the decoding process was finished, all the files were deleted. But after the files deletion, Alex noticed that he saved the recordings in format \u00ab[ time] : message\u00bb. So, information about the dates was lost. However, as the lines were added into the log in chronological order, it' s not difficult to say if the recordings could appear during one day or not. It is possible also to find the minimum amount of days during which the log was written. So, to make up for his mistake Alex has to find the minimum amount of days covered by the log. Note that Alex doesn' t have to find the minimum amount of days between the beginning and the end of the logging, he has to find the minimum amount of dates in which records could be done. ( See Sample test 2 for further clarifications) . We should remind you that the process made not more than 10 recordings in a minute. Consider that a midnight belongs to coming day.",
    "input": "The first input line contains number n ( 1 \u2264 n \u2264 100) . The following n lines contain recordings in format \u00ab[ time] : message\u00bb, where time is given in format \u00abhh: mm x. m. \u00bb. For hh two- digit numbers from 01 to 12 are used, for mm two- digit numbers from 00 to 59 are used, and x is either character \u00aba\u00bb or character \u00abp\u00bb. A message is a non- empty sequence of Latin letters and/ or spaces, it doesn' t start or end with a space. The length of each message doesn' t exceed 20.",
    "output": "Output one number \u2014 the minimum amount of days covered by the log.",
    "note": "Formally the 12- hour time format is described at: http: / / en. wikipedia. org/ wiki/ 12- hour_ clock. The problem authors recommend you to look through these descriptions before you start with the problem.",
    "topics": [
      "implementation",
      "strings"
    ]
  },
  {
    "title": "Train and Peter",
    "url": "https://codeforces.com/problemset/problem/8/A",
    "history": "Peter likes to travel by train. He likes it so much that on the train he falls asleep. Once in summer Peter was going by train from city A to city B, and as usual, was sleeping. Then he woke up, started to look through the window and noticed that every railway station has a flag of a particular colour. The boy started to memorize the order of the flags' colours that he had seen. But soon he fell asleep again. Unfortunately, he didn' t sleep long, he woke up and went on memorizing the colours. Then he fell asleep again, and that time he slept till the end of the journey. At the station he told his parents about what he was doing, and wrote two sequences of the colours that he had seen before and after his sleep, respectively. Peter' s parents know that their son likes to fantasize. They give you the list of the flags' colours at the stations that the train passes sequentially on the way from A to B, and ask you to find out if Peter could see those sequences on the way from A to B, or from B to A. Remember, please, that Peter had two periods of wakefulness. Peter' s parents put lowercase Latin letters for colours. The same letter stands for the same colour, different letters \u2014 for different colours.",
    "input": "The input data contains three lines. The first line contains a non- empty string, whose length does not exceed 105, the string consists of lowercase Latin letters \u2014 the flags' colours at the stations on the way from A to B. On the way from B to A the train passes the same stations, but in reverse order. The second line contains the sequence, written by Peter during the first period of wakefulness. The third line contains the sequence, written during the second period of wakefulness. Both sequences are non- empty, consist of lowercase Latin letters, and the length of each does not exceed 100 letters. Each of the sequences is written in chronological order.",
    "output": "Output one of the four words without inverted commas: \u00abforward\u00bb \u2014 if Peter could see such sequences only on the way from A to B; \u00abbackward\u00bb \u2014 if Peter could see such sequences on the way from B to A; \u00abboth\u00bb \u2014 if Peter could see such sequences both on the way from A to B, and on the way from B to A; \u00abfantasy\u00bb \u2014 if Peter could not see such sequences.",
    "note": "It is assumed that the train moves all the time, so one flag cannot be seen twice. There are no flags at stations A and B.",
    "topics": [
      "strings"
    ]
  },
  {
    "title": "Palindrome Degree",
    "url": "https://codeforces.com/problemset/problem/7/D",
    "history": "String s of length n is called k- palindrome, if it is a palindrome itself, and its prefix and suffix of length are ( k - 1) - palindromes. By definition, any string ( even empty) is 0- palindrome. Let' s call the palindrome degree of string s such a maximum number k, for which s is k- palindrome. For example, \" abaaba\" has degree equals to 3. You are given a string. Your task is to find the sum of the palindrome degrees of all its prefixes.",
    "input": "The first line of the input data contains a non- empty string, consisting of Latin letters and digits. The length of the string does not exceed 5\u00b7106. The string is case- sensitive.",
    "output": "Output the only number \u2014 the sum of the polindrome degrees of all the string' s prefixes.",
    "note": "",
    "topics": [
      "hashing",
      "strings"
    ]
  },
  {
    "title": "Longest Regular Bracket Sequence",
    "url": "https://codeforces.com/problemset/problem/5/C",
    "history": "This is yet another problem dealing with regular bracket sequences. We should remind you that a bracket sequence is called regular, if by inserting \u00ab+ \u00bb and \u00ab1\u00bb into it we can get a correct mathematical expression. For example, sequences \u00ab( ( ) ) ( ) \u00bb, \u00ab( ) \u00bb and \u00ab( ( ) ( ( ) ) ) \u00bb are regular, while \u00ab) ( \u00bb, \u00ab( ( ) \u00bb and \u00ab( ( ) ) ) ( \u00bb are not. You are given a string of \u00ab( \u00bb and \u00ab) \u00bb characters. You are to find its longest substring that is a regular bracket sequence. You are to find the number of such substrings as well.",
    "input": "The first line of the input file contains a non- empty string, consisting of \u00ab( \u00bb and \u00ab) \u00bb characters. Its length does not exceed 106.",
    "output": "Print the length of the longest substring that is a regular bracket sequence, and the number of such substrings. If there are no such substrings, write the only line containing \" 0 1\" .",
    "note": "",
    "topics": [
      "constructive algorithms",
      "data structures",
      "dp",
      "greedy",
      "sortings",
      "strings"
    ]
  },
  {
    "title": "Center Alignment",
    "url": "https://codeforces.com/problemset/problem/5/B",
    "history": "Almost every text editor has a built- in function of center text alignment. The developers of the popular in Berland text editor \u00abTextpad\u00bb decided to introduce this functionality into the fourth release of the product. You are to implement the alignment in the shortest possible time. Good luck!",
    "input": "The input file consists of one or more lines, each of the lines contains Latin letters, digits and/ or spaces. The lines cannot start or end with a space. It is guaranteed that at least one of the lines has positive length. The length of each line and the total amount of the lines do not exceed 1000.",
    "output": "Format the given text, aligning it center. Frame the whole text with characters \u00ab* \u00bb of the minimum size. If a line cannot be aligned perfectly ( for example, the line has even length, while the width of the block is uneven) , you should place such lines rounding down the distance to the left or to the right edge and bringing them closer left or right alternatively ( you should start with bringing left) . Study the sample tests carefully to understand the output format better.",
    "note": "",
    "topics": [
      "implementation",
      "strings"
    ]
  }
]